var THREE;
(function (THREE) {
    THREE.REVISION = '93dev';
    THREE.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    };
    THREE.CullFaceNone = 0;
    THREE.CullFaceBack = 1;
    THREE.CullFaceFront = 2;
    THREE.CullFaceFrontBack = 3;
    THREE.FrontFaceDirectionCW = 0;
    THREE.FrontFaceDirectionCCW = 1;
    THREE.BasicShadowMap = 0;
    THREE.PCFShadowMap = 1;
    THREE.PCFSoftShadowMap = 2;
    THREE.FrontSide = 0;
    THREE.BackSide = 1;
    THREE.DoubleSide = 2;
    THREE.FlatShading = 1;
    THREE.SmoothShading = 2;
    THREE.NoColors = 0;
    THREE.FaceColors = 1;
    THREE.VertexColors = 2;
    THREE.NoBlending = 0;
    THREE.NormalBlending = 1;
    THREE.AdditiveBlending = 2;
    THREE.SubtractiveBlending = 3;
    THREE.MultiplyBlending = 4;
    THREE.CustomBlending = 5;
    THREE.AddEquation = 100;
    THREE.SubtractEquation = 101;
    THREE.ReverseSubtractEquation = 102;
    THREE.MinEquation = 103;
    THREE.MaxEquation = 104;
    THREE.ZeroFactor = 200;
    THREE.OneFactor = 201;
    THREE.SrcColorFactor = 202;
    THREE.OneMinusSrcColorFactor = 203;
    THREE.SrcAlphaFactor = 204;
    THREE.OneMinusSrcAlphaFactor = 205;
    THREE.DstAlphaFactor = 206;
    THREE.OneMinusDstAlphaFactor = 207;
    THREE.DstColorFactor = 208;
    THREE.OneMinusDstColorFactor = 209;
    THREE.SrcAlphaSaturateFactor = 210;
    THREE.NeverDepth = 0;
    THREE.AlwaysDepth = 1;
    THREE.LessDepth = 2;
    THREE.LessEqualDepth = 3;
    THREE.EqualDepth = 4;
    THREE.GreaterEqualDepth = 5;
    THREE.GreaterDepth = 6;
    THREE.NotEqualDepth = 7;
    THREE.MultiplyOperation = 0;
    THREE.MixOperation = 1;
    THREE.AddOperation = 2;
    THREE.NoToneMapping = 0;
    THREE.LinearToneMapping = 1;
    THREE.ReinhardToneMapping = 2;
    THREE.Uncharted2ToneMapping = 3;
    THREE.CineonToneMapping = 4;
    THREE.UVMapping = 300;
    THREE.CubeReflectionMapping = 301;
    THREE.CubeRefractionMapping = 302;
    THREE.EquirectangularReflectionMapping = 303;
    THREE.EquirectangularRefractionMapping = 304;
    THREE.SphericalReflectionMapping = 305;
    THREE.CubeUVReflectionMapping = 306;
    THREE.CubeUVRefractionMapping = 307;
    THREE.RepeatWrapping = 1000;
    THREE.ClampToEdgeWrapping = 1001;
    THREE.MirroredRepeatWrapping = 1002;
    THREE.NearestFilter = 1003;
    THREE.NearestMipMapNearestFilter = 1004;
    THREE.NearestMipMapLinearFilter = 1005;
    THREE.LinearFilter = 1006;
    THREE.LinearMipMapNearestFilter = 1007;
    THREE.LinearMipMapLinearFilter = 1008;
    THREE.UnsignedByteType = 1009;
    THREE.ByteType = 1010;
    THREE.ShortType = 1011;
    THREE.UnsignedShortType = 1012;
    THREE.IntType = 1013;
    THREE.UnsignedIntType = 1014;
    THREE.FloatType = 1015;
    THREE.HalfFloatType = 1016;
    THREE.UnsignedShort4444Type = 1017;
    THREE.UnsignedShort5551Type = 1018;
    THREE.UnsignedShort565Type = 1019;
    THREE.UnsignedInt248Type = 1020;
    THREE.AlphaFormat = 1021;
    THREE.RGBFormat = 1022;
    THREE.RGBAFormat = 1023;
    THREE.LuminanceFormat = 1024;
    THREE.LuminanceAlphaFormat = 1025;
    THREE.RGBEFormat = THREE.RGBAFormat;
    THREE.DepthFormat = 1026;
    THREE.DepthStencilFormat = 1027;
    THREE.RGB_S3TC_DXT1_Format = 33776;
    THREE.RGBA_S3TC_DXT1_Format = 33777;
    THREE.RGBA_S3TC_DXT3_Format = 33778;
    THREE.RGBA_S3TC_DXT5_Format = 33779;
    THREE.RGB_PVRTC_4BPPV1_Format = 35840;
    THREE.RGB_PVRTC_2BPPV1_Format = 35841;
    THREE.RGBA_PVRTC_4BPPV1_Format = 35842;
    THREE.RGBA_PVRTC_2BPPV1_Format = 35843;
    THREE.RGB_ETC1_Format = 36196;
    THREE.RGBA_ASTC_4x4_Format = 37808;
    THREE.RGBA_ASTC_5x4_Format = 37809;
    THREE.RGBA_ASTC_5x5_Format = 37810;
    THREE.RGBA_ASTC_6x5_Format = 37811;
    THREE.RGBA_ASTC_6x6_Format = 37812;
    THREE.RGBA_ASTC_8x5_Format = 37813;
    THREE.RGBA_ASTC_8x6_Format = 37814;
    THREE.RGBA_ASTC_8x8_Format = 37815;
    THREE.RGBA_ASTC_10x5_Format = 37816;
    THREE.RGBA_ASTC_10x6_Format = 37817;
    THREE.RGBA_ASTC_10x8_Format = 37818;
    THREE.RGBA_ASTC_10x10_Format = 37819;
    THREE.RGBA_ASTC_12x10_Format = 37820;
    THREE.RGBA_ASTC_12x12_Format = 37821;
    THREE.LoopOnce = 2200;
    THREE.LoopRepeat = 2201;
    THREE.LoopPingPong = 2202;
    THREE.InterpolateDiscrete = 2300;
    THREE.InterpolateLinear = 2301;
    THREE.InterpolateSmooth = 2302;
    THREE.ZeroCurvatureEnding = 2400;
    THREE.ZeroSlopeEnding = 2401;
    THREE.WrapAroundEnding = 2402;
    THREE.TrianglesDrawMode = 0;
    THREE.TriangleStripDrawMode = 1;
    THREE.TriangleFanDrawMode = 2;
    THREE.LinearEncoding = 3000;
    THREE.sRGBEncoding = 3001;
    THREE.GammaEncoding = 3007;
    THREE.RGBEEncoding = 3002;
    THREE.LogLuvEncoding = 3003;
    THREE.RGBM7Encoding = 3004;
    THREE.RGBM16Encoding = 3005;
    THREE.RGBDEncoding = 3006;
    THREE.BasicDepthPacking = 3200;
    THREE.RGBADepthPacking = 3201;
})(THREE || (THREE = {}));
// Polyfills
var THREE;
// Polyfills
(function (THREE) {
    if (Number.EPSILON === undefined) {
        Number.EPSILON = Math.pow(2, -52);
    }
    if (Number.isInteger === undefined) {
        // Missing in IE
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
        Number.isInteger = function (value) {
            return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
        };
    }
    //
    if (Math.sign === undefined) {
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
        Math.sign = function (x) {
            return (x < 0) ? -1 : (x > 0) ? 1 : +x;
        };
    }
    if ('name' in Function.prototype === false) {
        // Missing in IE
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
        Object.defineProperty(Function.prototype, 'name', {
            get: function () {
                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
            }
        });
    }
    if (Object.assign === undefined) {
        // Missing in IE
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
        (function () {
            Object.assign = function (target) {
                'use strict';
                if (target === undefined || target === null) {
                    throw new TypeError('Cannot convert undefined or null to object');
                }
                var output = Object(target);
                for (var index = 1; index < arguments.length; index++) {
                    var source = arguments[index];
                    if (source !== undefined && source !== null) {
                        for (var nextKey in source) {
                            if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
                                output[nextKey] = source[nextKey];
                            }
                        }
                    }
                }
                return output;
            };
        })();
    }
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    function arrayMin(array) {
        if (array.length === 0)
            return Infinity;
        var min = array[0];
        for (var i = 1, l = array.length; i < l; ++i) {
            if (array[i] < min)
                min = array[i];
        }
        return min;
    }
    THREE.arrayMin = arrayMin;
    function arrayMax(array) {
        if (array.length === 0)
            return -Infinity;
        var max = array[0];
        for (var i = 1, l = array.length; i < l; ++i) {
            if (array[i] > max)
                max = array[i];
        }
        return max;
    }
    THREE.arrayMax = arrayMax;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class AnimationAction {
        constructor(mixer, clip, localRoot) {
            this._mixer = mixer;
            this._clip = clip;
            this._localRoot = localRoot || null;
            var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
            var interpolantSettings = {
                endingStart: THREE.ZeroCurvatureEnding,
                endingEnd: THREE.ZeroCurvatureEnding
            };
            for (var i = 0; i !== nTracks; ++i) {
                var interpolant = tracks[i].createInterpolant(null);
                interpolants[i] = interpolant;
                interpolant.settings = interpolantSettings;
            }
            this._interpolantSettings = interpolantSettings;
            this._interpolants = interpolants; // bound by the mixer
            // inside: PropertyMixer (managed by the mixer)
            this._propertyBindings = new Array(nTracks);
            this._cacheIndex = null; // for the memory manager
            this._byClipCacheIndex = null; // for the memory manager
            this._timeScaleInterpolant = null;
            this._weightInterpolant = null;
            this.loop = THREE.LoopRepeat;
            this._loopCount = -1;
            // global mixer time when the action is to be started
            // it's set back to 'null' upon start of the action
            this._startTime = null;
            // scaled local time of the action
            // gets clamped or wrapped to 0..clip.duration according to loop
            this.time = 0;
            this.timeScale = 1;
            this._effectiveTimeScale = 1;
            this.weight = 1;
            this._effectiveWeight = 1;
            this.repetitions = Infinity; // no. of repetitions when looping
            this.paused = false; // true -> zero effective time scale
            this.enabled = true; // false -> zero effective weight
            this.clampWhenFinished = false; // keep feeding the last frame?
            this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
            this.zeroSlopeAtEnd = true; // clips for start, loop and end
        }
        // Object.assign(AnimationAction.prototype, {
        // State & Scheduling
        play() {
            this._mixer._activateAction(this);
            return this;
        }
        stop() {
            this._mixer._deactivateAction(this);
            return this.reset();
        }
        reset() {
            this.paused = false;
            this.enabled = true;
            this.time = 0; // restart clip
            this._loopCount = -1; // forget previous loops
            this._startTime = null; // forget scheduling
            return this.stopFading().stopWarping();
        }
        isRunning() {
            return this.enabled && !this.paused && this.timeScale !== 0 &&
                this._startTime === null && this._mixer._isActiveAction(this);
        }
        // return true when play has been called
        isScheduled() {
            return this._mixer._isActiveAction(this);
        }
        startAt(time) {
            this._startTime = time;
            return this;
        }
        setLoop(mode, repetitions) {
            this.loop = mode;
            this.repetitions = repetitions;
            return this;
        }
        // Weight
        // set the weight stopping any scheduled fading
        // although .enabled = false yields an effective weight of zero, this
        // method does *not* change .enabled, because it would be confusing
        setEffectiveWeight(weight) {
            this.weight = weight;
            // note: same logic as when updated at runtime
            this._effectiveWeight = this.enabled ? weight : 0;
            return this.stopFading();
        }
        // return the weight considering fading and .enabled
        getEffectiveWeight() {
            return this._effectiveWeight;
        }
        fadeIn(duration) {
            return this._scheduleFading(duration, 0, 1);
        }
        fadeOut(duration) {
            return this._scheduleFading(duration, 1, 0);
        }
        crossFadeFrom(fadeOutAction, duration, warp) {
            fadeOutAction.fadeOut(duration);
            this.fadeIn(duration);
            if (warp) {
                var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
                fadeOutAction.warp(1.0, startEndRatio, duration);
                this.warp(endStartRatio, 1.0, duration);
            }
            return this;
        }
        crossFadeTo(fadeInAction, duration, warp) {
            return fadeInAction.crossFadeFrom(this, duration, warp);
        }
        stopFading() {
            var weightInterpolant = this._weightInterpolant;
            if (weightInterpolant !== null) {
                this._weightInterpolant = null;
                this._mixer._takeBackControlInterpolant(weightInterpolant);
            }
            return this;
        }
        // Time Scale Control
        // set the time scale stopping any scheduled warping
        // although .paused = true yields an effective time scale of zero, this
        // method does *not* change .paused, because it would be confusing
        setEffectiveTimeScale(timeScale) {
            this.timeScale = timeScale;
            this._effectiveTimeScale = this.paused ? 0 : timeScale;
            return this.stopWarping();
        }
        // return the time scale considering warping and .paused
        getEffectiveTimeScale() {
            return this._effectiveTimeScale;
        }
        setDuration(duration) {
            this.timeScale = this._clip.duration / duration;
            return this.stopWarping();
        }
        syncWith(action) {
            this.time = action.time;
            this.timeScale = action.timeScale;
            return this.stopWarping();
        }
        halt(duration) {
            return this.warp(this._effectiveTimeScale, 0, duration);
        }
        warp(startTimeScale, endTimeScale, duration) {
            var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
            if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant();
                this._timeScaleInterpolant = interpolant;
            }
            var times = interpolant.parameterPositions, values = interpolant.sampleValues;
            times[0] = now;
            times[1] = now + duration;
            values[0] = startTimeScale / timeScale;
            values[1] = endTimeScale / timeScale;
            return this;
        }
        stopWarping() {
            var timeScaleInterpolant = this._timeScaleInterpolant;
            if (timeScaleInterpolant !== null) {
                this._timeScaleInterpolant = null;
                this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
            }
            return this;
        }
        // Object Accessors
        getMixer() {
            return this._mixer;
        }
        getClip() {
            return this._clip;
        }
        getRoot() {
            return this._localRoot || this._mixer._root;
        }
        // Interna
        t(time, deltaTime, timeDirection, accuIndex) {
            // called by the mixer
            if (!this.enabled) {
                // call ._updateWeight() to update ._effectiveWeight
                this._updateWeight(time);
                return;
            }
            var startTime = this._startTime;
            if (startTime !== null) {
                // check for scheduled start of action
                var timeRunning = (time - startTime) * timeDirection;
                if (timeRunning < 0 || timeDirection === 0) {
                    return; // yet to come / don't decide when delta = 0
                }
                // start
                this._startTime = null; // unschedule
                deltaTime = timeDirection * timeRunning;
            }
            // apply time scale and advance time
            deltaTime *= this._updateTimeScale(time);
            var clipTime = this._updateTime(deltaTime);
            // note: _updateTime may disable the action resulting in
            // an effective weight of 0
            var weight = this._updateWeight(time);
            if (weight > 0) {
                var interpolants = this._interpolants;
                var propertyMixers = this._propertyBindings;
                for (var j = 0, m = interpolants.length; j !== m; ++j) {
                    interpolants[j].evaluate(clipTime);
                    propertyMixers[j].accumulate(accuIndex, weight);
                }
            }
        }
        _updateWeight(time) {
            var weight = 0;
            if (this.enabled) {
                weight = this.weight;
                var interpolant = this._weightInterpolant;
                if (interpolant !== null) {
                    var interpolantValue = interpolant.evaluate(time)[0];
                    weight *= interpolantValue;
                    if (time > interpolant.parameterPositions[1]) {
                        this.stopFading();
                        if (interpolantValue === 0) {
                            // faded out, disable
                            this.enabled = false;
                        }
                    }
                }
            }
            this._effectiveWeight = weight;
            return weight;
        }
        _updateTimeScale(time) {
            var timeScale = 0;
            if (!this.paused) {
                timeScale = this.timeScale;
                var interpolant = this._timeScaleInterpolant;
                if (interpolant !== null) {
                    var interpolantValue = interpolant.evaluate(time)[0];
                    timeScale *= interpolantValue;
                    if (time > interpolant.parameterPositions[1]) {
                        this.stopWarping();
                        if (timeScale === 0) {
                            // motion has halted, pause
                            this.paused = true;
                        }
                        else {
                            // warp done - apply final time scale
                            this.timeScale = timeScale;
                        }
                    }
                }
            }
            this._effectiveTimeScale = timeScale;
            return timeScale;
        }
        _updateTime(deltaTime) {
            var time = this.time + deltaTime;
            if (deltaTime === 0)
                return time;
            var duration = this._clip.duration, loop = this.loop, loopCount = this._loopCount;
            if (loop === THREE.LoopOnce) {
                if (loopCount === -1) {
                    // just started
                    this._loopCount = 0;
                    this._setEndings(true, true, false);
                }
                handle_stop: {
                    if (time >= duration) {
                        time = duration;
                    }
                    else if (time < 0) {
                        time = 0;
                    }
                    else
                        break handle_stop;
                    if (this.clampWhenFinished)
                        this.paused = true;
                    else
                        this.enabled = false;
                    this._mixer.dispatchEvent({
                        type: 'finished', action: this,
                        direction: deltaTime < 0 ? -1 : 1
                    });
                }
            }
            else { // repetitive Repeat or PingPong
                var pingPong = (loop === THREE.LoopPingPong);
                if (loopCount === -1) {
                    // just started
                    if (deltaTime >= 0) {
                        loopCount = 0;
                        this._setEndings(true, this.repetitions === 0, pingPong);
                    }
                    else {
                        // when looping in reverse direction, the initial
                        // transition through zero counts as a repetition,
                        // so leave loopCount at -1
                        this._setEndings(this.repetitions === 0, true, pingPong);
                    }
                }
                if (time >= duration || time < 0) {
                    // wrap around
                    var loopDelta = Math.floor(time / duration); // signed
                    time -= duration * loopDelta;
                    loopCount += Math.abs(loopDelta);
                    var pending = this.repetitions - loopCount;
                    if (pending <= 0) {
                        // have to stop (switch state, clamp time, fire event)
                        if (this.clampWhenFinished)
                            this.paused = true;
                        else
                            this.enabled = false;
                        time = deltaTime > 0 ? duration : 0;
                        this._mixer.dispatchEvent({
                            type: 'finished', action: this,
                            direction: deltaTime > 0 ? 1 : -1
                        });
                    }
                    else {
                        // keep running
                        if (pending === 1) {
                            // entering the last round
                            var atStart = deltaTime < 0;
                            this._setEndings(atStart, !atStart, pingPong);
                        }
                        else {
                            this._setEndings(false, false, pingPong);
                        }
                        this._loopCount = loopCount;
                        this._mixer.dispatchEvent({
                            type: 'loop', action: this, loopDelta: loopDelta
                        });
                    }
                }
                if (pingPong && (loopCount & 1) === 1) {
                    // invert time for the "pong round"
                    this.time = time;
                    return duration - time;
                }
            }
            this.time = time;
            return time;
        }
        _setEndings(atStart, atEnd, pingPong) {
            var settings = this._interpolantSettings;
            if (pingPong) {
                settings.endingStart = THREE.ZeroSlopeEnding;
                settings.endingEnd = THREE.ZeroSlopeEnding;
            }
            else {
                // assuming for LoopOnce atStart == atEnd == true
                if (atStart) {
                    settings.endingStart = this.zeroSlopeAtStart ? THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;
                }
                else {
                    settings.endingStart = THREE.WrapAroundEnding;
                }
                if (atEnd) {
                    settings.endingEnd = this.zeroSlopeAtEnd ? THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;
                }
                else {
                    settings.endingEnd = THREE.WrapAroundEnding;
                }
            }
        }
        _scheduleFading(duration, weightNow, weightThen) {
            var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
            if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant();
                this._weightInterpolant = interpolant;
            }
            var times = interpolant.parameterPositions, values = interpolant.sampleValues;
            times[0] = now;
            values[0] = weightNow;
            times[1] = now + duration;
            values[1] = weightThen;
            return this;
        }
    }
    THREE.AnimationAction = AnimationAction;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class AnimationClip {
        constructor(name, duration, tracks) {
            this.name = name;
            this.tracks = tracks;
            this.duration = (duration !== undefined) ? duration : -1;
            this.uuid = THREE._Math.generateUUID();
            // this means it should figure out its duration by scanning the tracks
            if (this.duration < 0) {
                this.resetDuration();
            }
            this.optimize();
        }
        //  Object.assign(AnimationClip, {
        static parse(json) {
            var tracks = [], jsonTracks = json.tracks, frameTime = 1.0 / (json.fps || 1.0);
            for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
                tracks.push(THREE.KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));
            }
            return new AnimationClip(json.name, json.duration, tracks);
        }
        static toJSON(clip) {
            var tracks = [], clipTracks = clip.tracks;
            var json = {
                'name': clip.name,
                'duration': clip.duration,
                'tracks': tracks,
                'uuid': clip.uuid
            };
            for (var i = 0, n = clipTracks.length; i !== n; ++i) {
                tracks.push(THREE.KeyframeTrack.toJSON(clipTracks[i]));
            }
            return json;
        }
        static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
            var numMorphTargets = morphTargetSequence.length;
            var tracks = [];
            for (var i = 0; i < numMorphTargets; i++) {
                var times = [];
                var values = [];
                times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
                values.push(0, 1, 0);
                var order = THREE.AnimationUtils.getKeyframeOrder(times);
                times = THREE.AnimationUtils.sortedArray(times, 1, order);
                values = THREE.AnimationUtils.sortedArray(values, 1, order);
                // if there is a key at the first frame, duplicate it as the
                // last frame as well for perfect loop.
                if (!noLoop && times[0] === 0) {
                    times.push(numMorphTargets);
                    values.push(values[0]);
                }
                tracks.push(new THREE.NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
            }
            return new AnimationClip(name, -1, tracks);
        }
        static findByName(objectOrClipArray, name) {
            var clipArray = objectOrClipArray;
            if (!Array.isArray(objectOrClipArray)) {
                var o = objectOrClipArray;
                clipArray = o.geometry && o.geometry.animations || o.animations;
            }
            for (var i = 0; i < clipArray.length; i++) {
                if (clipArray[i].name === name) {
                    return clipArray[i];
                }
            }
            return null;
        }
        static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
            var animationToMorphTargets = {};
            // tested with https://regex101.com/ on trick sequences
            // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
            var pattern = /^([\w-]*?)([\d]+)$/;
            // sort morph target names into animation groups based
            // patterns like Walk_001, Walk_002, Run_001, Run_002
            for (var i = 0, il = morphTargets.length; i < il; i++) {
                var morphTarget = morphTargets[i];
                var parts = morphTarget.name.match(pattern);
                if (parts && parts.length > 1) {
                    var name = parts[1];
                    var animationMorphTargets = animationToMorphTargets[name];
                    if (!animationMorphTargets) {
                        animationToMorphTargets[name] = animationMorphTargets = [];
                    }
                    animationMorphTargets.push(morphTarget);
                }
            }
            var clips = [];
            for (var name_1 in animationToMorphTargets) {
                clips.push(AnimationClip.CreateFromMorphTargetSequence(name_1, animationToMorphTargets[name_1], fps, noLoop));
            }
            return clips;
        }
        // parse the animation.hierarchy format
        static parseAnimation(animation, bones) {
            if (!animation) {
                console.error('THREE.AnimationClip: No animation in JSONLoader data.');
                return null;
            }
            var addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
                // only return track if there are actually keys.
                if (animationKeys.length !== 0) {
                    var times = [];
                    var values = [];
                    THREE.AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
                    // empty keys are filtered out, so check again
                    if (times.length !== 0) {
                        destTracks.push(new trackType(trackName, times, values));
                    }
                }
            };
            var tracks = [];
            var clipName = animation.name || 'default';
            // automatic length determination in AnimationClip.
            var duration = animation.length || -1;
            var fps = animation.fps || 30;
            var hierarchyTracks = animation.hierarchy || [];
            for (var h = 0; h < hierarchyTracks.length; h++) {
                var animationKeys = hierarchyTracks[h].keys;
                // skip empty tracks
                if (!animationKeys || animationKeys.length === 0)
                    continue;
                // process morph targets
                if (animationKeys[0].morphTargets) {
                    // figure out all morph targets used in this track
                    var morphTargetNames = {};
                    for (var k = 0; k < animationKeys.length; k++) {
                        if (animationKeys[k].morphTargets) {
                            for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                            }
                        }
                    }
                    // create a track for each morph target with all zero
                    // morphTargetInfluences except for the keys in which
                    // the morphTarget is named.
                    for (var morphTargetName in morphTargetNames) {
                        var times = [];
                        var values = [];
                        for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                            var animationKey = animationKeys[k];
                            times.push(animationKey.time);
                            values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);
                        }
                        tracks.push(new THREE.NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                    }
                    duration = morphTargetNames.length * (fps || 1.0);
                }
                else {
                    // ...assume skeletal animation
                    var boneName = '.bones[' + bones[h].name + ']';
                    addNonemptyTrack(THREE.VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
                    addNonemptyTrack(THREE.QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
                    addNonemptyTrack(THREE.VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
                }
            }
            if (tracks.length === 0) {
                return null;
            }
            var clip = new AnimationClip(clipName, duration, tracks);
            return clip;
        }
        resetDuration() {
            var tracks = this.tracks, duration = 0;
            for (var i = 0, n = tracks.length; i !== n; ++i) {
                var track = this.tracks[i];
                duration = Math.max(duration, track.times[track.times.length - 1]);
            }
            this.duration = duration;
        }
        trim() {
            for (var i = 0; i < this.tracks.length; i++) {
                this.tracks[i].trim(0, this.duration);
            }
            return this;
        }
        optimize() {
            for (var i = 0; i < this.tracks.length; i++) {
                this.tracks[i].optimize();
            }
            return this;
        }
    }
    THREE.AnimationClip = AnimationClip;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class EventDispatcher {
        constructor() {
        }
        addEventListener(type, listener) {
            if (this._listeners === undefined)
                this._listeners = {};
            var listeners = this._listeners;
            if (listeners[type] === undefined) {
                listeners[type] = [];
            }
            if (listeners[type].indexOf(listener) === -1) {
                listeners[type].push(listener);
            }
        }
        hasEventListener(type, listener) {
            if (this._listeners === undefined)
                return false;
            var listeners = this._listeners;
            return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
        }
        removeEventListener(type, listener) {
            if (this._listeners === undefined)
                return;
            var listeners = this._listeners;
            var listenerArray = listeners[type];
            if (listenerArray !== undefined) {
                var index = listenerArray.indexOf(listener);
                if (index !== -1) {
                    listenerArray.splice(index, 1);
                }
            }
        }
        dispatchEvent(event) {
            if (this._listeners === undefined)
                return;
            var listeners = this._listeners;
            var listenerArray = listeners[event.type];
            if (listenerArray !== undefined) {
                event.target = this;
                var array = listenerArray.slice(0);
                for (var i = 0, l = array.length; i < l; i++) {
                    array[i].call(this, event);
                }
            }
        }
    }
    THREE.EventDispatcher = EventDispatcher;
})(THREE || (THREE = {}));
/// <reference path="../core/EventDispatcher.ts" />
var THREE;
/// <reference path="../core/EventDispatcher.ts" />
(function (THREE) {
    class AnimationMixer extends THREE.EventDispatcher {
        constructor(root) {
            super();
            this._controlInterpolantsResultBuffer = new Float32Array(1);
            this._root = root;
            this._initMemoryManager();
            this._accuIndex = 0;
            this.time = 0;
            this.timeScale = 1.0;
        }
        // AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        //constructor: AnimationMixer,
        _bindAction(action, prototypeAction) {
            var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
            if (bindingsByName === undefined) {
                bindingsByName = {};
                bindingsByRoot[rootUuid] = bindingsByName;
            }
            for (var i = 0; i !== nTracks; ++i) {
                var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
                if (binding !== undefined) {
                    bindings[i] = binding;
                }
                else {
                    binding = bindings[i];
                    if (binding !== undefined) {
                        // existing binding, make sure the cache knows
                        if (binding._cacheIndex === null) {
                            ++binding.referenceCount;
                            this._addInactiveBinding(binding, rootUuid, trackName);
                        }
                        continue;
                    }
                    var path = prototypeAction && prototypeAction.
                        _propertyBindings[i].binding.parsedPath;
                    binding = new THREE.PropertyMixer(THREE.PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                    ++binding.referenceCount;
                    this._addInactiveBinding(binding, rootUuid, trackName);
                    bindings[i] = binding;
                }
                interpolants[i].resultBuffer = binding.buffer;
            }
        }
        _activateAction(action) {
            if (!this._isActiveAction(action)) {
                if (action._cacheIndex === null) {
                    // this action has been forgotten by the cache, but the user
                    // appears to be still using it -> rebind
                    var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                    this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                    this._addInactiveAction(action, clipUuid, rootUuid);
                }
                var bindings = action._propertyBindings;
                // increment reference counts / sort out state
                for (var i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    if (binding.useCount++ === 0) {
                        this._lendBinding(binding);
                        binding.saveOriginalState();
                    }
                }
                this._lendAction(action);
            }
        }
        _deactivateAction(action) {
            if (this._isActiveAction(action)) {
                var bindings = action._propertyBindings;
                // decrement reference counts / sort out state
                for (var i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    if (--binding.useCount === 0) {
                        binding.restoreOriginalState();
                        this._takeBackBinding(binding);
                    }
                }
                this._takeBackAction(action);
            }
        }
        // Memory manager
        _initMemoryManager() {
            this._actions = []; // 'nActiveActions' followed by inactive ones
            this._nActiveActions = 0;
            this._actionsByClip = {};
            // inside:
            // {
            // 		knownActions: Array< AnimationAction >	- used as prototypes
            // 		actionByRoot: AnimationAction			- lookup
            // }
            this._bindings = []; // 'nActiveBindings' followed by inactive ones
            this._nActiveBindings = 0;
            this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
            this._controlInterpolants = []; // same game as above
            this._nActiveControlInterpolants = 0;
            var scope = this;
            this.stats = {
                actions: {
                    get total() {
                        return scope._actions.length;
                    },
                    get inUse() {
                        return scope._nActiveActions;
                    }
                },
                bindings: {
                    get total() {
                        return scope._bindings.length;
                    },
                    get inUse() {
                        return scope._nActiveBindings;
                    }
                },
                controlInterpolants: {
                    get total() {
                        return scope._controlInterpolants.length;
                    },
                    get inUse() {
                        return scope._nActiveControlInterpolants;
                    }
                }
            };
        }
        // Memory management for AnimationAction objects
        _isActiveAction(action) {
            var index = action._cacheIndex;
            return index !== null && index < this._nActiveActions;
        }
        _addInactiveAction(action, clipUuid, rootUuid) {
            var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
            if (actionsForClip === undefined) {
                actionsForClip = {
                    knownActions: [action],
                    actionByRoot: {}
                };
                action._byClipCacheIndex = 0;
                actionsByClip[clipUuid] = actionsForClip;
            }
            else {
                var knownActions = actionsForClip.knownActions;
                action._byClipCacheIndex = knownActions.length;
                knownActions.push(action);
            }
            action._cacheIndex = actions.length;
            actions.push(action);
            actionsForClip.actionByRoot[rootUuid] = action;
        }
        _removeInactiveAction(action) {
            var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
            lastInactiveAction._cacheIndex = cacheIndex;
            actions[cacheIndex] = lastInactiveAction;
            actions.pop();
            action._cacheIndex = null;
            var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
            lastKnownAction._byClipCacheIndex = byClipCacheIndex;
            knownActionsForClip[byClipCacheIndex] = lastKnownAction;
            knownActionsForClip.pop();
            action._byClipCacheIndex = null;
            var actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
            delete actionByRoot[rootUuid];
            if (knownActionsForClip.length === 0) {
                delete actionsByClip[clipUuid];
            }
            this._removeInactiveBindingsForAction(action);
        }
        _removeInactiveBindingsForAction(action) {
            var bindings = action._propertyBindings;
            for (var i = 0, n = bindings.length; i !== n; ++i) {
                var binding = bindings[i];
                if (--binding.referenceCount === 0) {
                    this._removeInactiveBinding(binding);
                }
            }
        }
        _lendAction(action) {
            // [ active actions |  inactive actions  ]
            // [  active actions >| inactive actions ]
            //                 s        a
            //                  <-swap->
            //                 a        s
            var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
            action._cacheIndex = lastActiveIndex;
            actions[lastActiveIndex] = action;
            firstInactiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = firstInactiveAction;
        }
        _takeBackAction(action) {
            // [  active actions  | inactive actions ]
            // [ active actions |< inactive actions  ]
            //        a        s
            //         <-swap->
            //        s        a
            var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
            action._cacheIndex = firstInactiveIndex;
            actions[firstInactiveIndex] = action;
            lastActiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = lastActiveAction;
        }
        // Memory management for PropertyMixer objects
        _addInactiveBinding(binding, rootUuid, trackName) {
            var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
            if (bindingByName === undefined) {
                bindingByName = {};
                bindingsByRoot[rootUuid] = bindingByName;
            }
            bindingByName[trackName] = binding;
            binding._cacheIndex = bindings.length;
            bindings.push(binding);
        }
        _removeInactiveBinding(binding) {
            var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
            lastInactiveBinding._cacheIndex = cacheIndex;
            bindings[cacheIndex] = lastInactiveBinding;
            bindings.pop();
            delete bindingByName[trackName];
            remove_empty_map: {
                for (var _ in bindingByName)
                    break remove_empty_map; // eslint-disable-line no-unused-vars
                delete bindingsByRoot[rootUuid];
            }
        }
        _lendBinding(binding) {
            var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
            binding._cacheIndex = lastActiveIndex;
            bindings[lastActiveIndex] = binding;
            firstInactiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = firstInactiveBinding;
        }
        _takeBackBinding(binding) {
            var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
            binding._cacheIndex = firstInactiveIndex;
            bindings[firstInactiveIndex] = binding;
            lastActiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = lastActiveBinding;
        }
        // Memory management of Interpolants for weight and time scale
        _lendControlInterpolant() {
            var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
            if (interpolant === undefined) {
                interpolant = new THREE.LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
                interpolant.__cacheIndex = lastActiveIndex;
                interpolants[lastActiveIndex] = interpolant;
            }
            return interpolant;
        }
        _takeBackControlInterpolant(interpolant) {
            var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
            interpolant.__cacheIndex = firstInactiveIndex;
            interpolants[firstInactiveIndex] = interpolant;
            lastActiveInterpolant.__cacheIndex = prevIndex;
            interpolants[prevIndex] = lastActiveInterpolant;
        }
        // return an action for a clip optionally using a custom root target
        // object (this method allocates a lot of dynamic memory in case a
        // previously unknown clip/root combination is specified)
        clipAction(clip, optionalRoot) {
            var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ?
                THREE.AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
            if (actionsForClip !== undefined) {
                var existingAction = actionsForClip.actionByRoot[rootUuid];
                if (existingAction !== undefined) {
                    return existingAction;
                }
                // we know the clip, so we don't have to parse all
                // the bindings again but can just copy
                prototypeAction = actionsForClip.knownActions[0];
                // also, take the clip from the prototype action
                if (clipObject === null)
                    clipObject = prototypeAction._clip;
            }
            // clip must be known when specified via string
            if (clipObject === null)
                return null;
            // allocate all resources required to run it
            var newAction = new THREE.AnimationAction(this, clipObject, optionalRoot);
            this._bindAction(newAction, prototypeAction);
            // and make the action known to the memory manager
            this._addInactiveAction(newAction, clipUuid, rootUuid);
            return newAction;
        }
        // get an existing action
        existingAction(clip, optionalRoot) {
            var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ?
                THREE.AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
            if (actionsForClip !== undefined) {
                return actionsForClip.actionByRoot[rootUuid] || null;
            }
            return null;
        }
        // deactivates all previously scheduled actions
        stopAllAction() {
            var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
            this._nActiveActions = 0;
            this._nActiveBindings = 0;
            for (var i = 0; i !== nActions; ++i) {
                actions[i].reset();
            }
            for (var i = 0; i !== nBindings; ++i) {
                bindings[i].useCount = 0;
            }
            return this;
        }
        // advance the time and update apply the animation
        update(deltaTime) {
            deltaTime *= this.timeScale;
            var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
            // run active actions
            for (var i = 0; i !== nActions; ++i) {
                var action = actions[i];
                action._update(time, deltaTime, timeDirection, accuIndex);
            }
            // update scene graph
            var bindings = this._bindings, nBindings = this._nActiveBindings;
            for (var i = 0; i !== nBindings; ++i) {
                bindings[i].apply(accuIndex);
            }
            return this;
        }
        // return this mixer's root target object
        getRoot() {
            return this._root;
        }
        // free all resources specific to a particular clip
        uncacheClip(clip) {
            var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
            if (actionsForClip !== undefined) {
                // note: just calling _removeInactiveAction would mess up the
                // iteration state and also require updating the state we can
                // just throw away
                var actionsToRemove = actionsForClip.knownActions;
                for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
                    var action = actionsToRemove[i];
                    this._deactivateAction(action);
                    var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                    action._cacheIndex = null;
                    action._byClipCacheIndex = null;
                    lastInactiveAction._cacheIndex = cacheIndex;
                    actions[cacheIndex] = lastInactiveAction;
                    actions.pop();
                    this._removeInactiveBindingsForAction(action);
                }
                delete actionsByClip[clipUuid];
            }
        }
        // free all resources specific to a particular root target object
        uncacheRoot(root) {
            var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
            for (var clipUuid in actionsByClip) {
                var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
                if (action !== undefined) {
                    this._deactivateAction(action);
                    this._removeInactiveAction(action);
                }
            }
            var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
            if (bindingByName !== undefined) {
                for (var trackName in bindingByName) {
                    var binding = bindingByName[trackName];
                    binding.restoreOriginalState();
                    this._removeInactiveBinding(binding);
                }
            }
        }
        // remove a targeted clip from the cache
        uncacheAction(clip, optionalRoot) {
            var action = this.existingAction(clip, optionalRoot);
            if (action !== null) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
    }
    THREE.AnimationMixer = AnimationMixer;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class AnimationObjectGroup {
        constructor() {
            this.isAnimationObjectGroup = true;
            this.uuid = THREE._Math.generateUUID();
            // cached objects followed by the active ones
            this._objects = Array.prototype.slice.call(arguments);
            this.nCachedObjects_ = 0; // threshold
            // note: read by PropertyBinding.Composite
            var indices = {};
            this._indicesByUUID = indices; // for bookkeeping
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                indices[arguments[i].uuid] = i;
            }
            this._paths = []; // inside: string
            this._parsedPaths = []; // inside: { we don't care, here }
            this._bindings = []; // inside: Array< PropertyBinding >
            this._bindingsIndicesByPath = {}; // inside: indices in these arrays
            var scope = this;
            this.stats = {
                objects: {
                    get total() {
                        return scope._objects.length;
                    },
                    get inUse() {
                        return this.total - scope.nCachedObjects_;
                    }
                },
                get bindingsPerObject() {
                    return scope._bindings.length;
                }
            };
        }
        // Object.assign(AnimationObjectGroup.prototype, {
        add() {
            var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, knownObject = undefined;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index === undefined) {
                    // unknown object -> add it to the ACTIVE region
                    index = nObjects++;
                    indicesByUUID[uuid] = index;
                    objects.push(object);
                    // accounting is done, now do the same for all bindings
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        bindings[j].push(new THREE.PropertyBinding(object, paths[j], parsedPaths[j]));
                    }
                }
                else if (index < nCachedObjects) {
                    knownObject = objects[index];
                    // move existing object to the ACTIVE region
                    var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;
                    indicesByUUID[uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = object;
                    // accounting is done, now do the same for all bindings
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
                        bindingsForPath[index] = lastCached;
                        if (binding === undefined) {
                            // since we do not bother to create new bindings
                            // for objects that are cached, the binding may
                            // or may not exist
                            binding = new THREE.PropertyBinding(object, paths[j], parsedPaths[j]);
                        }
                        bindingsForPath[firstActiveIndex] = binding;
                    }
                }
                else if (objects[index] !== knownObject) {
                    console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' +
                        'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
                } // else the object is already where we want it to be
            } // for arguments
            this.nCachedObjects_ = nCachedObjects;
        }
        remove() {
            var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index !== undefined && index >= nCachedObjects) {
                    // move existing object into the CACHED region
                    var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                    indicesByUUID[firstActiveObject.uuid] = index;
                    objects[index] = firstActiveObject;
                    indicesByUUID[uuid] = lastCachedIndex;
                    objects[lastCachedIndex] = object;
                    // accounting is done, now do the same for all bindings
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                        bindingsForPath[index] = firstActive;
                        bindingsForPath[lastCachedIndex] = binding;
                    }
                }
            } // for arguments
            this.nCachedObjects_ = nCachedObjects;
        }
        // remove & forget
        uncache() {
            var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index !== undefined) {
                    delete indicesByUUID[uuid];
                    if (index < nCachedObjects) {
                        // object is cached, shrink the CACHED region
                        var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                        // last cached object takes this object's place
                        indicesByUUID[lastCachedObject.uuid] = index;
                        objects[index] = lastCachedObject;
                        // last object goes to the activated slot and pop
                        indicesByUUID[lastObject.uuid] = firstActiveIndex;
                        objects[firstActiveIndex] = lastObject;
                        objects.pop();
                        // accounting is done, now do the same for all bindings
                        for (var j = 0, m = nBindings; j !== m; ++j) {
                            var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                            bindingsForPath[index] = lastCached;
                            bindingsForPath[firstActiveIndex] = last;
                            bindingsForPath.pop();
                        }
                    }
                    else {
                        // object is active, just swap with the last and pop
                        var lastIndex = --nObjects, lastObject = objects[lastIndex];
                        indicesByUUID[lastObject.uuid] = index;
                        objects[index] = lastObject;
                        objects.pop();
                        // accounting is done, now do the same for all bindings
                        for (var j = 0, m = nBindings; j !== m; ++j) {
                            var bindingsForPath = bindings[j];
                            bindingsForPath[index] = bindingsForPath[lastIndex];
                            bindingsForPath.pop();
                        }
                    } // cached or active
                } // if object is known
            } // for arguments
            this.nCachedObjects_ = nCachedObjects;
        }
        // Internal interface used by befriended PropertyBinding.Composite:
        subscribe_(path, parsedPath) {
            // returns an array of bindings for the given path that is changed
            // according to the contained objects in the group
            var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
            if (index !== undefined)
                return bindings[index];
            var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
            index = bindings.length;
            indicesByPath[path] = index;
            paths.push(path);
            parsedPaths.push(parsedPath);
            bindings.push(bindingsForPath);
            for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
                var object = objects[i];
                bindingsForPath[i] = new THREE.PropertyBinding(object, path, parsedPath);
            }
            return bindingsForPath;
        }
        unsubscribe_(path) {
            // tells the group to forget about a property path and no longer
            // update the array previously obtained with 'subscribe_'
            var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
            if (index !== undefined) {
                var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
                indicesByPath[lastBindingsPath] = index;
                bindings[index] = lastBindings;
                bindings.pop();
                parsedPaths[index] = parsedPaths[lastBindingsIndex];
                parsedPaths.pop();
                paths[index] = paths[lastBindingsIndex];
                paths.pop();
            }
        }
    }
    THREE.AnimationObjectGroup = AnimationObjectGroup;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class AnimationUtils {
        // same as Array.prototype.slice, but also works on typed arrays
        static arraySlice(array, from, to) {
            if (AnimationUtils.isTypedArray(array)) {
                // in ios9 array.subarray(from, undefined) will return empty array
                // but array.subarray(from) or array.subarray(from, len) is correct
                return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
            }
            return array.slice(from, to);
        }
        // converts an array to a specific type
        static convertArray(array, type, forceClone) {
            if (!array || // let 'undefined' and 'null' pass
                !forceClone && array.constructor === type)
                return array;
            if (typeof type.BYTES_PER_ELEMENT === 'number') {
                return new type(array); // create typed array
            }
            return Array.prototype.slice.call(array); // create Array
        }
        static isTypedArray(object) {
            return ArrayBuffer.isView(object) &&
                !(object instanceof DataView);
        }
        // returns an array by which times and values can be sorted
        static getKeyframeOrder(times) {
            function compareTime(i, j) {
                return times[i] - times[j];
            }
            var n = times.length;
            var result = new Array(n);
            for (var i = 0; i !== n; ++i)
                result[i] = i;
            result.sort(compareTime);
            return result;
        }
        // uses the array previously returned by 'getKeyframeOrder' to sort data
        static sortedArray(values, stride, order) {
            var nValues = values.length;
            var result = new values.constructor(nValues);
            for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
                var srcOffset = order[i] * stride;
                for (var j = 0; j !== stride; ++j) {
                    result[dstOffset++] = values[srcOffset + j];
                }
            }
            return result;
        }
        // function for parsing AOS keyframe formats
        static flattenJSON(jsonKeys, times, values, valuePropertyName) {
            var i = 1, key = jsonKeys[0];
            while (key !== undefined && key[valuePropertyName] === undefined) {
                key = jsonKeys[i++];
            }
            if (key === undefined)
                return; // no data
            var value = key[valuePropertyName];
            if (value === undefined)
                return; // no data
            if (Array.isArray(value)) {
                do {
                    value = key[valuePropertyName];
                    if (value !== undefined) {
                        times.push(key.time);
                        values.push.apply(values, value); // push all elements
                    }
                    key = jsonKeys[i++];
                } while (key !== undefined);
            }
            else if (value.toArray !== undefined) {
                // ...assume THREE.Math-ish
                do {
                    value = key[valuePropertyName];
                    if (value !== undefined) {
                        times.push(key.time);
                        value.toArray(values, values.length);
                    }
                    key = jsonKeys[i++];
                } while (key !== undefined);
            }
            else {
                // otherwise push as-is
                do {
                    value = key[valuePropertyName];
                    if (value !== undefined) {
                        times.push(key.time);
                        values.push(value);
                    }
                    key = jsonKeys[i++];
                } while (key !== undefined);
            }
        }
    }
    THREE.AnimationUtils = AnimationUtils;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
    class Composite {
        constructor(targetGroup, path, optionalParsedPath) {
            var parsedPath = optionalParsedPath || THREE.PropertyBinding.parseTrackName(path);
            this._targetGroup = targetGroup;
            this._bindings = targetGroup.subscribe_(path, parsedPath);
        }
        getValue(array, offset) {
            this.bind(); // bind all binding
            var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
            // and only call .getValue on the first
            if (binding !== undefined)
                binding.getValue(array, offset);
        }
        setValue(array, offset) {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].setValue(array, offset);
            }
        }
        bind() {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].bind();
            }
        }
        unbind() {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].unbind();
            }
        }
    }
    THREE.Composite = Composite;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class KeyframeTrack {
        constructor(name, times, values, interpolation) {
            if (name === undefined)
                throw new Error('THREE.KeyframeTrack: track name is undefined');
            if (times === undefined || times.length === 0)
                throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
            this.name = name;
            this.times = THREE.AnimationUtils.convertArray(times, this.TimeBufferType);
            this.values = THREE.AnimationUtils.convertArray(values, this.ValueBufferType);
            this.setInterpolation(interpolation || this.DefaultInterpolation);
            this.validate();
            this.optimize();
            this.TimeBufferType = Float32Array;
            this.ValueBufferType = Float32Array;
            this.DefaultInterpolation = THREE.InterpolateLinear;
        }
        static parse(json) {
            if (json.type === undefined) {
                throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
            }
            var trackType = KeyframeTrack._getTrackTypeForValueTypeName(json.type);
            if (json.times === undefined) {
                var times = [], values = [];
                THREE.AnimationUtils.flattenJSON(json.keys, times, values, 'value');
                json.times = times;
                json.values = values;
            }
            // derived classes can define a static parse method
            if (trackType.parse !== undefined) {
                return trackType.parse(json);
            }
            else {
                // by default, we assume a constructor compatible with the base
                return new trackType(json.name, json.times, json.values, json.interpolation);
            }
        }
        static toJSON(track) {
            var trackType = track.constructor;
            var json;
            // derived classes can define a static toJSON method
            if (trackType.toJSON !== undefined) {
                json = trackType.toJSON(track);
            }
            else {
                // by default, we assume the data can be serialized as-is
                json = {
                    'name': track.name,
                    'times': THREE.AnimationUtils.convertArray(track.times, Array),
                    'values': THREE.AnimationUtils.convertArray(track.values, Array)
                };
                var interpolation = track.getInterpolation();
                if (interpolation !== track.DefaultInterpolation) {
                    json.interpolation = interpolation;
                }
            }
            json.type = track.ValueTypeName; // mandatory
            return json;
        }
        static _getTrackTypeForValueTypeName(typeName) {
            switch (typeName.toLowerCase()) {
                case 'scalar':
                case 'double':
                case 'float':
                case 'number':
                case 'integer':
                    return THREE.NumberKeyframeTrack;
                case 'vector':
                case 'vector2':
                case 'vector3':
                case 'vector4':
                    return THREE.VectorKeyframeTrack;
                case 'color':
                    return THREE.ColorKeyframeTrack;
                case 'quaternion':
                    return THREE.QuaternionKeyframeTrack;
                case 'bool':
                case 'boolean':
                    return THREE.BooleanKeyframeTrack;
                case 'string':
                    return THREE.StringKeyframeTrack;
            }
            throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
        }
        InterpolantFactoryMethodDiscrete(result) {
            return new THREE.DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodLinear(result) {
            return new THREE.LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        InterpolantFactoryMethodSmooth(result) {
            return new THREE.CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        }
        setInterpolation(interpolation) {
            var factoryMethod;
            switch (interpolation) {
                case THREE.InterpolateDiscrete:
                    factoryMethod = this.InterpolantFactoryMethodDiscrete;
                    break;
                case THREE.InterpolateLinear:
                    factoryMethod = this.InterpolantFactoryMethodLinear;
                    break;
                case THREE.InterpolateSmooth:
                    factoryMethod = this.InterpolantFactoryMethodSmooth;
                    break;
            }
            if (factoryMethod === undefined) {
                var message = "unsupported interpolation for " +
                    this.ValueTypeName + " keyframe track named " + this.name;
                if (this.createInterpolant === undefined) {
                    // fall back to default, unless the default itself is messed up
                    if (interpolation !== this.DefaultInterpolation) {
                        this.setInterpolation(this.DefaultInterpolation);
                    }
                    else {
                        throw new Error(message); // fatal, in this case
                    }
                }
                console.warn('THREE.KeyframeTrack:', message);
                return;
            }
            this.createInterpolant = factoryMethod;
        }
        getInterpolation() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return THREE.InterpolateDiscrete;
                case this.InterpolantFactoryMethodLinear:
                    return THREE.InterpolateLinear;
                case this.InterpolantFactoryMethodSmooth:
                    return THREE.InterpolateSmooth;
            }
        }
        getValueSize() {
            return this.values.length / this.times.length;
        }
        // move all keyframes either forwards or backwards in time
        shift(timeOffset) {
            if (timeOffset !== 0.0) {
                var times = this.times;
                for (var i = 0, n = times.length; i !== n; ++i) {
                    times[i] += timeOffset;
                }
            }
            return this;
        }
        // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
        scale(timeScale) {
            if (timeScale !== 1.0) {
                var times = this.times;
                for (var i = 0, n = times.length; i !== n; ++i) {
                    times[i] *= timeScale;
                }
            }
            return this;
        }
        // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
        // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
        trim(startTime, endTime) {
            var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1;
            while (from !== nKeys && times[from] < startTime) {
                ++from;
            }
            while (to !== -1 && times[to] > endTime) {
                --to;
            }
            ++to; // inclusive -> exclusive bound
            if (from !== 0 || to !== nKeys) {
                // empty tracks are forbidden, so keep at least one keyframe
                if (from >= to)
                    to = Math.max(to, 1), from = to - 1;
                var stride = this.getValueSize();
                this.times = THREE.AnimationUtils.arraySlice(times, from, to);
                this.values = THREE.AnimationUtils.arraySlice(this.values, from * stride, to * stride);
            }
            return this;
        }
        // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
        validate() {
            var valid = true;
            var valueSize = this.getValueSize();
            if (valueSize - Math.floor(valueSize) !== 0) {
                console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
                valid = false;
            }
            var times = this.times, values = this.values, nKeys = times.length;
            if (nKeys === 0) {
                console.error('THREE.KeyframeTrack: Track is empty.', this);
                valid = false;
            }
            var prevTime = null;
            for (var i = 0; i !== nKeys; i++) {
                var currTime = times[i];
                if (typeof currTime === 'number' && isNaN(currTime)) {
                    console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
                    valid = false;
                    break;
                }
                if (prevTime !== null && prevTime > currTime) {
                    console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
                    valid = false;
                    break;
                }
                prevTime = currTime;
            }
            if (values !== undefined) {
                if (THREE.AnimationUtils.isTypedArray(values)) {
                    for (var i = 0, n = values.length; i !== n; ++i) {
                        var value = values[i];
                        if (isNaN(value)) {
                            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
                            valid = false;
                            break;
                        }
                    }
                }
            }
            return valid;
        }
        // removes equivalent sequential keys as common in morph target sequences
        // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
        optimize() {
            var times = this.times, values = this.values, stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === THREE.InterpolateSmooth, writeIndex = 1, lastIndex = times.length - 1;
            for (var i = 1; i < lastIndex; ++i) {
                var keep = false;
                var time = times[i];
                var timeNext = times[i + 1];
                // remove adjacent keyframes scheduled at the same time
                if (time !== timeNext && (i !== 1 || time !== time[0])) {
                    if (!smoothInterpolation) {
                        // remove unnecessary keyframes same as their neighbors
                        var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
                        for (var j = 0; j !== stride; ++j) {
                            var value = values[offset + j];
                            if (value !== values[offsetP + j] ||
                                value !== values[offsetN + j]) {
                                keep = true;
                                break;
                            }
                        }
                    }
                    else {
                        keep = true;
                    }
                }
                // in-place compaction
                if (keep) {
                    if (i !== writeIndex) {
                        times[writeIndex] = times[i];
                        var readOffset = i * stride, writeOffset = writeIndex * stride;
                        for (var j = 0; j !== stride; ++j) {
                            values[writeOffset + j] = values[readOffset + j];
                        }
                    }
                    ++writeIndex;
                }
            }
            // flush last keyframe (compaction looks ahead)
            if (lastIndex > 0) {
                times[writeIndex] = times[lastIndex];
                for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
                    values[writeOffset + j] = values[readOffset + j];
                }
                ++writeIndex;
            }
            if (writeIndex !== times.length) {
                this.times = THREE.AnimationUtils.arraySlice(times, 0, writeIndex);
                this.values = THREE.AnimationUtils.arraySlice(values, 0, writeIndex * stride);
            }
            return this;
        }
    }
    THREE.KeyframeTrack = KeyframeTrack;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
    class PropertyBinding {
        constructor(rootNode, path, parsedPath) {
            this.path = path;
            this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
            this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
            this.rootNode = rootNode;
            this._getValue_unbound = this.getValue;
            this._setValue_unbound = this.setValue;
        }
        static create(root, path, parsedPath) {
            if (!(root && root.isAnimationObjectGroup)) {
                return new PropertyBinding(root, path, parsedPath);
            }
            else {
                return new PropertyBinding.Composite(root, path, parsedPath);
            }
        }
        /**
         * Replaces spaces with underscores and removes unsupported characters from
         * node names, to ensure compatibility with parseTrackName().
         *
         * @param  {string} name Node name to be sanitized.
         * @return {string}
         */
        static sanitizeNodeName(name) {
            var reservedRe = new RegExp('[' + RESERVED_CHARS_RE + ']', 'g');
            return name.replace(/\s/g, '_').replace(reservedRe, '');
        }
        ;
        static parseTrackName(trackName) {
            // Attempts to allow node names from any language. ES5's `\w` regexp matches
            // only latin characters, and the unicode \p{L} is not yet supported. So
            // instead, we exclude reserved characters and match everything else.
            var wordChar = '[^' + RESERVED_CHARS_RE + ']';
            var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace('\\.', '') + ']';
            // Parent directories, delimited by '/' or ':'. Currently unused, but must
            // be matched to parse the rest of the track name.
            var directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', wordChar);
            // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
            var nodeRe = /(WCOD+)?/.source.replace('WCOD', wordCharOrDot);
            // Object on target node, and accessor. May not contain reserved
            // characters. Accessor may contain any character except closing bracket.
            var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', wordChar);
            // Property and accessor. May not contain reserved characters. Accessor may
            // contain any non-bracket characters.
            var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', wordChar);
            var trackRe = new RegExp(''
                + '^'
                + directoryRe
                + nodeRe
                + objectRe
                + propertyRe
                + '$');
            var supportedObjectNames = ['material', 'materials', 'bones'];
            var matches = trackRe.exec(trackName);
            if (!matches) {
                throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
            }
            var results = {
                // directoryName: matches[ 1 ], // (tschw) currently unused
                nodeName: matches[2],
                objectName: matches[3],
                objectIndex: matches[4],
                propertyName: matches[5],
                propertyIndex: matches[6]
            };
            var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
            if (lastDot !== undefined && lastDot !== -1) {
                var objectName = results.nodeName.substring(lastDot + 1);
                // Object names must be checked against a whitelist. Otherwise, there
                // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
                // 'bar' could be the objectName, or part of a nodeName (which can
                // include '.' characters).
                if (supportedObjectNames.indexOf(objectName) !== -1) {
                    results.nodeName = results.nodeName.substring(0, lastDot);
                    results.objectName = objectName;
                }
            }
            if (results.propertyName === null || results.propertyName.length === 0) {
                throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
            }
            return results;
        }
        ;
        static findNode(root, nodeName) {
            if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
                return root;
            }
            // search into skeleton bones.
            if (root.skeleton) {
                var bone = root.skeleton.getBoneByName(nodeName);
                if (bone !== undefined) {
                    return bone;
                }
            }
            // search into node subtree.
            if (root.children) {
                var searchNodeSubtree = function (children) {
                    for (var i = 0; i < children.length; i++) {
                        var childNode = children[i];
                        if (childNode.name === nodeName || childNode.uuid === nodeName) {
                            return childNode;
                        }
                        var result = searchNodeSubtree(childNode.children);
                        if (result)
                            return result;
                    }
                    return null;
                };
                var subTreeNode = searchNodeSubtree(root.children);
                if (subTreeNode) {
                    return subTreeNode;
                }
            }
            return null;
        }
        _getValue_unavailable() {
        }
        _setValue_unavailable() {
        }
        get BindingType() {
            return {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            };
        }
        get Versioning() {
            return {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            };
        }
        get GetterByBindingType() {
            return [
                function getValue_direct(buffer, offset) {
                    buffer[offset] = this.node[this.propertyName];
                },
                function getValue_array(buffer, offset) {
                    var source = this.resolvedProperty;
                    for (var i = 0, n = source.length; i !== n; ++i) {
                        buffer[offset++] = source[i];
                    }
                },
                function getValue_arrayElement(buffer, offset) {
                    buffer[offset] = this.resolvedProperty[this.propertyIndex];
                },
                function getValue_toArray(buffer, offset) {
                    this.resolvedProperty.toArray(buffer, offset);
                }
            ];
        }
        get SetterByBindingTypeAndVersioning() {
            return [
                [
                    // Direct
                    function setValue_direct(buffer, offset) {
                        this.targetObject[this.propertyName] = buffer[offset];
                    },
                    function setValue_direct_setNeedsUpdate(buffer, offset) {
                        this.targetObject[this.propertyName] = buffer[offset];
                        this.targetObject.needsUpdate = true;
                    },
                    function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
                        this.targetObject[this.propertyName] = buffer[offset];
                        this.targetObject.matrixWorldNeedsUpdate = true;
                    }
                ], [
                    // EntireArray
                    function setValue_array(buffer, offset) {
                        var dest = this.resolvedProperty;
                        for (var i = 0, n = dest.length; i !== n; ++i) {
                            dest[i] = buffer[offset++];
                        }
                    },
                    function setValue_array_setNeedsUpdate(buffer, offset) {
                        var dest = this.resolvedProperty;
                        for (var i = 0, n = dest.length; i !== n; ++i) {
                            dest[i] = buffer[offset++];
                        }
                        this.targetObject.needsUpdate = true;
                    },
                    function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
                        var dest = this.resolvedProperty;
                        for (var i = 0, n = dest.length; i !== n; ++i) {
                            dest[i] = buffer[offset++];
                        }
                        this.targetObject.matrixWorldNeedsUpdate = true;
                    }
                ], [
                    // ArrayElement
                    function setValue_arrayElement(buffer, offset) {
                        this.resolvedProperty[this.propertyIndex] = buffer[offset];
                    },
                    function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
                        this.resolvedProperty[this.propertyIndex] = buffer[offset];
                        this.targetObject.needsUpdate = true;
                    },
                    function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
                        this.resolvedProperty[this.propertyIndex] = buffer[offset];
                        this.targetObject.matrixWorldNeedsUpdate = true;
                    }
                ], [
                    // HasToFromArray
                    function setValue_fromArray(buffer, offset) {
                        this.resolvedProperty.fromArray(buffer, offset);
                    },
                    function setValue_fromArray_setNeedsUpdate(buffer, offset) {
                        this.resolvedProperty.fromArray(buffer, offset);
                        this.targetObject.needsUpdate = true;
                    },
                    function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
                        this.resolvedProperty.fromArray(buffer, offset);
                        this.targetObject.matrixWorldNeedsUpdate = true;
                    }
                ]
            ];
        }
        getValuegetValue_unbound(targetArray, offset) {
            this.bind();
            this.getValue(targetArray, offset);
            // Note: This class uses a State pattern on a per-method basis:
            // 'bind' sets 'this.getValue' / 'setValue' and shadows the
            // prototype version of these methods with one that represents
            // the bound state. When the property is not found, the methods
            // become no-ops.
        }
        setValuegetValue_unbound(sourceArray, offset) {
            this.bind();
            this.setValue(sourceArray, offset);
        }
        // create getter / setter pair for a property in the scene graph
        bind() {
            var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
            if (!targetObject) {
                targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
                this.node = targetObject;
            }
            // set fail state so we can just 'return' on error
            this.getValue = this._getValue_unavailable;
            this.setValue = this._setValue_unavailable;
            // ensure there is a value node
            if (!targetObject) {
                console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
                return;
            }
            if (objectName) {
                var objectIndex = parsedPath.objectIndex;
                // special cases were we need to reach deeper into the hierarchy to get the face materials....
                switch (objectName) {
                    case 'materials':
                        if (!targetObject.material) {
                            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                            return;
                        }
                        if (!targetObject.material.materials) {
                            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                            return;
                        }
                        targetObject = targetObject.material.materials;
                        break;
                    case 'bones':
                        if (!targetObject.skeleton) {
                            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                            return;
                        }
                        // potential future optimization: skip this if propertyIndex is already an integer
                        // and convert the integer string to a true integer.
                        targetObject = targetObject.skeleton.bones;
                        // support resolving morphTarget names into indices.
                        for (var i = 0; i < targetObject.length; i++) {
                            if (targetObject[i].name === objectIndex) {
                                objectIndex = i;
                                break;
                            }
                        }
                        break;
                    default:
                        if (targetObject[objectName] === undefined) {
                            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                            return;
                        }
                        targetObject = targetObject[objectName];
                }
                if (objectIndex !== undefined) {
                    if (targetObject[objectIndex] === undefined) {
                        console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                        return;
                    }
                    targetObject = targetObject[objectIndex];
                }
            }
            // resolve property
            var nodeProperty = targetObject[propertyName];
            if (nodeProperty === undefined) {
                var nodeName = parsedPath.nodeName;
                console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
                    '.' + propertyName + ' but it wasn\'t found.', targetObject);
                return;
            }
            // determine versioning scheme
            var versioning = this.Versioning.None;
            if (targetObject.needsUpdate !== undefined) { // material
                versioning = this.Versioning.NeedsUpdate;
                this.targetObject = targetObject;
            }
            else if (targetObject.matrixWorldNeedsUpdate !== undefined) { // node transform
                versioning = this.Versioning.MatrixWorldNeedsUpdate;
                this.targetObject = targetObject;
            }
            // determine how the property gets bound
            var bindingType = this.BindingType.Direct;
            if (propertyIndex !== undefined) {
                // access a sub element of the property array (only primitives are supported right now)
                if (propertyName === "morphTargetInfluences") {
                    // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
                    // support resolving morphTarget names into indices.
                    if (!targetObject.geometry) {
                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                        return;
                    }
                    if (targetObject.geometry.isBufferGeometry) {
                        if (!targetObject.geometry.morphAttributes) {
                            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                            return;
                        }
                        for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) {
                            if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
                                propertyIndex = i;
                                break;
                            }
                        }
                    }
                    else {
                        if (!targetObject.geometry.morphTargets) {
                            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this);
                            return;
                        }
                        for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
                            if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                                propertyIndex = i;
                                break;
                            }
                        }
                    }
                }
                bindingType = this.BindingType.ArrayElement;
                this.resolvedProperty = nodeProperty;
                this.propertyIndex = propertyIndex;
            }
            else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
                // must use copy for Object3D.Euler/Quaternion
                bindingType = this.BindingType.HasFromToArray;
                this.resolvedProperty = nodeProperty;
            }
            else if (Array.isArray(nodeProperty)) {
                bindingType = this.BindingType.EntireArray;
                this.resolvedProperty = nodeProperty;
            }
            else {
                this.propertyName = propertyName;
            }
            // select getter / setter
            this.getValue = this.GetterByBindingType[bindingType];
            this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        }
        unbind() {
            this.node = null;
            // back to the prototype version of getValue / setValue
            // note: avoiding to mutate the shape of 'this' via 'delete'
            this.getValue = this._getValue_unbound;
            this.setValue = this._setValue_unbound;
        }
    }
    PropertyBinding.Composite = THREE.Composite;
    THREE.PropertyBinding = PropertyBinding;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class PropertyMixer {
        constructor(binding, typeName, valueSize) {
            this.binding = binding;
            this.valueSize = valueSize;
            var bufferType = Float64Array, mixFunction;
            switch (typeName) {
                case 'quaternion':
                    mixFunction = this._slerp;
                    break;
                case 'string':
                case 'bool':
                    bufferType = Array;
                    mixFunction = this._select;
                    break;
                default:
                    mixFunction = this._lerp;
            }
            this.buffer = new bufferType(valueSize * 4);
            // layout: [ incoming | accu0 | accu1 | orig ]
            //
            // interpolators can use .buffer as their .result
            // the data then goes to 'incoming'
            //
            // 'accu0' and 'accu1' are used frame-interleaved for
            // the cumulative result and are compared to detect
            // changes
            //
            // 'orig' stores the original state of the property
            this._mixBufferRegion = mixFunction;
            this.cumulativeWeight = 0;
            this.useCount = 0;
            this.referenceCount = 0;
        }
        accumulate(accuIndex, weight) {
            // note: happily accumulating nothing when weight = 0, the caller knows
            // the weight and shouldn't have made the call in the first place
            var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
            if (currentWeight === 0) {
                // accuN := incoming * weight
                for (var i = 0; i !== stride; ++i) {
                    buffer[offset + i] = buffer[i];
                }
                currentWeight = weight;
            }
            else {
                // accuN := accuN + incoming * weight
                currentWeight += weight;
                var mix = weight / currentWeight;
                this._mixBufferRegion(buffer, offset, 0, mix, stride);
            }
            this.cumulativeWeight = currentWeight;
        }
        // apply the state of 'accu<i>' to the binding when accus differ
        apply(accuIndex) {
            var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
            this.cumulativeWeight = 0;
            if (weight < 1) {
                // accuN := accuN + original * ( 1 - cumulativeWeight )
                var originalValueOffset = stride * 3;
                this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
            }
            for (var i = stride, e = stride + stride; i !== e; ++i) {
                if (buffer[i] !== buffer[i + stride]) {
                    // value has changed -> update scene graph
                    binding.setValue(buffer, offset);
                    break;
                }
            }
        }
        // remember the state of the bound property and copy it to both accus
        saveOriginalState() {
            var binding = this.binding;
            var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3;
            binding.getValue(buffer, originalValueOffset);
            // accu[0..1] := orig -- initially detect changes against the original
            for (var i = stride, e = originalValueOffset; i !== e; ++i) {
                buffer[i] = buffer[originalValueOffset + (i % stride)];
            }
            this.cumulativeWeight = 0;
        }
        // apply the state previously taken via 'saveOriginalState' to the binding
        restoreOriginalState() {
            var originalValueOffset = this.valueSize * 3;
            this.binding.setValue(this.buffer, originalValueOffset);
        }
        // mix functions
        _select(buffer, dstOffset, srcOffset, t, stride) {
            if (t >= 0.5) {
                for (var i = 0; i !== stride; ++i) {
                    buffer[dstOffset + i] = buffer[srcOffset + i];
                }
            }
        }
        _slerp(buffer, dstOffset, srcOffset, t) {
            THREE.Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
        }
        _lerp(buffer, dstOffset, srcOffset, t, stride) {
            var s = 1 - t;
            for (var i = 0; i !== stride; ++i) {
                var j = dstOffset + i;
                buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
            }
        }
    }
    THREE.PropertyMixer = PropertyMixer;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class BooleanKeyframeTrack extends THREE.KeyframeTrack {
        constructor(name, times, values) {
            super(name, times, values, null);
            this.ValueTypeName = 'bool';
            this.ValueBufferType = Array;
            this.DefaultInterpolation = THREE.InterpolateDiscrete;
            this.InterpolantFactoryMethodLinear = undefined;
            this.InterpolantFactoryMethodSmooth = undefined;
        }
    }
    THREE.BooleanKeyframeTrack = BooleanKeyframeTrack;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class ColorKeyframeTrack extends THREE.KeyframeTrack {
        constructor(name, times, values, interpolation) {
            super(name, times, values, interpolation);
            this.ValueTypeName = "color";
        }
    }
    THREE.ColorKeyframeTrack = ColorKeyframeTrack;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class NumberKeyframeTrack extends THREE.KeyframeTrack {
        constructor(name, times, values, interpolation) {
            super(name, times, values, interpolation);
            this.ValueTypeName = 'number';
        }
    }
    THREE.NumberKeyframeTrack = NumberKeyframeTrack;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class QuaternionKeyframeTrack extends THREE.KeyframeTrack {
        constructor(name, times, values, interpolation) {
            super(name, times, values, interpolation);
            this.ValueTypeName = 'quaternion';
            this.DefaultInterpolation = THREE.InterpolateLinear;
            this.InterpolantFactoryMethodSmooth = undefined;
        }
        InterpolantFactoryMethodLinear(result) {
            return new THREE.QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        }
    }
    THREE.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class StringKeyframeTrack extends THREE.KeyframeTrack {
        constructor(name, times, values, interpolation) {
            super(name, times, values, interpolation);
            this.ValueTypeName = 'string';
            this.ValueBufferType = Array;
            this.DefaultInterpolation = THREE.InterpolateDiscrete;
            this.InterpolantFactoryMethodLinear = undefined;
            this.InterpolantFactoryMethodSmooth = undefined;
        }
    }
    THREE.StringKeyframeTrack = StringKeyframeTrack;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class VectorKeyframeTrack extends THREE.KeyframeTrack {
        constructor(name, times, values, interpolation) {
            super(name, times, values, interpolation);
            this.ValueTypeName = 'vector';
        }
    }
    THREE.VectorKeyframeTrack = VectorKeyframeTrack;
})(THREE || (THREE = {}));
///<reference path="./Vector3.ts" />
var THREE;
///<reference path="./Vector3.ts" />
(function (THREE) {
    class Quaternion {
        constructor(x, y, z, w) {
            this._x = x || 0;
            this._y = y || 0;
            this._z = z || 0;
            this._w = (w !== undefined) ? w : 1;
        }
        set x(value) {
            this._x = value;
            this.onChangeCallback();
        }
        get x() {
            return this._x;
        }
        set y(value) {
            this._y = value;
            this.onChangeCallback();
        }
        get y() {
            return this._y;
        }
        set z(value) {
            this._z = value;
            this.onChangeCallback();
        }
        get z() {
            return this._z;
        }
        set w(value) {
            this._w = value;
            this.onChangeCallback();
        }
        get w() {
            return this._w;
        }
        static slerp(qa, qb, qm, t) {
            return qm.copy(qa).slerp(qb, t);
        }
        static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
            // fuzz-free, array-based Quaternion SLERP operation
            var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
            if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = (cos >= 0 ? 1 : -1), sqrSin = 1 - cos * cos;
                // Skip the Slerp for tiny steps to avoid numeric problems:
                if (sqrSin > Number.EPSILON) {
                    var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                    s = Math.sin(s * len) / sin;
                    t = Math.sin(t * len) / sin;
                }
                var tDir = t * dir;
                x0 = x0 * s + x1 * tDir;
                y0 = y0 * s + y1 * tDir;
                z0 = z0 * s + z1 * tDir;
                w0 = w0 * s + w1 * tDir;
                // Normalize in case we just did a lerp:
                if (s === 1 - t) {
                    var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                    x0 *= f;
                    y0 *= f;
                    z0 *= f;
                    w0 *= f;
                }
            }
            dst[dstOffset] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
        }
        set(x, y, z, w) {
            this._x = x;
            this._y = y;
            this._z = z;
            this._w = w;
            this.onChangeCallback();
            return this;
        }
        clone() {
            return new Quaternion(this._x, this._y, this._z, this._w);
        }
        copy(quaternion) {
            this._x = quaternion.x;
            this._y = quaternion.y;
            this._z = quaternion.z;
            this._w = quaternion.w;
            this.onChangeCallback();
            return this;
        }
        setFromEuler(euler, update) {
            if (!(euler && euler.isEuler)) {
                throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
            }
            var x = euler._x, y = euler._y, z = euler._z, order = euler.order;
            // http://www.mathworks.com/matlabcentral/fileexchange/
            // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
            //	content/SpinCalc.m
            var cos = Math.cos;
            var sin = Math.sin;
            var c1 = cos(x / 2);
            var c2 = cos(y / 2);
            var c3 = cos(z / 2);
            var s1 = sin(x / 2);
            var s2 = sin(y / 2);
            var s3 = sin(z / 2);
            if (order === 'XYZ') {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            }
            else if (order === 'YXZ') {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            else if (order === 'ZXY') {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            }
            else if (order === 'ZYX') {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            else if (order === 'YZX') {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            }
            else if (order === 'XZY') {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            if (update !== false)
                this.onChangeCallback();
            return this;
        }
        setFromAxisAngle(axis, angle) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
            // assumes axis is normalized
            var halfAngle = angle / 2, s = Math.sin(halfAngle);
            this._x = axis.x * s;
            this._y = axis.y * s;
            this._z = axis.z * s;
            this._w = Math.cos(halfAngle);
            this.onChangeCallback();
            return this;
        }
        setFromRotationMatrix(m) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                this._w = 0.25 / s;
                this._x = (m32 - m23) * s;
                this._y = (m13 - m31) * s;
                this._z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                this._w = (m32 - m23) / s;
                this._x = 0.25 * s;
                this._y = (m12 + m21) / s;
                this._z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                this._w = (m13 - m31) / s;
                this._x = (m12 + m21) / s;
                this._y = 0.25 * s;
                this._z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                this._w = (m21 - m12) / s;
                this._x = (m13 + m31) / s;
                this._y = (m23 + m32) / s;
                this._z = 0.25 * s;
            }
            this.onChangeCallback();
            return this;
        }
        //public static v1 = new Vector3();
        // public setFromUnitVectors() {
        // assumes direction vectors vFrom and vTo are normalized
        setFromUnitVectors(vFrom, vTo) {
            var v1 = new THREE.Vector3();
            var r;
            var EPS = 0.000001;
            if (v1 === undefined)
                v1 = new THREE.Vector3();
            r = vFrom.dot(vTo) + 1;
            if (r < EPS) {
                r = 0;
                if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                    v1.set(-vFrom.y, vFrom.x, 0);
                }
                else {
                    v1.set(0, -vFrom.z, vFrom.y);
                }
            }
            else {
                v1.crossVectors(vFrom, vTo);
            }
            this._x = v1.x;
            this._y = v1.y;
            this._z = v1.z;
            this._w = r;
            return this.normalize();
        }
        inverse() {
            // quaternion is assumed to have unit length
            return this.conjugate();
        }
        conjugate() {
            this._x *= -1;
            this._y *= -1;
            this._z *= -1;
            this.onChangeCallback();
            return this;
        }
        dot(v) {
            return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
            var l = this.length();
            if (l === 0) {
                this._x = 0;
                this._y = 0;
                this._z = 0;
                this._w = 1;
            }
            else {
                l = 1 / l;
                this._x = this._x * l;
                this._y = this._y * l;
                this._z = this._z * l;
                this._w = this._w * l;
            }
            this.onChangeCallback();
            return this;
        }
        multiply(q, p) {
            if (p !== undefined) {
                console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
                return this.multiplyQuaternions(q, p);
            }
            return this.multiplyQuaternions(this, q);
        }
        premultiply(q) {
            return this.multiplyQuaternions(q, this);
        }
        multiplyQuaternions(a, b) {
            // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
            var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
            var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
            this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
            this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
            this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
            this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
            this.onChangeCallback();
            return this;
        }
        slerp(qb, t) {
            if (t === 0)
                return this;
            if (t === 1)
                return this.copy(qb);
            var x = this._x, y = this._y, z = this._z, w = this._w;
            // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
            if (cosHalfTheta < 0) {
                this._w = -qb._w;
                this._x = -qb._x;
                this._y = -qb._y;
                this._z = -qb._z;
                cosHalfTheta = -cosHalfTheta;
            }
            else {
                this.copy(qb);
            }
            if (cosHalfTheta >= 1.0) {
                this._w = w;
                this._x = x;
                this._y = y;
                this._z = z;
                return this;
            }
            var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
            if (Math.abs(sinHalfTheta) < 0.001) {
                this._w = 0.5 * (w + this._w);
                this._x = 0.5 * (x + this._x);
                this._y = 0.5 * (y + this._y);
                this._z = 0.5 * (z + this._z);
                return this;
            }
            var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
            var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            this._w = (w * ratioA + this._w * ratioB);
            this._x = (x * ratioA + this._x * ratioB);
            this._y = (y * ratioA + this._y * ratioB);
            this._z = (z * ratioA + this._z * ratioB);
            this.onChangeCallback();
            return this;
        }
        equals(quaternion) {
            return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
        }
        fromArray(array, offset) {
            if (offset === undefined)
                offset = 0;
            this._x = array[offset];
            this._y = array[offset + 1];
            this._z = array[offset + 2];
            this._w = array[offset + 3];
            this.onChangeCallback();
            return this;
        }
        toArray(array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._w;
            return array;
        }
        onChange(callback) {
            this._onChangeCallback = callback;
            return this;
        }
        onChangeCallback() {
            if (this._onChangeCallback) {
                this._onChangeCallback();
            }
        }
    }
    THREE.Quaternion = Quaternion;
})(THREE || (THREE = {}));
/// <reference path="./Quaternion.ts" />
var THREE;
/// <reference path="./Quaternion.ts" />
(function (THREE) {
    class Vector3 {
        constructor(x, y, z) {
            this.isVector3 = true;
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
        }
        set(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        setScalar(scalar) {
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            return this;
        }
        setX(x) {
            this.x = x;
            return this;
        }
        setY(y) {
            this.y = y;
            return this;
        }
        setZ(z) {
            this.z = z;
            return this;
        }
        setComponent(index, value) {
            switch (index) {
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                case 2:
                    this.z = value;
                    break;
                default: throw new Error('index is out of range: ' + index);
            }
            return this;
        }
        getComponent(index) {
            switch (index) {
                case 0: return this.x;
                case 1: return this.y;
                case 2: return this.z;
                default: throw new Error('index is out of range: ' + index);
            }
        }
        clone() {
            return new Vector3(this.x, this.y, this.z);
        }
        copy(v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            return this;
        }
        add(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            return this;
        }
        addScalar(s) {
            this.x += s;
            this.y += s;
            this.z += s;
            return this;
        }
        addVectors(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            return this;
        }
        addScaledVector(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            return this;
        }
        sub(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            return this;
        }
        subScalar(s) {
            this.x -= s;
            this.y -= s;
            this.z -= s;
            return this;
        }
        subVectors(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            return this;
        }
        multiply(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
                return this.multiplyVectors(v, w);
            }
            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;
            return this;
        }
        multiplyScalar(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            return this;
        }
        multiplyVectors(a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            return this;
        }
        applyEuler(euler) {
            if (!(euler && euler.isEuler)) {
                console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
            }
            return this.applyQuaternion(Vector3.quaternion.setFromEuler(euler));
        }
        //public static quaternion = new Quaternion();
        // public applyAxisAngle() {
        applyAxisAngle(axis, angle) {
            return this.applyQuaternion(Vector3.quaternion.setFromAxisAngle(axis, angle));
        }
        applyMatrix3(m) {
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[3] * y + e[6] * z;
            this.y = e[1] * x + e[4] * y + e[7] * z;
            this.z = e[2] * x + e[5] * y + e[8] * z;
            return this;
        }
        applyMatrix4(m) {
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
            this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
            this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
            this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
            return this;
        }
        applyQuaternion(q) {
            var x = this.x, y = this.y, z = this.z;
            var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
            // calculate quat * vector
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;
            // calculate result * inverse quat
            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return this;
        }
        //@TODO
        // public project() {
        project(camera) {
            Vector3.matrix.multiplyMatrices(camera.projectionMatrix, Vector3.matrix.getInverse(camera.matrixWorld));
            return this.applyMatrix4(Vector3.matrix);
        }
        //public static matrix = new Matrix4();
        // public unproject() {
        unproject(camera) {
            //@TODO
            Vector3.matrix.multiplyMatrices(camera.matrixWorld, Vector3.matrix.getInverse(camera.projectionMatrix));
            return this.applyMatrix4(Vector3.matrix);
        }
        transformDirection(m) {
            // input: THREE.Matrix4 affine matrix
            // vector interpreted as a direction
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z;
            this.y = e[1] * x + e[5] * y + e[9] * z;
            this.z = e[2] * x + e[6] * y + e[10] * z;
            return this.normalize();
        }
        divide(v) {
            this.x /= v.x;
            this.y /= v.y;
            this.z /= v.z;
            return this;
        }
        divideScalar(scalar) {
            return this.multiplyScalar(1 / scalar);
        }
        min(v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            return this;
        }
        max(v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            return this;
        }
        clamp(min, max) {
            // assumes min < max, componentwise
            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));
            this.z = Math.max(min.z, Math.min(max.z, this.z));
            return this;
        }
        // public clampScalar() {
        clampScalar(minVal, maxVal) {
            Vector3.min.set(minVal, minVal, minVal);
            Vector3.max.set(maxVal, maxVal, maxVal);
            return this.clamp(Vector3.min, Vector3.max);
        }
        clampLength(min, max) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            return this;
        }
        ceil() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            return this;
        }
        round() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            return this;
        }
        roundToZero() {
            this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
            return this;
        }
        negate() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        }
        dot(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
        }
        // TODO lengthSquared?
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
            return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            return this;
        }
        lerpVectors(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        }
        cross(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
                return this.crossVectors(v, w);
            }
            return this.crossVectors(this, v);
        }
        crossVectors(a, b) {
            var ax = a.x, ay = a.y, az = a.z;
            var bx = b.x, by = b.y, bz = b.z;
            this.x = ay * bz - az * by;
            this.y = az * bx - ax * bz;
            this.z = ax * by - ay * bx;
            return this;
        }
        projectOnVector(vector) {
            var scalar = vector.dot(this) / vector.lengthSq();
            return this.copy(vector).multiplyScalar(scalar);
        }
        // public projectOnPlane() {
        projectOnPlane(planeNormal) {
            Vector3.v1.copy(this).projectOnVector(planeNormal);
            return this.sub(Vector3.v1);
        }
        //public static v1 = new Vector3();
        // public reflect() {
        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length
        reflect(normal) {
            return this.sub(Vector3.v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
        }
        angleTo(v) {
            var theta = this.dot(v) / (Math.sqrt(this.lengthSq() * v.lengthSq()));
            // clamp, to handle numerical problems
            return Math.acos(_Math.clamp(theta, -1, 1));
        }
        distanceTo(v) {
            return Math.sqrt(this.distanceToSquared(v));
        }
        distanceToSquared(v) {
            var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
            return dx * dx + dy * dy + dz * dz;
        }
        manhattanDistanceTo(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
        }
        setFromSpherical(s) {
            var sinPhiRadius = Math.sin(s.phi) * s.radius;
            this.x = sinPhiRadius * Math.sin(s.theta);
            this.y = Math.cos(s.phi) * s.radius;
            this.z = sinPhiRadius * Math.cos(s.theta);
            return this;
        }
        setFromCylindrical(c) {
            this.x = c.radius * Math.sin(c.theta);
            this.y = c.y;
            this.z = c.radius * Math.cos(c.theta);
            return this;
        }
        setFromMatrixPosition(m) {
            var e = m.elements;
            this.x = e[12];
            this.y = e[13];
            this.z = e[14];
            return this;
        }
        setFromMatrixScale(m) {
            var sx = this.setFromMatrixColumn(m, 0).length();
            var sy = this.setFromMatrixColumn(m, 1).length();
            var sz = this.setFromMatrixColumn(m, 2).length();
            this.x = sx;
            this.y = sy;
            this.z = sz;
            return this;
        }
        setFromMatrixColumn(m, index) {
            return this.fromArray(m.elements, index * 4);
        }
        equals(v) {
            return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
        }
        fromArray(array, offset) {
            if (offset === undefined)
                offset = 0;
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            return this;
        }
        toArray(array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            return array;
        }
        fromBufferAttribute(attribute, index, offset) {
            if (offset !== undefined) {
                console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
            }
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            this.z = attribute.getZ(index);
            return this;
        }
    }
    //public applyEuler() {
    Vector3.quaternion = new THREE.Quaternion();
    Vector3.min = new Vector3();
    Vector3.max = new Vector3();
    Vector3.v1 = new Vector3();
    THREE.Vector3 = Vector3;
})(THREE || (THREE = {}));
/// <reference path="./../math/Vector3" />
var THREE;
/// <reference path="./../math/Vector3" />
(function (THREE) {
    class Object3D extends THREE.EventDispatcher {
        constructor() {
            super();
            this.isObject3D = true;
            this.id = Object3D.object3DId++;
            this.uuid = THREE._Math.generateUUID();
            this.name = '';
            this.type = 'Object3D';
            this.parent = null;
            this.children = [];
            this.up = Object3D.DefaultUp.clone();
            this.position = new THREE.Vector3();
            this.rotation = new THREE.Euler();
            this.quaternion = new THREE.Quaternion();
            this.scale = new THREE.Vector3(1, 1, 1);
            this.rotation.onChange(this.onRotationChange());
            this.quaternion.onChange(this.onQuaternionChange());
            this.matrix = new THREE.Matrix4();
            this.modelViewMatrix = new THREE.Matrix4();
            this.matrixWorld = new THREE.Matrix4();
            this.normalMatrix = new THREE.Matrix3();
            this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
            this.matrixWorldNeedsUpdate = false;
            this.layers = new THREE.Layers();
            this.visible = true;
            this.castShadow = false;
            this.receiveShadow = false;
            this.frustumCulled = true;
            this.renderOrder = 0;
            this.userData = {};
        }
        onRotationChange() {
            return () => {
                this.quaternion.setFromEuler(this.rotation, false);
            };
        }
        onQuaternionChange() {
            return () => {
                this.rotation.setFromQuaternion(this.quaternion, undefined, false);
            };
        }
        // Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        onBeforeRender(render, scene, camera, geometry, material, group) {
        }
        onAfterRender(render, scene, camera, geometry, material, group) {
        }
        applyMatrix(matrix) {
            this.matrix.multiplyMatrices(matrix, this.matrix);
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(q) {
            this.quaternion.premultiply(q);
            return this;
        }
        setRotationFromAxisAngle(axis, angle) {
            // assumes axis is normalized
            this.quaternion.setFromAxisAngle(axis, angle);
        }
        setRotationFromEuler(euler) {
            this.quaternion.setFromEuler(euler, true);
        }
        setRotationFromMatrix(m) {
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            this.quaternion.setFromRotationMatrix(m);
        }
        setRotationFromQuaternion(q) {
            // assumes q is normalized
            this.quaternion.copy(q);
        }
        rotateOnAxis(axis, angle) {
            // rotate object on axis in object space
            // axis is assumed to be normalized
            //TODO:
            var q1 = new THREE.Quaternion();
            q1.setFromAxisAngle(axis, angle);
            this.quaternion.multiply(q1);
            return this;
        }
        rotateOnWorldAxis(axis, angle) {
            // rotate object on axis in world space
            // axis is assumed to be normalized
            // method assumes no rotated parent
            //TODO:
            var q1 = new THREE.Quaternion();
            q1.setFromAxisAngle(axis, angle);
            this.quaternion.premultiply(q1);
            return this;
        }
        rotateX(angle) {
            //TODO:
            var v1 = new THREE.Vector3(1, 0, 0);
            return this.rotateOnAxis(v1, angle);
        }
        rotateY(angle) {
            //TODO:
            var v1 = new THREE.Vector3(0, 1, 0);
            return this.rotateOnAxis(v1, angle);
        }
        rotateZ(angle) {
            //TODO:
            var v1 = new THREE.Vector3(0, 0, 1);
            return this.rotateOnAxis(v1, angle);
        }
        translateOnAxis(axis, distance) {
            // translate object by distance along axis in object space
            // axis is assumed to be normalized
            //TODO:
            var v1 = new THREE.Vector3();
            v1.copy(axis).applyQuaternion(this.quaternion);
            this.position.add(v1.multiplyScalar(distance));
            return this;
        }
        translateX(distance) {
            //TODO:
            var v1 = new THREE.Vector3(1, 0, 0);
            return this.translateOnAxis(v1, distance);
        }
        translateY(distance) {
            //TODO:
            var v1 = new THREE.Vector3(0, 1, 0);
            return this.translateOnAxis(v1, distance);
        }
        translateZ(distance) {
            //TODO:
            var v1 = new THREE.Vector3(0, 0, 1);
            return this.translateOnAxis(v1, distance);
        }
        localToWorld(vector) {
            return vector.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(vector) {
            //TODO:
            var m1 = new THREE.Matrix4();
            return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
        }
        lookAt(x, y, z) {
            // This method does not support objects with rotated and/or translated parent(s)
            //TODO:
            var m1 = new THREE.Matrix4();
            var vector = new THREE.Vector3();
            if (y == null) {
                vector.copy(x);
            }
            else {
                vector.set(x, y, z);
            }
            if (this.isCamera) {
                m1.lookAt(this.position, vector, this.up);
            }
            else {
                m1.lookAt(vector, this.position, this.up);
            }
            this.quaternion.setFromRotationMatrix(m1);
        }
        add(object) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.add(arguments[i]);
                }
                return this;
            }
            if (object === this) {
                console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
                return this;
            }
            if ((object && object.isObject3D)) {
                if (object.parent !== null) {
                    object.parent.remove(object);
                }
                object.parent = this;
                object.dispatchEvent({ type: 'added' });
                this.children.push(object);
            }
            else {
                console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
            }
            return this;
        }
        remove(object) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.remove(arguments[i]);
                }
                return this;
            }
            var index = this.children.indexOf(object);
            if (index !== -1) {
                object.parent = null;
                object.dispatchEvent({ type: 'removed' });
                this.children.splice(index, 1);
            }
            return this;
        }
        getObjectById(id) {
            return this.getObjectByProperty('id', id);
        }
        getObjectByName(name) {
            return this.getObjectByProperty('name', name);
        }
        getObjectByProperty(name, value) {
            if (this[name] === value)
                return this;
            for (var i = 0, l = this.children.length; i < l; i++) {
                var child = this.children[i];
                var object = child.getObjectByProperty(name, value);
                if (object !== undefined) {
                    return object;
                }
            }
            return undefined;
        }
        getWorldPosition(target) {
            if (target === undefined) {
                console.warn('THREE.Object3D: .getWorldPosition() target is now required');
                target = new THREE.Vector3();
            }
            this.updateMatrixWorld(true);
            return target.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(target) {
            //TODO:
            var position = new THREE.Vector3();
            var scale = new THREE.Vector3();
            if (target === undefined) {
                console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
                target = new THREE.Quaternion();
            }
            this.updateMatrixWorld(true);
            this.matrixWorld.decompose(position, target, scale);
            return target;
        }
        getWorldScale(target) {
            //TODO:
            var position = new THREE.Vector3();
            var quaternion = new THREE.Quaternion();
            if (target === undefined) {
                console.warn('THREE.Object3D: .getWorldScale() target is now required');
                target = new THREE.Vector3();
            }
            this.updateMatrixWorld(true);
            this.matrixWorld.decompose(position, quaternion, target);
            return target;
        }
        getWorldDirection(target) {
            //TODO:
            var quaternion = new THREE.Quaternion();
            if (target === undefined) {
                console.warn('THREE.Object3D: .getWorldDirection() target is now required');
                target = new THREE.Vector3();
            }
            this.getWorldQuaternion(quaternion);
            return target.set(0, 0, 1).applyQuaternion(quaternion);
        }
        raycast() { }
        traverse(callback) {
            callback(this);
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].traverse(callback);
            }
        }
        traverseVisible(callback) {
            if (this.visible === false)
                return;
            callback(this);
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].traverseVisible(callback);
            }
        }
        traverseAncestors(callback) {
            var parent = this.parent;
            if (parent !== null) {
                callback(parent);
                parent.traverseAncestors(callback);
            }
        }
        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale);
            this.matrixWorldNeedsUpdate = true;
        }
        /**
         * 更新matrixwrold参数，两种情况：force = true， matrixWorldNeedsUpdate = true
         * @param force 是否强制更新
         */
        updateMatrixWorld(force) {
            if (this.matrixAutoUpdate)
                this.updateMatrix();
            if (this.matrixWorldNeedsUpdate || force) {
                if (this.parent === null) {
                    this.matrixWorld.copy(this.matrix);
                }
                else {
                    this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                }
                this.matrixWorldNeedsUpdate = false;
                force = true;
            }
            // update children
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].updateMatrixWorld(force);
            }
        }
        toJSON(meta) {
            // meta is a string when called from JSON.stringify
            var isRootObject = (meta === undefined || typeof meta === 'string');
            var output = {};
            // meta is a hash used to collect geometries, materials.
            // not providing it implies that this is the root object
            // being serialized.
            if (isRootObject) {
                // initialize meta obj
                meta = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {}
                };
                output.metadata = {
                    version: 4.5,
                    type: 'Object',
                    generator: 'Object3D.toJSON'
                };
            }
            // standard Object3D serialization
            var object = {};
            object.uuid = this.uuid;
            object.type = this.type;
            if (this.name !== '')
                object.name = this.name;
            if (this.castShadow === true)
                object.castShadow = true;
            if (this.receiveShadow === true)
                object.receiveShadow = true;
            if (this.visible === false)
                object.visible = false;
            if (this.frustumCulled === false)
                object.frustumCulled = false;
            if (this.renderOrder !== 0)
                object.renderOrder = this.renderOrder;
            if (JSON.stringify(this.userData) !== '{}')
                object.userData = this.userData;
            object.matrix = this.matrix.toArray();
            if (this.matrixAutoUpdate === false)
                object.matrixAutoUpdate = false;
            //
            function serialize(library, element) {
                if (library[element.uuid] === undefined) {
                    library[element.uuid] = element.toJSON(meta);
                }
                return element.uuid;
            }
            if (this.geometry !== undefined) {
                object.geometry = serialize(meta.geometries, this.geometry);
                var parameters = this.geometry.parameters;
                if (parameters !== undefined && parameters.shapes !== undefined) {
                    var shapes = parameters.shapes;
                    if (Array.isArray(shapes)) {
                        for (var i = 0, l = shapes.length; i < l; i++) {
                            var shape = shapes[i];
                            serialize(meta.shapes, shape);
                        }
                    }
                    else {
                        serialize(meta.shapes, shapes);
                    }
                }
            }
            if (this.material !== undefined) {
                if (Array.isArray(this.material)) {
                    var uuids = [];
                    for (var i = 0, l = this.material.length; i < l; i++) {
                        uuids.push(serialize(meta.materials, this.material[i]));
                    }
                    object.material = uuids;
                }
                else {
                    object.material = serialize(meta.materials, this.material);
                }
            }
            //
            if (this.children.length > 0) {
                object.children = [];
                for (var i = 0; i < this.children.length; i++) {
                    object.children.push(this.children[i].toJSON(meta).object);
                }
            }
            if (isRootObject) {
                var geometries = extractFromCache(meta.geometries);
                var materials = extractFromCache(meta.materials);
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                var shapes = extractFromCache(meta.shapes);
                if (geometries.length > 0)
                    output.geometries = geometries;
                if (materials.length > 0)
                    output.materials = materials;
                if (textures.length > 0)
                    output.textures = textures;
                if (images.length > 0)
                    output.images = images;
                if (shapes.length > 0)
                    output.shapes = shapes;
            }
            output.object = object;
            return output;
            // extract data from the cache hash
            // remove metadata on each item
            // and return as array
            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
        }
        clone(recursive) {
            return new Object3D().copy(this, recursive);
        }
        copy(source, recursive) {
            if (recursive === undefined)
                recursive = true;
            this.name = source.name;
            this.up.copy(source.up);
            this.position.copy(source.position);
            this.quaternion.copy(source.quaternion);
            this.scale.copy(source.scale);
            this.matrix.copy(source.matrix);
            this.matrixWorld.copy(source.matrixWorld);
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
            this.layers.mask = source.layers.mask;
            this.visible = source.visible;
            this.castShadow = source.castShadow;
            this.receiveShadow = source.receiveShadow;
            this.frustumCulled = source.frustumCulled;
            this.renderOrder = source.renderOrder;
            this.userData = JSON.parse(JSON.stringify(source.userData));
            if (recursive === true) {
                for (var i = 0; i < source.children.length; i++) {
                    var child = source.children[i];
                    this.add(child.clone());
                }
            }
            return this;
        }
    }
    Object3D.object3DId = 0;
    Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);
    Object3D.DefaultMatrixAutoUpdate = true;
    THREE.Object3D = Object3D;
})(THREE || (THREE = {}));
/// <reference path="./../core/Object3D" />
var THREE;
/// <reference path="./../core/Object3D" />
(function (THREE) {
    class Audio extends THREE.Object3D {
        constructor(listener) {
            super();
            this.type = 'Audio';
            this.context = listener.context;
            this.gain = this.context.createGain();
            this.gain.connect(listener.getInput());
            this.autoplay = false;
            this.buffer = null;
            this.loop = false;
            this.startTime = 0;
            this.offset = 0;
            this.playbackRate = 1;
            this.isPlaying = false;
            this.hasPlaybackControl = true;
            this.sourceType = 'empty';
            this.filters = [];
        }
        getOutput() {
            return this.gain;
        }
        setNodeSource(audioNode) {
            this.hasPlaybackControl = false;
            this.sourceType = 'audioNode';
            this.source = audioNode;
            this.connect();
            return this;
        }
        setMediaElementSource(mediaElement) {
            this.hasPlaybackControl = false;
            this.sourceType = 'mediaNode';
            this.source = this.context.createMediaElementSource(mediaElement);
            this.connect();
            return this;
        }
        setBuffer(audioBuffer) {
            this.buffer = audioBuffer;
            this.sourceType = 'buffer';
            if (this.autoplay)
                this.play();
            return this;
        }
        play() {
            if (this.isPlaying === true) {
                console.warn('THREE.Audio: Audio is already playing.');
                return;
            }
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            var source = this.context.createBufferSource();
            source.buffer = this.buffer;
            source.loop = this.loop;
            source.onended = this.onEnded.bind(this);
            source.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
            this.startTime = this.context.currentTime;
            source.start(this.startTime, this.offset);
            this.isPlaying = true;
            this.source = source;
            return this.connect();
        }
        pause() {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            if (this.isPlaying === true) {
                this.source.stop();
                this.offset += (this.context.currentTime - this.startTime) * this.playbackRate;
                this.isPlaying = false;
            }
            return this;
        }
        stop() {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.source.stop();
            this.offset = 0;
            this.isPlaying = false;
            return this;
        }
        connect() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) {
                    this.filters[i - 1].connect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].connect(this.getOutput());
            }
            else {
                this.source.connect(this.getOutput());
            }
            return this;
        }
        disconnect() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) {
                    this.filters[i - 1].disconnect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].disconnect(this.getOutput());
            }
            else {
                this.source.disconnect(this.getOutput());
            }
            return this;
        }
        getFilters() {
            return this.filters;
        }
        setFilters(value) {
            if (!value)
                value = [];
            if (this.isPlaying === true) {
                this.disconnect();
                this.filters = value;
                this.connect();
            }
            else {
                this.filters = value;
            }
            return this;
        }
        getFilter() {
            return this.getFilters()[0];
        }
        setFilter(filter) {
            return this.setFilters(filter ? [filter] : []);
        }
        setPlaybackRate(value) {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.playbackRate = value;
            if (this.isPlaying === true) {
                this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime);
            }
            return this;
        }
        getPlaybackRate() {
            return this.playbackRate;
        }
        onEnded() {
            this.isPlaying = false;
        }
        getLoop() {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return false;
            }
            return this.loop;
        }
        setLoop(value) {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.loop = value;
            if (this.isPlaying === true) {
                this.source.loop = this.loop;
            }
            return this;
        }
        getVolume() {
            return this.gain.gain.value;
        }
        setVolume(value) {
            this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
            return this;
        }
    }
    THREE.Audio = Audio;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class AudioAnalyser {
        constructor(audio, fftSize) {
            this.analyser = audio.context.createAnalyser();
            this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
            this.data = new Uint8Array(this.analyser.frequencyBinCount);
            audio.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
            this.analyser.getByteFrequencyData(this.data);
            return this.data;
        }
        getAverageFrequency() {
            var value = 0, data = this.getFrequencyData();
            for (var i = 0; i < data.length; i++) {
                value += data[i];
            }
            return value / data.length;
        }
    }
    THREE.AudioAnalyser = AudioAnalyser;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var context;
    THREE.AudioContext = {
        getContext: function () {
            if (context === undefined) {
                context = new (window.AudioContext || window.webkitAudioContext)();
            }
            return context;
        },
        setContext: function (value) {
            context = value;
        }
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class AudioListener extends THREE.Object3D {
        constructor() {
            super();
            this.type = 'AudioListener';
            this.context = THREE.AudioContext.getContext();
            this.gain = this.context.createGain();
            this.gain.connect(this.context.destination);
            this.filter = null;
        }
        getInput() {
            return this.gain;
        }
        removeFilter() {
            if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
                this.gain.connect(this.context.destination);
                this.filter = null;
            }
        }
        getFilter() {
            return this.filter;
        }
        setFilter(value) {
            if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
            }
            else {
                this.gain.disconnect(this.context.destination);
            }
            this.filter = value;
            this.gain.connect(this.filter);
            this.filter.connect(this.context.destination);
        }
        getMasterVolume() {
            return this.gain.gain.value;
        }
        setMasterVolume(value) {
            this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        }
        updateMatrixWorld(force) {
            var position = new THREE.Vector3();
            var quaternion = new THREE.Quaternion();
            var scale = new THREE.Vector3();
            var orientation = new THREE.Vector3();
            THREE.Object3D.prototype.updateMatrixWorld.call(this, force);
            var listener = this.context.listener;
            var up = this.up;
            this.matrixWorld.decompose(position, quaternion, scale);
            orientation.set(0, 0, -1).applyQuaternion(quaternion);
            if (listener.positionX) {
                listener.positionX.setValueAtTime(position.x, this.context.currentTime);
                listener.positionY.setValueAtTime(position.y, this.context.currentTime);
                listener.positionZ.setValueAtTime(position.z, this.context.currentTime);
                listener.forwardX.setValueAtTime(orientation.x, this.context.currentTime);
                listener.forwardY.setValueAtTime(orientation.y, this.context.currentTime);
                listener.forwardZ.setValueAtTime(orientation.z, this.context.currentTime);
                listener.upX.setValueAtTime(up.x, this.context.currentTime);
                listener.upY.setValueAtTime(up.y, this.context.currentTime);
                listener.upZ.setValueAtTime(up.z, this.context.currentTime);
            }
            else {
                listener.setPosition(position.x, position.y, position.z);
                listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
            }
        }
        ;
    }
    THREE.AudioListener = AudioListener;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class PositionalAudio extends THREE.Audio {
        constructor(listener) {
            super(listener);
            this.panner = this.context.createPanner();
            this.panner.connect(this.gain);
        }
        getOutput() {
            return this.panner;
        }
        getRefDistance() {
            return this.panner.refDistance;
        }
        setRefDistance(value) {
            this.panner.refDistance = value;
        }
        getRolloffFactor() {
            return this.panner.rolloffFactor;
        }
        setRolloffFactor(value) {
            this.panner.rolloffFactor = value;
        }
        getDistanceModel() {
            return this.panner.distanceModel;
        }
        setDistanceModel(value) {
            this.panner.distanceModel = value;
        }
        getMaxDistance() {
            return this.panner.maxDistance;
        }
        setMaxDistance(value) {
            this.panner.maxDistance = value;
        }
        updateMatrixWorld(force) {
            var position = new THREE.Vector3();
            THREE.Object3D.prototype.updateMatrixWorld.call(this, force);
            position.setFromMatrixPosition(this.matrixWorld);
            this.panner.setPosition(position.x, position.y, position.z);
        }
        ;
    }
    THREE.PositionalAudio = PositionalAudio;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Camera extends THREE.Object3D {
        constructor() {
            super();
            this.type = 'Camera';
            this.matrixWorldInverse = new THREE.Matrix4();
            this.projectionMatrix = new THREE.Matrix4();
            this.isCamera = true;
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.matrixWorldInverse.copy(source.matrixWorldInverse);
            this.projectionMatrix.copy(source.projectionMatrix);
            return this;
        }
        getWorldDirection(target) {
            var quaternion = new THREE.Quaternion();
            if (target === undefined) {
                console.warn('THREE.Camera: .getWorldDirection() target is now required');
                target = new THREE.Vector3();
            }
            this.getWorldQuaternion(quaternion);
            return target.set(0, 0, -1).applyQuaternion(quaternion);
        }
        ;
        updateMatrixWorld(force) {
            super.updateMatrixWorld(force);
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        }
        clone() {
            var camera = new Camera();
            camera.copy(this, null);
            return camera;
        }
    }
    THREE.Camera = Camera;
})(THREE || (THREE = {}));
/// <reference path="./Camera" />
var THREE;
/// <reference path="./Camera" />
(function (THREE) {
    class PerspectiveCamera extends THREE.Camera {
        constructor(fov, aspect, near, far) {
            super();
            this.type = 'PerspectiveCamera';
            this.fov = fov !== undefined ? fov : 50;
            this.zoom = 1;
            this.near = near !== undefined ? near : 0.1;
            this.far = far !== undefined ? far : 2000;
            this.focus = 10;
            this.aspect = aspect !== undefined ? aspect : 1;
            this.view = null;
            this.filmGauge = 35; // width of the film (default in millimeters)
            this.filmOffset = 0; // horizontal film offset (same unit as gauge)
            this.isPerspectiveCamera = true;
            this.updateProjectionMatrix();
        }
        copy(source, recursive) {
            THREE.Camera.prototype.copy.call(this, source, recursive);
            this.fov = source.fov;
            this.zoom = source.zoom;
            this.near = source.near;
            this.far = source.far;
            this.focus = source.focus;
            this.aspect = source.aspect;
            this.view = source.view === null ? null : Object.assign({}, source.view);
            this.filmGauge = source.filmGauge;
            this.filmOffset = source.filmOffset;
            return this;
        }
        /**
         * Sets the FOV by focal length in respect to the current .filmGauge.
         *
         * The default film gauge is 35, so that the focal length can be specified for
         * a 35mm (full frame) camera.
         *
         * Values for focal length and film gauge must have the same unit.
         */
        setFocalLength(focalLength) {
            // see http://www.bobatkins.com/photography/technical/field_of_view.html
            var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
            this.fov = THREE._Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
            this.updateProjectionMatrix();
        }
        /**
         * Calculates the focal length from the current .fov and .filmGauge.
         */
        getFocalLength() {
            var vExtentSlope = Math.tan(THREE._Math.DEG2RAD * 0.5 * this.fov);
            return 0.5 * this.getFilmHeight() / vExtentSlope;
        }
        getEffectiveFOV() {
            return THREE._Math.RAD2DEG * 2 * Math.atan(Math.tan(THREE._Math.DEG2RAD * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
            // film not completely covered in portrait format (aspect < 1)
            return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
            // film not completely covered in landscape format (aspect > 1)
            return this.filmGauge / Math.max(this.aspect, 1);
        }
        /**
         * Sets an offset in a larger frustum. This is useful for multi-window or
         * multi-monitor/multi-machine setups.
         *
         * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
         * the monitors are in grid like this
         *
         *   +---+---+---+
         *   | A | B | C |
         *   +---+---+---+
         *   | D | E | F |
         *   +---+---+---+
         *
         * then for each monitor you would call it like this
         *
         *   var w = 1920;
         *   var h = 1080;
         *   var fullWidth = w * 3;
         *   var fullHeight = h * 2;
         *
         *   --A--
         *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
         *   --B--
         *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
         *   --C--
         *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
         *   --D--
         *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
         *   --E--
         *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
         *   --F--
         *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
         *
         *   Note there is no reason monitors have to be the same size or in a grid.
         */
        setViewOffset(fullWidth, fullHeight, x, y, width, height) {
            this.aspect = fullWidth / fullHeight;
            if (this.view === null) {
                this.view = {
                    enabled: true,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                };
            }
            this.view.enabled = true;
            this.view.fullWidth = fullWidth;
            this.view.fullHeight = fullHeight;
            this.view.offsetX = x;
            this.view.offsetY = y;
            this.view.width = width;
            this.view.height = height;
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
            if (this.view !== null) {
                this.view.enabled = false;
            }
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
            var near = this.near, top = near * Math.tan(THREE._Math.DEG2RAD * 0.5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width, view = this.view;
            if (this.view !== null && this.view.enabled) {
                var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
                left += view.offsetX * width / fullWidth;
                top -= view.offsetY * height / fullHeight;
                width *= view.width / fullWidth;
                height *= view.height / fullHeight;
            }
            var skew = this.filmOffset;
            if (skew !== 0)
                left += near * skew / this.getFilmWidth();
            this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        }
        toJSON(meta) {
            var data = THREE.Object3D.prototype.toJSON.call(this, meta);
            data.object.fov = this.fov;
            data.object.zoom = this.zoom;
            data.object.near = this.near;
            data.object.far = this.far;
            data.object.focus = this.focus;
            data.object.aspect = this.aspect;
            if (this.view !== null)
                data.object.view = Object.assign({}, this.view);
            data.object.filmGauge = this.filmGauge;
            data.object.filmOffset = this.filmOffset;
            return data;
        }
    }
    THREE.PerspectiveCamera = PerspectiveCamera;
})(THREE || (THREE = {}));
/// <reference path="./PerspectiveCamera.ts" />
var THREE;
/// <reference path="./PerspectiveCamera.ts" />
(function (THREE) {
    class ArrayCamera extends THREE.PerspectiveCamera {
        constructor(array) {
            super(null, null, null, null);
            this.cameras = array || [];
            this.isArrayCamera = true;
        }
    }
    THREE.ArrayCamera = ArrayCamera;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class CubeCamera extends THREE.Object3D {
        constructor(near, far, cubeResolution) {
            super();
            this.type = 'CubeCamera';
            var fov = 90, aspect = 1;
            var cameraPX = CubeCamera.cameraPX = new THREE.PerspectiveCamera(fov, aspect, near, far);
            cameraPX.up.set(0, -1, 0);
            cameraPX.lookAt(new THREE.Vector3(1, 0, 0), null, null);
            this.add(cameraPX);
            var cameraNX = CubeCamera.cameraNX = new THREE.PerspectiveCamera(fov, aspect, near, far);
            cameraNX.up.set(0, -1, 0);
            cameraNX.lookAt(new THREE.Vector3(-1, 0, 0), null, null);
            this.add(cameraNX);
            var cameraPY = CubeCamera.cameraPY = new THREE.PerspectiveCamera(fov, aspect, near, far);
            cameraPY.up.set(0, 0, 1);
            cameraPY.lookAt(new THREE.Vector3(0, 1, 0), null, null);
            this.add(cameraPY);
            var cameraNY = CubeCamera.cameraNY = new THREE.PerspectiveCamera(fov, aspect, near, far);
            cameraNY.up.set(0, 0, -1);
            cameraNY.lookAt(new THREE.Vector3(0, -1, 0), null, null);
            this.add(cameraNY);
            var cameraPZ = CubeCamera.cameraPZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
            cameraPZ.up.set(0, -1, 0);
            cameraPZ.lookAt(new THREE.Vector3(0, 0, 1), null, null);
            this.add(cameraPZ);
            var cameraNZ = CubeCamera.cameraNZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
            cameraNZ.up.set(0, -1, 0);
            cameraNZ.lookAt(new THREE.Vector3(0, 0, -1), null, null);
            this.add(cameraNZ);
            var options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };
            this.renderTarget = new THREE.WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
            this.renderTarget.texture.name = "CubeCamera";
        }
        update(renderer, scene) {
            var cameraPX = CubeCamera.cameraPX;
            var cameraPY = CubeCamera.cameraPY;
            var cameraPZ = CubeCamera.cameraPZ;
            var cameraNX = CubeCamera.cameraNX;
            var cameraNY = CubeCamera.cameraNY;
            var cameraNZ = CubeCamera.cameraNZ;
            if (this.parent === null)
                this.updateMatrixWorld(null);
            var renderTarget = this.renderTarget;
            var generateMipmaps = renderTarget.texture.generateMipmaps;
            renderTarget.texture.generateMipmaps = false;
            renderTarget.activeCubeFace = 0;
            renderer.render(scene, cameraPX, renderTarget);
            renderTarget.activeCubeFace = 1;
            renderer.render(scene, cameraNX, renderTarget);
            renderTarget.activeCubeFace = 2;
            renderer.render(scene, cameraPY, renderTarget);
            renderTarget.activeCubeFace = 3;
            renderer.render(scene, cameraNY, renderTarget);
            renderTarget.activeCubeFace = 4;
            renderer.render(scene, cameraPZ, renderTarget);
            renderTarget.texture.generateMipmaps = generateMipmaps;
            renderTarget.activeCubeFace = 5;
            renderer.render(scene, cameraNZ, renderTarget);
            renderer.setRenderTarget(null);
        }
        ;
        clear(renderer, color, depth, stencil) {
            var renderTarget = this.renderTarget;
            for (var i = 0; i < 6; i++) {
                renderTarget.activeCubeFace = i;
                renderer.setRenderTarget(renderTarget);
                renderer.clear(color, depth, stencil);
            }
            renderer.setRenderTarget(null);
        }
        ;
    }
    THREE.CubeCamera = CubeCamera;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class OrthographicCamera extends THREE.Camera {
        constructor(left, right, top, bottom, near, far) {
            super();
            this.type = 'OrthographicCamera';
            this.zoom = 1;
            this.view = null;
            this.left = left;
            this.right = right;
            this.top = top;
            this.bottom = bottom;
            this.near = (near !== undefined) ? near : 0.1;
            this.far = (far !== undefined) ? far : 2000;
            this.isOrthographicCamera = true;
            this.updateProjectionMatrix();
        }
        copy(source, recursive) {
            super.copy(source, recursive);
            this.left = source.left;
            this.right = source.right;
            this.top = source.top;
            this.bottom = source.bottom;
            this.near = source.near;
            this.far = source.far;
            this.zoom = source.zoom;
            this.view = source.view === null ? null : Object.assign({}, source.view);
            return this;
        }
        setViewOffset(fullWidth, fullHeight, x, y, width, height) {
            if (this.view === null) {
                this.view = {
                    enabled: true,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                };
            }
            this.view.enabled = true;
            this.view.fullWidth = fullWidth;
            this.view.fullHeight = fullHeight;
            this.view.offsetX = x;
            this.view.offsetY = y;
            this.view.width = width;
            this.view.height = height;
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
            if (this.view !== null) {
                this.view.enabled = false;
            }
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
            var dx = (this.right - this.left) / (2 * this.zoom);
            var dy = (this.top - this.bottom) / (2 * this.zoom);
            var cx = (this.right + this.left) / 2;
            var cy = (this.top + this.bottom) / 2;
            var left = cx - dx;
            var right = cx + dx;
            var top = cy + dy;
            var bottom = cy - dy;
            if (this.view !== null && this.view.enabled) {
                var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
                var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
                var scaleW = (this.right - this.left) / this.view.width;
                var scaleH = (this.top - this.bottom) / this.view.height;
                left += scaleW * (this.view.offsetX / zoomW);
                right = left + scaleW * (this.view.width / zoomW);
                top -= scaleH * (this.view.offsetY / zoomH);
                bottom = top - scaleH * (this.view.height / zoomH);
            }
            this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        }
        toJSON(meta) {
            var data = THREE.Object3D.prototype.toJSON.call(this, meta);
            data.object.zoom = this.zoom;
            data.object.left = this.left;
            data.object.right = this.right;
            data.object.top = this.top;
            data.object.bottom = this.bottom;
            data.object.near = this.near;
            data.object.far = this.far;
            if (this.view !== null)
                data.object.view = Object.assign({}, this.view);
            return data;
        }
    }
    THREE.OrthographicCamera = OrthographicCamera;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class StereoCamera {
        constructor() {
            this.type = 'StereoCamera';
            this.aspect = 1;
            this.eyeSep = 0.064;
            this.cameraL = new THREE.PerspectiveCamera(null, null, null, null);
            this.cameraL.layers.enable(1);
            this.cameraL.matrixAutoUpdate = false;
            this.cameraR = new THREE.PerspectiveCamera(null, null, null, null);
            this.cameraR.layers.enable(2);
            this.cameraR.matrixAutoUpdate = false;
        }
        update(camera) {
            var instance, focus, fov, aspect, near, far, zoom, eyeSep;
            var eyeRight = new THREE.Matrix4();
            var eyeLeft = new THREE.Matrix4();
            var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
                aspect !== camera.aspect * this.aspect || near !== camera.near ||
                far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;
            if (needsUpdate) {
                instance = this;
                focus = camera.focus;
                fov = camera.fov;
                aspect = camera.aspect * this.aspect;
                near = camera.near;
                far = camera.far;
                zoom = camera.zoom;
                // Off-axis stereoscopic effect based on
                // http://paulbourke.net/stereographics/stereorender/
                var projectionMatrix = camera.projectionMatrix.clone();
                eyeSep = this.eyeSep / 2;
                var eyeSepOnProjection = eyeSep * near / focus;
                var ymax = (near * Math.tan(THREE._Math.DEG2RAD * fov * 0.5)) / zoom;
                var xmin, xmax;
                // translate xOffset
                eyeLeft.elements[12] = -eyeSep;
                eyeRight.elements[12] = eyeSep;
                // for left eye
                xmin = -ymax * aspect + eyeSepOnProjection;
                xmax = ymax * aspect + eyeSepOnProjection;
                projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                this.cameraL.projectionMatrix.copy(projectionMatrix);
                // for right eye
                xmin = -ymax * aspect - eyeSepOnProjection;
                xmax = ymax * aspect - eyeSepOnProjection;
                projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                this.cameraR.projectionMatrix.copy(projectionMatrix);
            }
            this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
            this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
        }
        ;
    }
    THREE.StereoCamera = StereoCamera;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class BufferAttribute {
        constructor(array, itemSize, normalized) {
            if (Array.isArray(array)) {
                throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
            }
            this.name = '';
            this.array = array;
            this.itemSize = itemSize;
            this.count = array !== undefined ? array.length / itemSize : 0;
            this.normalized = normalized === true;
            this.dynamic = false;
            this.updateRange = { offset: 0, count: -1 };
            this.version = 0;
            this.isBufferAttribute = true;
        }
        set needsUpdate(value) {
            if (value === true)
                this.version++;
        }
        onUploadCallback() {
        }
        setArray(array) {
            if (Array.isArray(array)) {
                throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
            }
            this.count = array !== undefined ? array.length / this.itemSize : 0;
            this.array = array;
            return this;
        }
        setDynamic(value) {
            this.dynamic = value;
            return this;
        }
        copy(source) {
            this.name = source.name;
            this.array = new source.array.constructor(source.array);
            this.itemSize = source.itemSize;
            this.count = source.count;
            this.normalized = source.normalized;
            this.dynamic = source.dynamic;
            return this;
        }
        copyAt(index1, attribute, index2) {
            index1 *= this.itemSize;
            index2 *= attribute.itemSize;
            for (var i = 0, l = this.itemSize; i < l; i++) {
                this.array[index1 + i] = attribute.array[index2 + i];
            }
            return this;
        }
        copyArray(array) {
            this.array.set(array);
            return this;
        }
        copyColorsArray(colors) {
            var array = this.array, offset = 0;
            for (var i = 0, l = colors.length; i < l; i++) {
                var color = colors[i];
                if (color === undefined) {
                    console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
                    color = new THREE.Color(null, null, null);
                }
                array[offset++] = color.r;
                array[offset++] = color.g;
                array[offset++] = color.b;
            }
            return this;
        }
        copyVector2sArray(vectors) {
            var array = this.array, offset = 0;
            for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                if (vector === undefined) {
                    console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
                    vector = new THREE.Vector2();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
            }
            return this;
        }
        copyVector3sArray(vectors) {
            var array = this.array, offset = 0;
            for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                if (vector === undefined) {
                    console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
                    vector = new THREE.Vector3();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
            }
            return this;
        }
        copyVector4sArray(vectors) {
            var array = this.array, offset = 0;
            for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                if (vector === undefined) {
                    console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
                    vector = new THREE.Vector4();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
                array[offset++] = vector.w;
            }
            return this;
        }
        set(value, offset) {
            if (offset === undefined)
                offset = 0;
            this.array.set(value, offset);
            return this;
        }
        getX(index) {
            return this.array[index * this.itemSize];
        }
        setX(index, x) {
            this.array[index * this.itemSize] = x;
            return this;
        }
        getY(index) {
            return this.array[index * this.itemSize + 1];
        }
        setY(index, y) {
            this.array[index * this.itemSize + 1] = y;
            return this;
        }
        getZ(index) {
            return this.array[index * this.itemSize + 2];
        }
        setZ(index, z) {
            this.array[index * this.itemSize + 2] = z;
            return this;
        }
        getW(index) {
            return this.array[index * this.itemSize + 3];
        }
        setW(index, w) {
            this.array[index * this.itemSize + 3] = w;
            return this;
        }
        setXY(index, x, y) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            return this;
        }
        setXYZ(index, x, y, z) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;
            return this;
        }
        setXYZW(index, x, y, z, w) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;
            this.array[index + 3] = w;
            return this;
        }
        onUpload(callback) {
            this.onUploadCallback = callback;
            return this;
        }
        clone() {
            var bufferattribute = new BufferAttribute(this.array, this.itemSize, null);
            bufferattribute.copy(this);
            return bufferattribute;
        }
    }
    THREE.BufferAttribute = BufferAttribute;
    class Int8BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Int8Array(array), itemSize, normalized);
        }
    }
    THREE.Int8BufferAttribute = Int8BufferAttribute;
    class Uint8BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Uint8Array(array), itemSize, normalized);
        }
    }
    THREE.Uint8BufferAttribute = Uint8BufferAttribute;
    class Uint8ClampedBufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Uint8Array(array), itemSize, normalized);
        }
    }
    THREE.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
    class Int16BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Int16Array(array), itemSize, normalized);
        }
    }
    THREE.Int16BufferAttribute = Int16BufferAttribute;
    class Uint16BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Uint16Array(array), itemSize, normalized);
        }
    }
    THREE.Uint16BufferAttribute = Uint16BufferAttribute;
    class Int32BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Int32Array(array), itemSize, normalized);
        }
    }
    THREE.Int32BufferAttribute = Int32BufferAttribute;
    class Uint32BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Uint32Array(array), itemSize, normalized);
        }
    }
    THREE.Uint32BufferAttribute = Uint32BufferAttribute;
    class Float32BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Float32Array(array), itemSize, normalized);
        }
    }
    THREE.Float32BufferAttribute = Float32BufferAttribute;
    class Float64BufferAttribute extends BufferAttribute {
        constructor(array, itemSize, normalized) {
            super(new Float64Array(array), itemSize, normalized);
        }
    }
    THREE.Float64BufferAttribute = Float64BufferAttribute;
})(THREE || (THREE = {}));
;
var THREE;
(function (THREE) {
    var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id
    class BufferGeometry extends THREE.EventDispatcher {
        constructor() {
            super();
            this.id = bufferGeometryId++;
            this.uuid = THREE._Math.generateUUID();
            this.name = '';
            this.type = 'BufferGeometry';
            this.index = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.groups = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.drawRange = { start: 0, count: Infinity };
            this.isBufferGeometry = true;
        }
        getIndex() {
            return this.index;
        }
        setIndex(index) {
            if (Array.isArray(index)) {
                this.index = new (THREE.arrayMax(index) > 65535 ? THREE.Uint32BufferAttribute : THREE.Uint16BufferAttribute)(index, 1, null);
            }
            else {
                this.index = index;
            }
        }
        addAttribute(name, attribute) {
            if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
                console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
                this.addAttribute(name, new THREE.BufferAttribute(arguments[1], arguments[2], null));
                return;
            }
            if (name === 'index') {
                console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
                this.setIndex(attribute);
                return;
            }
            this.attributes[name] = attribute;
            return this;
        }
        getAttribute(name) {
            return this.attributes[name];
        }
        removeAttribute(name) {
            delete this.attributes[name];
            return this;
        }
        addGroup(start, count, materialIndex) {
            this.groups.push({
                start: start,
                count: count,
                materialIndex: materialIndex !== undefined ? materialIndex : 0
            });
        }
        clearGroups() {
            this.groups = [];
        }
        setDrawRange(start, count) {
            this.drawRange.start = start;
            this.drawRange.count = count;
        }
        applyMatrix(matrix) {
            var position = this.attributes.position;
            if (position !== undefined) {
                matrix.applyToBufferAttribute(position);
                position.needsUpdate = true;
            }
            var normal = this.attributes.normal;
            if (normal !== undefined) {
                var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
                normalMatrix.applyToBufferAttribute(normal);
                normal.needsUpdate = true;
            }
            if (this.boundingBox !== null) {
                this.computeBoundingBox();
            }
            if (this.boundingSphere !== null) {
                this.computeBoundingSphere();
            }
            return this;
        }
        rotateX(angle) {
            var m1 = new THREE.Matrix4();
            m1.makeRotationX(angle);
            this.applyMatrix(m1);
            return this;
        }
        ;
        rotateY(angle) {
            var m1 = new THREE.Matrix4();
            m1.makeRotationY(angle);
            this.applyMatrix(m1);
            return this;
        }
        ;
        rotateZ(angle) {
            var m1 = new THREE.Matrix4();
            m1.makeRotationZ(angle);
            this.applyMatrix(m1);
            return this;
        }
        ;
        translate(x, y, z) {
            var m1 = new THREE.Matrix4();
            m1.makeTranslation(x, y, z);
            this.applyMatrix(m1);
            return this;
        }
        ;
        scale(x, y, z) {
            var m1 = new THREE.Matrix4();
            m1.makeScale(x, y, z);
            this.applyMatrix(m1);
            return this;
        }
        ;
        lookAt(vector) {
            var obj = new THREE.Object3D();
            obj.lookAt(vector, null, null);
            obj.updateMatrix();
            this.applyMatrix(obj.matrix);
        }
        ;
        center() {
            var offset = new THREE.Vector3();
            this.computeBoundingBox();
            this.boundingBox.getCenter(offset).negate();
            this.translate(offset.x, offset.y, offset.z);
            return this;
        }
        ;
        /**
         * 从mesh 、line point 等物品类型中设置buffergeometry
         * @param object
         */
        setFromObject(object) {
            // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
            var geometry = object.geometry;
            if (object.isPoints || object.isLine) {
                var positions = new THREE.Float32BufferAttribute(geometry.vertices.length * 3, 3, null);
                var colors = new THREE.Float32BufferAttribute(geometry.colors.length * 3, 3, null);
                this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
                this.addAttribute('color', colors.copyColorsArray(geometry.colors));
                if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                    var lineDistances = new THREE.Float32BufferAttribute(geometry.lineDistances.length, 1, null);
                    this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
                }
                if (geometry.boundingSphere !== null) {
                    this.boundingSphere = geometry.boundingSphere.clone();
                }
                if (geometry.boundingBox !== null) {
                    this.boundingBox = geometry.boundingBox.clone();
                }
            }
            else if (object.isMesh) {
                if (geometry && geometry.isGeometry) {
                    this.fromGeometry(geometry);
                }
            }
            return this;
        }
        /**
         * 从点集设置buffergeometry 的值
         * @param points
         */
        setFromPoints(points) {
            var position = [];
            for (var i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                position.push(point.x, point.y, point.z || 0);
            }
            this.addAttribute('position', new THREE.Float32BufferAttribute(position, 3, null));
            return this;
        }
        /**
         * 从其他物体更新当前buffergeometry的属性值
         * @param object
         */
        updateFromObject(object) {
            var geometry = object.geometry;
            if (object.isMesh) {
                var direct = geometry.__directGeometry;
                if (geometry.elementsNeedUpdate === true) {
                    direct = undefined;
                    geometry.elementsNeedUpdate = false;
                }
                if (direct === undefined) {
                    return this.fromGeometry(geometry);
                }
                direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
                direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
                direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
                direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
                direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
                geometry.verticesNeedUpdate = false;
                geometry.normalsNeedUpdate = false;
                geometry.colorsNeedUpdate = false;
                geometry.uvsNeedUpdate = false;
                geometry.groupsNeedUpdate = false;
                geometry = direct;
            }
            var attribute;
            if (geometry.verticesNeedUpdate === true) {
                attribute = this.attributes.position;
                if (attribute !== undefined) {
                    attribute.copyVector3sArray(geometry.vertices);
                    attribute.needsUpdate = true;
                }
                geometry.verticesNeedUpdate = false;
            }
            if (geometry.normalsNeedUpdate === true) {
                attribute = this.attributes.normal;
                if (attribute !== undefined) {
                    attribute.copyVector3sArray(geometry.normals);
                    attribute.needsUpdate = true;
                }
                geometry.normalsNeedUpdate = false;
            }
            if (geometry.colorsNeedUpdate === true) {
                attribute = this.attributes.color;
                if (attribute !== undefined) {
                    attribute.copyColorsArray(geometry.colors);
                    attribute.needsUpdate = true;
                }
                geometry.colorsNeedUpdate = false;
            }
            if (geometry.uvsNeedUpdate) {
                attribute = this.attributes.uv;
                if (attribute !== undefined) {
                    attribute.copyVector2sArray(geometry.uvs);
                    attribute.needsUpdate = true;
                }
                geometry.uvsNeedUpdate = false;
            }
            if (geometry.lineDistancesNeedUpdate) {
                attribute = this.attributes.lineDistance;
                if (attribute !== undefined) {
                    attribute.copyArray(geometry.lineDistances);
                    attribute.needsUpdate = true;
                }
                geometry.lineDistancesNeedUpdate = false;
            }
            if (geometry.groupsNeedUpdate) {
                geometry.computeGroups(object.geometry);
                this.groups = geometry.groups;
                geometry.groupsNeedUpdate = false;
            }
            return this;
        }
        /**
         * 从几何中设置buffergeometry
         * @param geometry
         */
        fromGeometry(geometry) {
            geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry(geometry);
            return this.fromDirectGeometry(geometry.__directGeometry);
        }
        /**
         * 从direct geometry 向buffer geometry 提供内存空间大小，和赋值
         * @param geometry  dire
         */
        fromDirectGeometry(geometry) {
            // 顶点坐标
            var positions = new Float32Array(geometry.vertices.length * 3);
            this.addAttribute('position', new THREE.BufferAttribute(positions, 3, null).copyVector3sArray(geometry.vertices));
            // 顶点法向
            if (geometry.normals.length > 0) {
                var normals = new Float32Array(geometry.normals.length * 3);
                this.addAttribute('normal', new THREE.BufferAttribute(normals, 3, null).copyVector3sArray(geometry.normals));
            }
            // 顶点颜色
            if (geometry.colors.length > 0) {
                var colors = new Float32Array(geometry.colors.length * 3);
                this.addAttribute('color', new THREE.BufferAttribute(colors, 3, null).copyColorsArray(geometry.colors));
            }
            // 顶点uv
            if (geometry.uvs.length > 0) {
                var uvs = new Float32Array(geometry.uvs.length * 2);
                this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2, null).copyVector2sArray(geometry.uvs));
            }
            // 顶点uv2
            if (geometry.uvs2.length > 0) {
                var uvs2 = new Float32Array(geometry.uvs2.length * 2);
                this.addAttribute('uv2', new THREE.BufferAttribute(uvs2, 2, null).copyVector2sArray(geometry.uvs2));
            }
            // groups
            this.groups = geometry.groups;
            // morphs
            for (var name in geometry.morphTargets) {
                var array = [];
                var morphTargets = geometry.morphTargets[name];
                for (var i = 0, l = morphTargets.length; i < l; i++) {
                    var morphTarget = morphTargets[i];
                    var attribute = new THREE.Float32BufferAttribute(morphTarget.length * 3, 3, null);
                    array.push(attribute.copyVector3sArray(morphTarget));
                }
                this.morphAttributes[name] = array;
            }
            // skinning
            if (geometry.skinIndices.length > 0) {
                var skinIndices = new THREE.Float32BufferAttribute(geometry.skinIndices.length * 4, 4, null);
                this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
            }
            if (geometry.skinWeights.length > 0) {
                var skinWeights = new THREE.Float32BufferAttribute(geometry.skinWeights.length * 4, 4, null);
                this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
            }
            //
            if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
            }
            if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
            }
            return this;
        }
        /**
         * 计算包围框
         */
        computeBoundingBox() {
            if (this.boundingBox === null) {
                this.boundingBox = new THREE.Box3();
            }
            var position = this.attributes.position;
            if (position !== undefined) {
                this.boundingBox.setFromBufferAttribute(position);
            }
            else {
                this.boundingBox.makeEmpty();
            }
            if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
                console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
            }
        }
        /**
         * 计算包围球体
        */
        computeBoundingSphere() {
            var box = new THREE.Box3();
            var vector = new THREE.Vector3();
            if (this.boundingSphere === null) {
                this.boundingSphere = new THREE.Sphere();
            }
            var position = this.attributes.position;
            if (position) {
                var center = this.boundingSphere.center;
                box.setFromBufferAttribute(position);
                box.getCenter(center);
                // hoping to find a boundingSphere with a radius smaller than the
                // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
                var maxRadiusSq = 0;
                for (var i = 0, il = position.count; i < il; i++) {
                    vector.x = position.getX(i);
                    vector.y = position.getY(i);
                    vector.z = position.getZ(i);
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
                }
                this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
                if (isNaN(this.boundingSphere.radius)) {
                    console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                }
            }
        }
        ;
        computeFaceNormals() {
            // backwards compatibility
        }
        /**
         * 计算顶点法向
         */
        computeVertexNormals() {
            var index = this.index;
            var attributes = this.attributes;
            var groups = this.groups;
            if (attributes.position) {
                var positions = attributes.position.array;
                if (attributes.normal === undefined) {
                    this.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(positions.length), 3, null));
                }
                else {
                    // reset existing normals to zero
                    var array = attributes.normal.array;
                    for (var i = 0, il = array.length; i < il; i++) {
                        array[i] = 0;
                    }
                }
                var normals = attributes.normal.array;
                var vA, vB, vC;
                var pA = new THREE.Vector3(), pB = new THREE.Vector3(), pC = new THREE.Vector3();
                var cb = new THREE.Vector3(), ab = new THREE.Vector3();
                // indexed elements
                if (index) {
                    var indices = index.array;
                    if (groups.length === 0) {
                        this.addGroup(0, indices.length, null);
                    }
                    for (var j = 0, jl = groups.length; j < jl; ++j) {
                        var group = groups[j];
                        var start = group.start;
                        var count = group.count;
                        for (i = start, il = start + count; i < il; i += 3) {
                            vA = indices[i + 0] * 3;
                            vB = indices[i + 1] * 3;
                            vC = indices[i + 2] * 3;
                            pA.fromArray(positions, vA);
                            pB.fromArray(positions, vB);
                            pC.fromArray(positions, vC);
                            cb.subVectors(pC, pB);
                            ab.subVectors(pA, pB);
                            cb.cross(ab);
                            normals[vA] += cb.x;
                            normals[vA + 1] += cb.y;
                            normals[vA + 2] += cb.z;
                            normals[vB] += cb.x;
                            normals[vB + 1] += cb.y;
                            normals[vB + 2] += cb.z;
                            normals[vC] += cb.x;
                            normals[vC + 1] += cb.y;
                            normals[vC + 2] += cb.z;
                        }
                    }
                }
                else {
                    // non-indexed elements (unconnected triangle soup)
                    for (var i = 0, il = positions.length; i < il; i += 9) {
                        pA.fromArray(positions, i);
                        pB.fromArray(positions, i + 3);
                        pC.fromArray(positions, i + 6);
                        cb.subVectors(pC, pB);
                        ab.subVectors(pA, pB);
                        cb.cross(ab);
                        normals[i] = cb.x;
                        normals[i + 1] = cb.y;
                        normals[i + 2] = cb.z;
                        normals[i + 3] = cb.x;
                        normals[i + 4] = cb.y;
                        normals[i + 5] = cb.z;
                        normals[i + 6] = cb.x;
                        normals[i + 7] = cb.y;
                        normals[i + 8] = cb.z;
                    }
                }
                this.normalizeNormals();
                attributes.normal.needsUpdate = true;
            }
        }
        // 合并
        merge(geometry, offset) {
            if (!(geometry && geometry.isBufferGeometry)) {
                console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
                return;
            }
            if (offset === undefined) {
                offset = 0;
                console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
                    + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
            }
            var attributes = this.attributes;
            for (var key in attributes) {
                if (geometry.attributes[key] === undefined)
                    continue;
                var attribute1 = attributes[key];
                var attributeArray1 = attribute1.array;
                var attribute2 = geometry.attributes[key];
                var attributeArray2 = attribute2.array;
                var attributeSize = attribute2.itemSize;
                for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
                    attributeArray1[j] = attributeArray2[i];
                }
            }
            return this;
        }
        /**
         * 法向归一化
         */
        normalizeNormals() {
            var vector = new THREE.Vector3();
            var normals = this.attributes.normal;
            for (var i = 0, il = normals.count; i < il; i++) {
                vector.x = normals.getX(i);
                vector.y = normals.getY(i);
                vector.z = normals.getZ(i);
                vector.normalize();
                normals.setXYZ(i, vector.x, vector.y, vector.z);
            }
        }
        /**
         * 无索引
         */
        toNonIndexed() {
            if (this.index === null) {
                console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
                return this;
            }
            var geometry2 = new BufferGeometry();
            var indices = this.index.array;
            var attributes = this.attributes;
            for (var name in attributes) {
                var attribute = attributes[name];
                var array = attribute.array;
                var itemSize = attribute.itemSize;
                var array2 = new array.constructor(indices.length * itemSize);
                var index = 0, index2 = 0;
                for (var i = 0, l = indices.length; i < l; i++) {
                    index = indices[i] * itemSize;
                    for (var j = 0; j < itemSize; j++) {
                        array2[index2++] = array[index++];
                    }
                }
                geometry2.addAttribute(name, new THREE.BufferAttribute(array2, itemSize, null));
            }
            var groups = this.groups;
            for (var i = 0, c = groups.length; i < c; i++) {
                var group = groups[i];
                geometry2.addGroup(group.start, group.count, group.materialIndex);
            }
            return geometry2;
        }
        toJSON() {
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'BufferGeometry',
                    generator: 'BufferGeometry.toJSON'
                }
            };
            // standard BufferGeometry serialization
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '')
                data.name = this.name;
            if (this.parameters !== undefined) {
                var parameters = this.parameters;
                for (var key in parameters) {
                    if (parameters[key] !== undefined)
                        data[key] = parameters[key];
                }
                return data;
            }
            data.data = { attributes: {} };
            var index = this.index;
            if (index !== null) {
                var array = Array.prototype.slice.call(index.array);
                data.data.index = {
                    type: index.array.constructor.name,
                    array: array
                };
            }
            var attributes = this.attributes;
            for (var key in attributes) {
                var attribute = attributes[key];
                var array = Array.prototype.slice.call(attribute.array);
                data.data.attributes[key] = {
                    itemSize: attribute.itemSize,
                    type: attribute.array.constructor.name,
                    array: array,
                    normalized: attribute.normalized
                };
            }
            var groups = this.groups;
            if (groups.length > 0) {
                data.data.groups = JSON.parse(JSON.stringify(groups));
            }
            var boundingSphere = this.boundingSphere;
            if (boundingSphere !== null) {
                data.data.boundingSphere = {
                    center: boundingSphere.center.toArray(null, null),
                    radius: boundingSphere.radius
                };
            }
            return data;
        }
        clone() {
            /*
             // Handle primitives
          
             var parameters = this.parameters;
          
             if ( parameters !== undefined ) {
          
             var values = [];
          
             for ( var key in parameters ) {
          
             values.push( parameters[ key ] );
          
             }
          
             var geometry = Object.create( this.constructor.prototype );
             this.constructor.apply( geometry, values );
             return geometry;
          
             }
          
             return new this.constructor().copy( this );
             */
            return new BufferGeometry().copy(this);
        }
        copy(source) {
            var name, i, l;
            // reset
            this.index = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.groups = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            // name
            this.name = source.name;
            // index
            var index = source.index;
            if (index !== null) {
                this.setIndex(index.clone());
            }
            // attributes
            var attributes = source.attributes;
            for (name in attributes) {
                var attribute = attributes[name];
                this.addAttribute(name, attribute.clone());
            }
            // morph attributes
            var morphAttributes = source.morphAttributes;
            for (name in morphAttributes) {
                var array = [];
                var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes
                for (i = 0, l = morphAttribute.length; i < l; i++) {
                    array.push(morphAttribute[i].clone());
                }
                this.morphAttributes[name] = array;
            }
            // groups
            var groups = source.groups;
            for (i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                this.addGroup(group.start, group.count, group.materialIndex);
            }
            // bounding box
            var boundingBox = source.boundingBox;
            if (boundingBox !== null) {
                this.boundingBox = boundingBox.clone();
            }
            // bounding sphere
            var boundingSphere = source.boundingSphere;
            if (boundingSphere !== null) {
                this.boundingSphere = boundingSphere.clone();
            }
            // draw range
            this.drawRange.start = source.drawRange.start;
            this.drawRange.count = source.drawRange.count;
            return this;
        }
        dispose() {
            this.dispatchEvent({ type: 'dispose' });
        }
    }
    THREE.BufferGeometry = BufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Clock {
        constructor(autoStart) {
            this.startTime = 0;
            this.oldTime = 0;
            this.elapsedTime = 0;
            this.running = false;
        }
        start() {
            this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
            this.oldTime = this.startTime;
            this.elapsedTime = 0;
            this.running = true;
        }
        stop() {
            this.getElapsedTime();
            this.running = false;
            this.autoStart = false;
        }
        getElapsedTime() {
            this.getDelta();
            return this.elapsedTime;
        }
        getDelta() {
            var diff = 0;
            if (this.autoStart && !this.running) {
                this.start();
                return 0;
            }
            if (this.running) {
                var newTime = (typeof performance === 'undefined' ? Date : performance).now();
                diff = (newTime - this.oldTime) / 1000;
                this.oldTime = newTime;
                this.elapsedTime += diff;
            }
            return diff;
        }
    }
    THREE.Clock = Clock;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class DirectGeometry {
        constructor() {
            this.vertices = [];
            this.normals = [];
            this.colors = [];
            this.uvs = [];
            this.uvs2 = [];
            this.groups = [];
            this.morphTargets = {};
            this.skinWeights = [];
            this.skinIndices = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.verticesNeedUpdate = false;
            this.normalsNeedUpdate = false;
            this.colorsNeedUpdate = false;
            this.uvsNeedUpdate = false;
            this.groupsNeedUpdate = false;
        }
        computeGroups(geometry) {
            var group;
            var groups = [];
            var materialIndex = undefined;
            var faces = geometry.faces;
            for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                // materials
                if (face.materialIndex !== materialIndex) {
                    materialIndex = face.materialIndex;
                    if (group !== undefined) {
                        group.count = (i * 3) - group.start;
                        groups.push(group);
                    }
                    group = {
                        start: i * 3,
                        materialIndex: materialIndex
                    };
                }
            }
            if (group !== undefined) {
                group.count = (i * 3) - group.start;
                groups.push(group);
            }
            this.groups = groups;
        }
        fromGeometry(geometry) {
            var faces = geometry.faces;
            var vertices = geometry.vertices;
            var faceVertexUvs = geometry.faceVertexUvs;
            var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
            var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
            // morphs
            var morphTargets = geometry.morphTargets;
            var morphTargetsLength = morphTargets.length;
            var morphTargetsPosition;
            if (morphTargetsLength > 0) {
                morphTargetsPosition = [];
                for (var i = 0; i < morphTargetsLength; i++) {
                    morphTargetsPosition[i] = [];
                }
                this.morphTargets.position = morphTargetsPosition;
            }
            var morphNormals = geometry.morphNormals;
            var morphNormalsLength = morphNormals.length;
            var morphTargetsNormal;
            if (morphNormalsLength > 0) {
                morphTargetsNormal = [];
                for (var i = 0; i < morphNormalsLength; i++) {
                    morphTargetsNormal[i] = [];
                }
                this.morphTargets.normal = morphTargetsNormal;
            }
            // skins
            var skinIndices = geometry.skinIndices;
            var skinWeights = geometry.skinWeights;
            var hasSkinIndices = skinIndices.length === vertices.length;
            var hasSkinWeights = skinWeights.length === vertices.length;
            //
            for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
                }
                else {
                    var normal = face.normal;
                    this.normals.push(normal, normal, normal);
                }
                var vertexColors = face.vertexColors;
                if (vertexColors.length === 3) {
                    this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
                }
                else {
                    var color = face.color;
                    this.colors.push(color, color, color);
                }
                if (hasFaceVertexUv === true) {
                    var vertexUvs = faceVertexUvs[0][i];
                    if (vertexUvs !== undefined) {
                        this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                    }
                    else {
                        console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
                        this.uvs.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
                    }
                }
                if (hasFaceVertexUv2 === true) {
                    var vertexUvs = faceVertexUvs[1][i];
                    if (vertexUvs !== undefined) {
                        this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                    }
                    else {
                        console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
                        this.uvs2.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
                    }
                }
                // morphs
                for (var j = 0; j < morphTargetsLength; j++) {
                    var morphTarget = morphTargets[j].vertices;
                    morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
                }
                for (var j = 0; j < morphNormalsLength; j++) {
                    var morphNormal = morphNormals[j].vertexNormals[i];
                    morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
                }
                // skins
                if (hasSkinIndices) {
                    this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
                }
                if (hasSkinWeights) {
                    this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
                }
            }
            this.computeGroups(geometry);
            this.verticesNeedUpdate = geometry.verticesNeedUpdate;
            this.normalsNeedUpdate = geometry.normalsNeedUpdate;
            this.colorsNeedUpdate = geometry.colorsNeedUpdate;
            this.uvsNeedUpdate = geometry.uvsNeedUpdate;
            this.groupsNeedUpdate = geometry.groupsNeedUpdate;
            return this;
        }
    }
    THREE.DirectGeometry = DirectGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Face3 {
        constructor(a, b, c, normal, color, materialIndex) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.normal = (normal && normal.isVector3) ? normal : new THREE.Vector3(null, null, null);
            this.vertexNormals = Array.isArray(normal) ? normal : [];
            this.color = (color && color.isColor) ? color : new THREE.Color(null, null, null);
            this.vertexColors = Array.isArray(color) ? color : [];
            this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
        }
        clone() {
            var face3 = new Face3(null, null, null, null, null, null);
            face3.copy(this);
            return face3;
        }
        copy(source) {
            this.a = source.a;
            this.b = source.b;
            this.c = source.c;
            this.normal.copy(source.normal);
            this.color.copy(source.color);
            this.materialIndex = source.materialIndex;
            for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
                this.vertexNormals[i] = source.vertexNormals[i].clone();
            }
            for (var i = 0, il = source.vertexColors.length; i < il; i++) {
                this.vertexColors[i] = source.vertexColors[i].clone();
            }
            return this;
        }
    }
    THREE.Face3 = Face3;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Geometry extends THREE.EventDispatcher {
        constructor() {
            //Object.defineProperty(this, 'id', { value: geometryId += 2 });
            super();
            this.id = 0;
            this.elementsNeedUpdate = false;
            this.verticesNeedUpdate = false;
            this.uvsNeedUpdate = false;
            this.normalsNeedUpdate = false;
            this.colorsNeedUpdate = false;
            this.lineDistancesNeedUpdate = false;
            this.groupsNeedUpdate = false;
            //Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
            // constructor: Geometry,
            this.isGeometry = true;
            Geometry.geometryId += 2;
            this.id = Geometry.geometryId;
            this.uuid = THREE._Math.generateUUID();
            this.name = '';
            this.type = 'Geometry';
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [[]];
            this.morphTargets = [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            // update flags
            this.elementsNeedUpdate = false;
            this.verticesNeedUpdate = false;
            this.uvsNeedUpdate = false;
            this.normalsNeedUpdate = false;
            this.colorsNeedUpdate = false;
            this.lineDistancesNeedUpdate = false;
            this.groupsNeedUpdate = false;
        }
        applyMatrix(matrix) {
            var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
            for (var i = 0, il = this.vertices.length; i < il; i++) {
                var vertex = this.vertices[i];
                vertex.applyMatrix4(matrix);
            }
            for (var i = 0, il = this.faces.length; i < il; i++) {
                var face = this.faces[i];
                face.normal.applyMatrix3(normalMatrix).normalize();
                for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                    face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
                }
            }
            if (this.boundingBox !== null) {
                this.computeBoundingBox();
            }
            if (this.boundingSphere !== null) {
                this.computeBoundingSphere();
            }
            this.verticesNeedUpdate = true;
            this.normalsNeedUpdate = true;
            return this;
        }
        rotateX(angle) {
            // rotate geometry around world x-axis
            //TODO:
            var m1 = new THREE.Matrix4();
            m1.makeRotationX(angle);
            this.applyMatrix(m1);
            return this;
        }
        rotateY(angle) {
            // rotate geometry around world y-axis
            //TODO:
            var m1 = new THREE.Matrix4();
            m1.makeRotationY(angle);
            this.applyMatrix(m1);
            return this;
        }
        rotateZ(angle) {
            // rotate geometry around world z-axis
            //TODO:
            var m1 = new THREE.Matrix4();
            m1.makeRotationZ(angle);
            this.applyMatrix(m1);
            return this;
        }
        translate(x, y, z) {
            // translate geometry
            //TODO:
            var m1 = new THREE.Matrix4();
            m1.makeTranslation(x, y, z);
            this.applyMatrix(m1);
            return this;
        }
        scale(x, y, z) {
            // scale geometry
            //TODO:
            var m1 = new THREE.Matrix4();
            m1.makeScale(x, y, z);
            this.applyMatrix(m1);
            return this;
        }
        lookAt(vector) {
            //TODO:
            var obj = new THREE.Object3D();
            obj.lookAt(vector);
            obj.updateMatrix();
            this.applyMatrix(obj.matrix);
        }
        fromBufferGeometry(geometry) {
            var scope = this;
            var indices = geometry.index !== null ? geometry.index.array : undefined;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;
            var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
            var colors = attributes.color !== undefined ? attributes.color.array : undefined;
            var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
            var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
            if (uvs2 !== undefined)
                this.faceVertexUvs[1] = [];
            var tempNormals = [];
            var tempUVs = [];
            var tempUVs2 = [];
            for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
                scope.vertices.push(new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]));
                if (normals !== undefined) {
                    tempNormals.push(new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]));
                }
                if (colors !== undefined) {
                    scope.colors.push(new THREE.Color(colors[i], colors[i + 1], colors[i + 2]));
                }
                if (uvs !== undefined) {
                    tempUVs.push(new THREE.Vector2(uvs[j], uvs[j + 1]));
                }
                if (uvs2 !== undefined) {
                    tempUVs2.push(new THREE.Vector2(uvs2[j], uvs2[j + 1]));
                }
            }
            function addFace(a, b, c, materialIndex) {
                var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
                var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];
                var face = new THREE.Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
                scope.faces.push(face);
                if (uvs !== undefined) {
                    scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);
                }
                if (uvs2 !== undefined) {
                    scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);
                }
            }
            var groups = geometry.groups;
            if (groups.length > 0) {
                for (var i = 0; i < groups.length; i++) {
                    var group = groups[i];
                    var start = group.start;
                    var count = group.count;
                    for (var j = start, jl = start + count; j < jl; j += 3) {
                        if (indices !== undefined) {
                            addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
                        }
                        else {
                            addFace(j, j + 1, j + 2, group.materialIndex);
                        }
                    }
                }
            }
            else {
                if (indices !== undefined) {
                    for (var i = 0; i < indices.length; i += 3) {
                        addFace(indices[i], indices[i + 1], indices[i + 2]);
                    }
                }
                else {
                    for (var i = 0; i < positions.length / 3; i += 3) {
                        addFace(i, i + 1, i + 2);
                    }
                }
            }
            this.computeFaceNormals();
            if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
            }
            if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
            }
            return this;
        }
        center() {
            //TODO:
            var offset = new THREE.Vector3();
            this.computeBoundingBox();
            this.boundingBox.getCenter(offset).negate();
            this.translate(offset.x, offset.y, offset.z);
            return this;
        }
        normalize() {
            this.computeBoundingSphere();
            var center = this.boundingSphere.center;
            var radius = this.boundingSphere.radius;
            var s = radius === 0 ? 1 : 1.0 / radius;
            var matrix = new THREE.Matrix4();
            matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
            this.applyMatrix(matrix);
            return this;
        }
        computeFaceNormals() {
            //TODO:
            var cb = new THREE.Vector3(), ab = new THREE.Vector3();
            for (var f = 0, fl = this.faces.length; f < fl; f++) {
                var face = this.faces[f];
                var vA = this.vertices[face.a];
                var vB = this.vertices[face.b];
                var vC = this.vertices[face.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                cb.normalize();
                face.normal.copy(cb);
            }
        }
        computeVertexNormals(areaWeighted) {
            if (areaWeighted === undefined)
                areaWeighted = true;
            var v, vl, f, fl, face, vertices;
            vertices = new Array(this.vertices.length);
            for (v = 0, vl = this.vertices.length; v < vl; v++) {
                vertices[v] = new THREE.Vector3();
            }
            if (areaWeighted) {
                // vertex normals weighted by triangle areas
                // http://www.iquilezles.org/www/articles/normals/normals.htm
                var vA, vB, vC;
                var cb = new THREE.Vector3(), ab = new THREE.Vector3();
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    vA = this.vertices[face.a];
                    vB = this.vertices[face.b];
                    vC = this.vertices[face.c];
                    cb.subVectors(vC, vB);
                    ab.subVectors(vA, vB);
                    cb.cross(ab);
                    vertices[face.a].add(cb);
                    vertices[face.b].add(cb);
                    vertices[face.c].add(cb);
                }
            }
            else {
                this.computeFaceNormals();
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    vertices[face.a].add(face.normal);
                    vertices[face.b].add(face.normal);
                    vertices[face.c].add(face.normal);
                }
            }
            for (v = 0, vl = this.vertices.length; v < vl; v++) {
                vertices[v].normalize();
            }
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    vertexNormals[0].copy(vertices[face.a]);
                    vertexNormals[1].copy(vertices[face.b]);
                    vertexNormals[2].copy(vertices[face.c]);
                }
                else {
                    vertexNormals[0] = vertices[face.a].clone();
                    vertexNormals[1] = vertices[face.b].clone();
                    vertexNormals[2] = vertices[face.c].clone();
                }
            }
            if (this.faces.length > 0) {
                this.normalsNeedUpdate = true;
            }
        }
        computeFlatVertexNormals() {
            var f, fl, face;
            this.computeFaceNormals();
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    vertexNormals[0].copy(face.normal);
                    vertexNormals[1].copy(face.normal);
                    vertexNormals[2].copy(face.normal);
                }
                else {
                    vertexNormals[0] = face.normal.clone();
                    vertexNormals[1] = face.normal.clone();
                    vertexNormals[2] = face.normal.clone();
                }
            }
            if (this.faces.length > 0) {
                this.normalsNeedUpdate = true;
            }
        }
        computeMorphNormals() {
            var i, il, f, fl, face;
            // save original normals
            // - create temp variables on first access
            //   otherwise just copy (for faster repeated calls)
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                if (!face.__originalFaceNormal) {
                    face.__originalFaceNormal = face.normal.clone();
                }
                else {
                    face.__originalFaceNormal.copy(face.normal);
                }
                if (!face.__originalVertexNormals)
                    face.__originalVertexNormals = [];
                for (i = 0, il = face.vertexNormals.length; i < il; i++) {
                    if (!face.__originalVertexNormals[i]) {
                        face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
                    }
                    else {
                        face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
                    }
                }
            }
            // use temp geometry to compute face and vertex normals for each morph
            var tmpGeo = new Geometry();
            tmpGeo.faces = this.faces;
            for (i = 0, il = this.morphTargets.length; i < il; i++) {
                // create on first access
                if (!this.morphNormals[i]) {
                    this.morphNormals[i] = {};
                    this.morphNormals[i].faceNormals = [];
                    this.morphNormals[i].vertexNormals = [];
                    var dstNormalsFace = this.morphNormals[i].faceNormals;
                    var dstNormalsVertex = this.morphNormals[i].vertexNormals;
                    var faceNormal, vertexNormals;
                    for (f = 0, fl = this.faces.length; f < fl; f++) {
                        faceNormal = new THREE.Vector3();
                        vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };
                        dstNormalsFace.push(faceNormal);
                        dstNormalsVertex.push(vertexNormals);
                    }
                }
                var morphNormals = this.morphNormals[i];
                // set vertices to morph target
                tmpGeo.vertices = this.morphTargets[i].vertices;
                // compute morph normals
                tmpGeo.computeFaceNormals();
                tmpGeo.computeVertexNormals();
                // store morph normals
                var faceNormal, vertexNormals;
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    faceNormal = morphNormals.faceNormals[f];
                    vertexNormals = morphNormals.vertexNormals[f];
                    faceNormal.copy(face.normal);
                    vertexNormals.a.copy(face.vertexNormals[0]);
                    vertexNormals.b.copy(face.vertexNormals[1]);
                    vertexNormals.c.copy(face.vertexNormals[2]);
                }
            }
            // restore original normals
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                face.normal = face.__originalFaceNormal;
                face.vertexNormals = face.__originalVertexNormals;
            }
        }
        computeBoundingBox() {
            if (this.boundingBox === null) {
                this.boundingBox = new THREE.Box3();
            }
            this.boundingBox.setFromPoints(this.vertices);
        }
        computeBoundingSphere() {
            if (this.boundingSphere === null) {
                this.boundingSphere = new THREE.Sphere();
            }
            this.boundingSphere.setFromPoints(this.vertices);
        }
        merge(geometry, matrix, materialIndexOffset) {
            if (!(geometry && geometry.isGeometry)) {
                console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
                return;
            }
            var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0], colors1 = this.colors, colors2 = geometry.colors;
            if (materialIndexOffset === undefined)
                materialIndexOffset = 0;
            if (matrix !== undefined) {
                normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
            }
            // vertices
            for (var i = 0, il = vertices2.length; i < il; i++) {
                var vertex = vertices2[i];
                var vertexCopy = vertex.clone();
                if (matrix !== undefined)
                    vertexCopy.applyMatrix4(matrix);
                vertices1.push(vertexCopy);
            }
            // colors
            for (var i = 0, il = colors2.length; i < il; i++) {
                colors1.push(colors2[i].clone());
            }
            // faces
            for (i = 0, il = faces2.length; i < il; i++) {
                var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
                faceCopy = new THREE.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
                faceCopy.normal.copy(face.normal);
                if (normalMatrix !== undefined) {
                    faceCopy.normal.applyMatrix3(normalMatrix).normalize();
                }
                for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
                    normal = faceVertexNormals[j].clone();
                    if (normalMatrix !== undefined) {
                        normal.applyMatrix3(normalMatrix).normalize();
                    }
                    faceCopy.vertexNormals.push(normal);
                }
                faceCopy.color.copy(face.color);
                for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
                    color = faceVertexColors[j];
                    faceCopy.vertexColors.push(color.clone());
                }
                faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
                faces1.push(faceCopy);
            }
            // uvs
            for (i = 0, il = uvs2.length; i < il; i++) {
                var uv = uvs2[i], uvCopy = [];
                if (uv === undefined) {
                    continue;
                }
                for (var j = 0, jl = uv.length; j < jl; j++) {
                    uvCopy.push(uv[j].clone());
                }
                uvs1.push(uvCopy);
            }
        }
        mergeMesh(mesh) {
            if (!(mesh && mesh.isMesh)) {
                console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
                return;
            }
            if (mesh.matrixAutoUpdate)
                mesh.updateMatrix();
            this.merge(mesh.geometry, mesh.matrix);
        }
        /*
         * Checks for duplicate vertices with hashmap.
         * Duplicated vertices are removed
         * and faces' vertices are updated.
         */
        mergeVertices() {
            var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
            var unique = [], changes = [];
            var v, key;
            var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
            var precision = Math.pow(10, precisionPoints);
            var i, il, face;
            var indices, j, jl;
            for (i = 0, il = this.vertices.length; i < il; i++) {
                v = this.vertices[i];
                key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
                if (verticesMap[key] === undefined) {
                    verticesMap[key] = i;
                    unique.push(this.vertices[i]);
                    changes[i] = unique.length - 1;
                }
                else {
                    //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
                    changes[i] = changes[verticesMap[key]];
                }
            }
            // if faces are completely degenerate after merging vertices, we
            // have to remove them from the geometry.
            var faceIndicesToRemove = [];
            for (i = 0, il = this.faces.length; i < il; i++) {
                face = this.faces[i];
                face.a = changes[face.a];
                face.b = changes[face.b];
                face.c = changes[face.c];
                indices = [face.a, face.b, face.c];
                // if any duplicate vertices are found in a Face3
                // we have to remove the face as nothing can be saved
                for (var n = 0; n < 3; n++) {
                    if (indices[n] === indices[(n + 1) % 3]) {
                        faceIndicesToRemove.push(i);
                        break;
                    }
                }
            }
            for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
                var idx = faceIndicesToRemove[i];
                this.faces.splice(idx, 1);
                for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
                    this.faceVertexUvs[j].splice(idx, 1);
                }
            }
            // Use unique set of vertices
            var diff = this.vertices.length - unique.length;
            this.vertices = unique;
            return diff;
        }
        setFromPoints(points) {
            this.vertices = [];
            for (var i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                this.vertices.push(new THREE.Vector3(point.x, point.y, point.z || 0));
            }
            return this;
        }
        sortFacesByMaterialIndex() {
            var faces = this.faces;
            var length = faces.length;
            // tag faces
            for (var i = 0; i < length; i++) {
                faces[i]._id = i;
            }
            // sort faces
            function materialIndexSort(a, b) {
                return a.materialIndex - b.materialIndex;
            }
            faces.sort(materialIndexSort);
            // sort uvs
            var uvs1 = this.faceVertexUvs[0];
            var uvs2 = this.faceVertexUvs[1];
            var newUvs1, newUvs2;
            if (uvs1 && uvs1.length === length)
                newUvs1 = [];
            if (uvs2 && uvs2.length === length)
                newUvs2 = [];
            for (var i = 0; i < length; i++) {
                var id = faces[i]._id;
                if (newUvs1)
                    newUvs1.push(uvs1[id]);
                if (newUvs2)
                    newUvs2.push(uvs2[id]);
            }
            if (newUvs1)
                this.faceVertexUvs[0] = newUvs1;
            if (newUvs2)
                this.faceVertexUvs[1] = newUvs2;
        }
        toJSON() {
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Geometry',
                    generator: 'Geometry.toJSON'
                }
            };
            // standard Geometry serialization
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '')
                data.name = this.name;
            if (this.parameters !== undefined) {
                var parameters = this.parameters;
                for (var key in parameters) {
                    if (parameters[key] !== undefined)
                        data[key] = parameters[key];
                }
                return data;
            }
            var vertices = [];
            for (var i = 0; i < this.vertices.length; i++) {
                var vertex = this.vertices[i];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
            var faces = [];
            var normals = [];
            var normalsHash = {};
            var colors = [];
            var colorsHash = {};
            var uvs = [];
            var uvsHash = {};
            for (var i = 0; i < this.faces.length; i++) {
                var face = this.faces[i];
                var hasMaterial = true;
                var hasFaceUv = false; // deprecated
                var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
                var hasFaceNormal = face.normal.length() > 0;
                var hasFaceVertexNormal = face.vertexNormals.length > 0;
                var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
                var hasFaceVertexColor = face.vertexColors.length > 0;
                var faceType = 0;
                faceType = setBit(faceType, 0, 0); // isQuad
                faceType = setBit(faceType, 1, hasMaterial);
                faceType = setBit(faceType, 2, hasFaceUv);
                faceType = setBit(faceType, 3, hasFaceVertexUv);
                faceType = setBit(faceType, 4, hasFaceNormal);
                faceType = setBit(faceType, 5, hasFaceVertexNormal);
                faceType = setBit(faceType, 6, hasFaceColor);
                faceType = setBit(faceType, 7, hasFaceVertexColor);
                faces.push(faceType);
                faces.push(face.a, face.b, face.c);
                faces.push(face.materialIndex);
                if (hasFaceVertexUv) {
                    var faceVertexUvs = this.faceVertexUvs[0][i];
                    faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
                }
                if (hasFaceNormal) {
                    faces.push(getNormalIndex(face.normal));
                }
                if (hasFaceVertexNormal) {
                    var vertexNormals = face.vertexNormals;
                    faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
                }
                if (hasFaceColor) {
                    faces.push(getColorIndex(face.color));
                }
                if (hasFaceVertexColor) {
                    var vertexColors = face.vertexColors;
                    faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
                }
            }
            function setBit(value, position, enabled) {
                return enabled ? value | (1 << position) : value & (~(1 << position));
            }
            function getNormalIndex(normal) {
                var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
                if (normalsHash[hash] !== undefined) {
                    return normalsHash[hash];
                }
                normalsHash[hash] = normals.length / 3;
                normals.push(normal.x, normal.y, normal.z);
                return normalsHash[hash];
            }
            function getColorIndex(color) {
                var hash = color.r.toString() + color.g.toString() + color.b.toString();
                if (colorsHash[hash] !== undefined) {
                    return colorsHash[hash];
                }
                colorsHash[hash] = colors.length;
                colors.push(color.getHex());
                return colorsHash[hash];
            }
            function getUvIndex(uv) {
                var hash = uv.x.toString() + uv.y.toString();
                if (uvsHash[hash] !== undefined) {
                    return uvsHash[hash];
                }
                uvsHash[hash] = uvs.length / 2;
                uvs.push(uv.x, uv.y);
                return uvsHash[hash];
            }
            data.data = {};
            data.data.vertices = vertices;
            data.data.normals = normals;
            if (colors.length > 0)
                data.data.colors = colors;
            if (uvs.length > 0)
                data.data.uvs = [uvs]; // temporal backward compatibility
            data.data.faces = faces;
            return data;
        }
        clone() {
            /*
             // Handle primitives
       
             var parameters = this.parameters;
       
             if ( parameters !== undefined ) {
       
             var values = [];
       
             for ( var key in parameters ) {
       
             values.push( parameters[ key ] );
       
             }
       
             var geometry = Object.create( this.constructor.prototype );
             this.constructor.apply( geometry, values );
             return geometry;
       
             }
       
             return new this.constructor().copy( this );
             */
            return new Geometry().copy(this);
        }
        copy(source) {
            var i, il, j, jl, k, kl;
            // reset
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [[]];
            this.morphTargets = [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            // name
            this.name = source.name;
            // vertices
            var vertices = source.vertices;
            for (i = 0, il = vertices.length; i < il; i++) {
                this.vertices.push(vertices[i].clone());
            }
            // colors
            var colors = source.colors;
            for (i = 0, il = colors.length; i < il; i++) {
                this.colors.push(colors[i].clone());
            }
            // faces
            var faces = source.faces;
            for (i = 0, il = faces.length; i < il; i++) {
                this.faces.push(faces[i].clone());
            }
            // face vertex uvs
            for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
                var faceVertexUvs = source.faceVertexUvs[i];
                if (this.faceVertexUvs[i] === undefined) {
                    this.faceVertexUvs[i] = [];
                }
                for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
                    var uvs = faceVertexUvs[j], uvsCopy = [];
                    for (k = 0, kl = uvs.length; k < kl; k++) {
                        var uv = uvs[k];
                        uvsCopy.push(uv.clone());
                    }
                    this.faceVertexUvs[i].push(uvsCopy);
                }
            }
            // morph targets
            var morphTargets = source.morphTargets;
            for (i = 0, il = morphTargets.length; i < il; i++) {
                var morphTarget = {};
                morphTarget.name = morphTargets[i].name;
                // vertices
                if (morphTargets[i].vertices !== undefined) {
                    morphTarget.vertices = [];
                    for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
                        morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
                    }
                }
                // normals
                if (morphTargets[i].normals !== undefined) {
                    morphTarget.normals = [];
                    for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
                        morphTarget.normals.push(morphTargets[i].normals[j].clone());
                    }
                }
                this.morphTargets.push(morphTarget);
            }
            // morph normals
            var morphNormals = source.morphNormals;
            for (i = 0, il = morphNormals.length; i < il; i++) {
                var morphNormal = {};
                // vertex normals
                if (morphNormals[i].vertexNormals !== undefined) {
                    morphNormal.vertexNormals = [];
                    for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
                        var srcVertexNormal = morphNormals[i].vertexNormals[j];
                        var destVertexNormal = {};
                        destVertexNormal.a = srcVertexNormal.a.clone();
                        destVertexNormal.b = srcVertexNormal.b.clone();
                        destVertexNormal.c = srcVertexNormal.c.clone();
                        morphNormal.vertexNormals.push(destVertexNormal);
                    }
                }
                // face normals
                if (morphNormals[i].faceNormals !== undefined) {
                    morphNormal.faceNormals = [];
                    for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
                        morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
                    }
                }
                this.morphNormals.push(morphNormal);
            }
            // skin weights
            var skinWeights = source.skinWeights;
            for (i = 0, il = skinWeights.length; i < il; i++) {
                this.skinWeights.push(skinWeights[i].clone());
            }
            // skin indices
            var skinIndices = source.skinIndices;
            for (i = 0, il = skinIndices.length; i < il; i++) {
                this.skinIndices.push(skinIndices[i].clone());
            }
            // line distances
            var lineDistances = source.lineDistances;
            for (i = 0, il = lineDistances.length; i < il; i++) {
                this.lineDistances.push(lineDistances[i]);
            }
            // bounding box
            var boundingBox = source.boundingBox;
            if (boundingBox !== null) {
                this.boundingBox = boundingBox.clone();
            }
            // bounding sphere
            var boundingSphere = source.boundingSphere;
            if (boundingSphere !== null) {
                this.boundingSphere = boundingSphere.clone();
            }
            // update flags
            this.elementsNeedUpdate = source.elementsNeedUpdate;
            this.verticesNeedUpdate = source.verticesNeedUpdate;
            this.uvsNeedUpdate = source.uvsNeedUpdate;
            this.normalsNeedUpdate = source.normalsNeedUpdate;
            this.colorsNeedUpdate = source.colorsNeedUpdate;
            this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
            this.groupsNeedUpdate = source.groupsNeedUpdate;
            return this;
        }
        dispose() {
            this.dispatchEvent({ type: 'dispose' });
        }
    }
    Geometry.geometryId = 0; // Geometry uses even numbers as Id
    THREE.Geometry = Geometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class InstancedBufferAttribute extends THREE.BufferAttribute {
        constructor(array, itemSize, meshPerAttribute) {
            super(array, itemSize, meshPerAttribute);
            this.meshPerAttribute = meshPerAttribute || 1;
            this.isInstancedBufferAttribute = true;
        }
        copy(source) {
            super.copy(source);
            this.meshPerAttribute = source.meshPerAttribute;
            return this;
        }
    }
    THREE.InstancedBufferAttribute = InstancedBufferAttribute;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class InstancedBufferGeometry extends THREE.BufferGeometry {
        constructor() {
            super();
            this.type = 'InstancedBufferGeometry';
            this.maxInstancedCount = undefined;
            this.isInstancedBufferGeometry = true;
        }
        copy(source) {
            super.copy(source);
            this.maxInstancedCount = source.maxInstancedCount;
            return this;
        }
        clone() {
            var instanceGeometry = new InstancedBufferGeometry();
            instanceGeometry.copy(this);
            return instanceGeometry;
        }
    }
    THREE.InstancedBufferGeometry = InstancedBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class InterleavedBuffer {
        constructor(array, stride) {
            this.version = 0;
            this.array = array;
            this.stride = stride;
            this.count = array !== undefined ? array.length / stride : 0;
            this.dynamic = false;
            this.updateRange = { offset: 0, count: -1 };
            this.version = 0;
        }
        set needsUpdate(value) {
            if (value === true)
                this.version++;
        }
        onUploadCallback() { }
        setArray(array) {
            if (Array.isArray(array)) {
                throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
            }
            this.count = array !== undefined ? array.length / this.stride : 0;
            this.array = array;
            return this;
        }
        setDynamic(value) {
            this.dynamic = value;
            return this;
        }
        copy(source) {
            this.array = new source.array.constructor(source.array);
            this.count = source.count;
            this.stride = source.stride;
            this.dynamic = source.dynamic;
            return this;
        }
        copyAt(index1, attribute, index2) {
            index1 *= this.stride;
            index2 *= attribute.stride;
            for (var i = 0, l = this.stride; i < l; i++) {
                this.array[index1 + i] = attribute.array[index2 + i];
            }
            return this;
        }
        set(value, offset) {
            if (offset === undefined)
                offset = 0;
            this.array.set(value, offset);
            return this;
        }
        clone() {
            return new InterleavedBuffer().copy(this);
        }
        onUpload(callback) {
            this.onUploadCallback = callback;
            return this;
        }
    }
    THREE.InterleavedBuffer = InterleavedBuffer;
})(THREE || (THREE = {}));
/// <reference path="./InterleavedBuffer.ts" />
var THREE;
/// <reference path="./InterleavedBuffer.ts" />
(function (THREE) {
    class InstancedInterleavedBuffer extends THREE.InterleavedBuffer {
        constructor(array, stride, meshPerAttribute) {
            super(array, stride);
            this.meshPerAttribute = meshPerAttribute || 1;
            this.isInstancedInterleavedBuffer = true;
        }
        copy(source) {
            super.copy(source);
            this.meshPerAttribute = source.meshPerAttribute;
            return this;
        }
    }
    THREE.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class InterleavedBufferAttribute {
        constructor(interleavedBuffer, itemSize, offset, normalized) {
            this.isInterleavedBufferAttribute = true;
            this.data = interleavedBuffer;
            this.itemSize = itemSize;
            this.offset = offset;
            this.normalized = normalized === true;
        }
        get count() {
            return this.data.count;
        }
        get array() {
            return this.data.array;
        }
        setX(index, x) {
            this.data.array[index * this.data.stride + this.offset] = x;
            return this;
        }
        setY(index, y) {
            this.data.array[index * this.data.stride + this.offset + 1] = y;
            return this;
        }
        setZ(index, z) {
            this.data.array[index * this.data.stride + this.offset + 2] = z;
            return this;
        }
        setW(index, w) {
            this.data.array[index * this.data.stride + this.offset + 3] = w;
            return this;
        }
        getX(index) {
            return this.data.array[index * this.data.stride + this.offset];
        }
        getY(index) {
            return this.data.array[index * this.data.stride + this.offset + 1];
        }
        getZ(index) {
            return this.data.array[index * this.data.stride + this.offset + 2];
        }
        getW(index) {
            return this.data.array[index * this.data.stride + this.offset + 3];
        }
        setXY(index, x, y) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            return this;
        }
        setXYZ(index, x, y, z) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;
            return this;
        }
        setXYZW(index, x, y, z, w) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;
            this.data.array[index + 3] = w;
            return this;
        }
    }
    THREE.InterleavedBufferAttribute = InterleavedBufferAttribute;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Layers {
        constructor() {
            this.mask = 1 | 0;
        }
        set(channel) {
            this.mask = 1 << channel | 0;
        }
        enable(channel) {
            this.mask |= 1 << channel | 0;
        }
        toggle(channel) {
            this.mask ^= 1 << channel | 0;
        }
        disable(channel) {
            this.mask &= ~(1 << channel | 0);
        }
        test(layers) {
            return (this.mask & layers.mask) !== 0;
        }
    }
    THREE.Layers = Layers;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Params {
        constructor(Mesh, Line, LOD, Points, Sprite) {
            this.Mesh = Mesh || {};
            this.Line = Line || {};
            this.LOD = LOD || {};
            this.Points = Points || { threshold: 1 };
            this.Sprite = Sprite || {};
        }
        get PointCloud() {
            console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
            return;
        }
    }
    function ascSort(a, b) {
        return a.distance - b.distance;
    }
    function intersectObject(object, raycaster, intersects, recursive) {
        if (object.visible === false)
            return;
        object.raycast(raycaster, intersects);
        if (recursive === true) {
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                intersectObject(children[i], raycaster, intersects, true);
            }
        }
    }
    class Raycaster {
        constructor(origin, direction, near, far) {
            this.linePrecision = 1;
            this.ray = new THREE.Ray(origin, direction);
            // direction is assumed to be normalized (for accurate distance calculations)
            this.near = near || 0;
            this.far = far || Infinity;
            this.params = new Params();
        }
        set(origin, direction) {
            // direction is assumed to be normalized (for accurate distance calculations)
            this.ray.set(origin, direction);
        }
        setFromCamera(coords, camera) {
            if ((camera && camera.isPerspectiveCamera)) {
                this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            }
            else if ((camera && camera.isOrthographicCamera)) {
                this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
                this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            }
            else {
                console.error('THREE.Raycaster: Unsupported camera type.');
            }
        }
        intersectObject(object, recursive, optionalTarget) {
            var intersects = optionalTarget || [];
            intersectObject(object, this, intersects, recursive);
            intersects.sort(ascSort);
            return intersects;
        }
        intersectObjects(objects, recursive, optionalTarget) {
            var intersects = optionalTarget || [];
            if (Array.isArray(objects) === false) {
                console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
                return intersects;
            }
            for (var i = 0, l = objects.length; i < l; i++) {
                intersectObject(objects[i], this, intersects, recursive);
            }
            intersects.sort(ascSort);
            return intersects;
        }
    }
    THREE.Raycaster = Raycaster;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Uniform {
        constructor(value) {
            this.clone = function () {
                return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
            };
            if (typeof value === 'string') {
                console.warn('THREE.Uniform: Type parameter is no longer needed.');
                value = arguments[1];
            }
            this.value = value;
        }
    }
    THREE.Uniform = Uniform;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    THREE.Earcut = {
        triangulate: function (data, holeIndices, dim) {
            dim = dim || 2;
            var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
            if (!outerNode)
                return triangles;
            var minX, minY, maxX, maxY, x, y, invSize;
            if (hasHoles)
                outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
            // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
            if (data.length > 80 * dim) {
                minX = maxX = data[0];
                minY = maxY = data[1];
                for (var i = dim; i < outerLen; i += dim) {
                    x = data[i];
                    y = data[i + 1];
                    if (x < minX)
                        minX = x;
                    if (y < minY)
                        minY = y;
                    if (x > maxX)
                        maxX = x;
                    if (y > maxY)
                        maxY = y;
                }
                // minX, minY and invSize are later used to transform coords into integers for z-order calculation
                invSize = Math.max(maxX - minX, maxY - minY);
                invSize = invSize !== 0 ? 1 / invSize : 0;
            }
            earcutLinked(outerNode, triangles, dim, minX, minY, invSize, null);
            return triangles;
        }
    };
    // create a circular doubly linked list from polygon points in the specified winding order
    function linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === (signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim)
                last = insertNode(i, data[i], data[i + 1], last);
        }
        else {
            for (i = end - dim; i >= start; i -= dim)
                last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals(last, last.next)) {
            removeNode(last);
            last = last.next;
        }
        return last;
    }
    // eliminate colinear or duplicate points
    function filterPoints(start, end) {
        if (!start)
            return start;
        if (!end)
            end = start;
        var p = start, again;
        do {
            again = false;
            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next)
                    break;
                again = true;
            }
            else {
                p = p.next;
            }
        } while (again || p !== end);
        return end;
    }
    // main ear slicing loop which triangulates a polygon (given as a linked list)
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
            return;
        // interlink polygon nodes in z-order
        if (!pass && invSize)
            indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        // iterate through ears, slicing them one by one
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;
            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                // cut off the triangle
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
                removeNode(ear);
                // skipping the next vertice leads to less sliver triangles
                ear = next.next;
                stop = next.next;
                continue;
            }
            ear = next;
            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) {
                    earcutLinked(filterPoints(ear, null), triangles, dim, minX, minY, invSize, 1);
                    // if this didn't work, try curing all small self-intersections locally
                }
                else if (pass === 1) {
                    ear = cureLocalIntersections(ear, triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                    // as a last resort, try splitting the remaining polygon into two
                }
                else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }
                break;
            }
        }
    }
    // check whether a polygon node forms a valid ear with adjacent nodes
    function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
            return false; // reflex, can't be an ear
        // now make sure we don't have other points inside the potential ear
        var p = ear.next.next;
        while (p !== ear.prev) {
            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.next;
        }
        return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
            return false; // reflex, can't be an ear
        // triangle bbox; min & max are calculated like this for speed
        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
        // z-order range for the current triangle bbox;
        var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
        // first look for points inside the triangle in increasing z-order
        var p = ear.nextZ;
        while (p && p.z <= maxZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0)
                return false;
            p = p.nextZ;
        }
        // then look for points in decreasing z-order
        p = ear.prevZ;
        while (p && p.z >= minZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0)
                return false;
            p = p.prevZ;
        }
        return true;
    }
    // go through all polygon nodes and cure small local self-intersections
    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev, b = p.next.next;
            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);
                // remove two nodes involved
                removeNode(p);
                removeNode(p.next);
                p = start = b;
            }
            p = p.next;
        } while (p !== start);
        return p;
    }
    // try splitting polygon into two and triangulate them independently
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    var c = splitPolygon(a, b);
                    // filter colinear points around the cuts
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);
                    // run earcut on each half
                    earcutLinked(a, triangles, dim, minX, minY, invSize, null);
                    earcutLinked(c, triangles, dim, minX, minY, invSize, null);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }
    // link every hole into the outer loop, producing a single-ring polygon without holes
    function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next)
                list.steiner = true;
            queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        // process holes from left to right
        for (i = 0; i < queue.length; i++) {
            eliminateHole(queue[i], outerNode);
            outerNode = filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
    }
    function compareX(a, b) {
        return a.x - b.x;
    }
    // find a bridge between vertices that connects hole with an outer ring and and link it
    function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = splitPolygon(outerNode, hole);
            filterPoints(b, b.next);
        }
    }
    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y)
                            return p;
                        if (hy === p.next.y)
                            return p.next;
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);
        if (!m)
            return null;
        if (hx === qx)
            return m.prev; // hole touches outer segment; pick lower endpoint
        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
        p = m.next;
        while (p !== stop) {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }
            p = p.next;
        }
        return m;
    }
    // interlink polygon nodes in z-order
    function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
            if (p.z === null)
                p.z = zOrder(p.x, p.y, minX, minY, invSize);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
    }
    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;
            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q)
                        break;
                }
                qSize = inSize;
                while (pSize > 0 || (qSize > 0 && q)) {
                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    }
                    else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
                    if (tail)
                        tail.nextZ = e;
                    else
                        list = e;
                    e.prevZ = tail;
                    tail = e;
                }
                p = q;
            }
            tail.nextZ = null;
            inSize *= 2;
        } while (numMerges > 1);
        return list;
    }
    // z-order of a point given coords and inverse of the longer side of data bbox
    function zOrder(x, y, minX, minY, invSize) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;
        return x | (y << 1);
    }
    // find the leftmost node of a polygon ring
    function getLeftmost(start) {
        var p = start, leftmost = start;
        do {
            if (p.x < leftmost.x)
                leftmost = p;
            p = p.next;
        } while (p !== start);
        return leftmost;
    }
    // check if a point lies within a convex triangle
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
            locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
    }
    // signed area of a triangle
    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    // check if two points are equal
    function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }
    // check if two segments intersect
    function intersects(p1, q1, p2, q2) {
        if ((equals(p1, q1) && equals(p2, q2)) ||
            (equals(p1, q2) && equals(p2, q1)))
            return true;
        return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
            area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
    }
    // check if a polygon diagonal intersects any polygon segments
    function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) {
                return true;
            }
            p = p.next;
        } while (p !== a);
        return false;
    }
    // check if a polygon diagonal is locally inside the polygon
    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ?
            area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
            area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    // check if the middle point of a polygon diagonal is inside the polygon
    function middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)) {
                inside = !inside;
            }
            p = p.next;
        } while (p !== a);
        return inside;
    }
    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    function splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
    }
    // create a node and optionally link it with previous one (in a circular doubly linked list)
    function insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
        if (!last) {
            p.prev = p;
            p.next = p;
        }
        else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }
    function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
            p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
            p.nextZ.prevZ = p.prevZ;
    }
    function Node(i, x, y) {
        // vertice index in coordinates array
        this.i = i;
        // vertex coordinates
        this.x = x;
        this.y = y;
        // previous and next vertice nodes in a polygon ring
        this.prev = null;
        this.next = null;
        // z-order curve value
        this.z = null;
        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;
        // indicates whether this is a steiner point
        this.steiner = false;
    }
    function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class ShapeUtils {
        // calculate area of the contour polygon
        static area(contour) {
            var n = contour.length;
            var a = 0.0;
            for (var p = n - 1, q = 0; q < n; p = q++) {
                a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
            }
            return a * 0.5;
        }
        static isClockWise(pts) {
            return ShapeUtils.area(pts) < 0;
        }
        static triangulateShape(contour, holes) {
            var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
            var holeIndices = []; // array of hole indices
            var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
            removeDupEndPts(contour);
            addContour(vertices, contour);
            //
            var holeIndex = contour.length;
            holes.forEach(removeDupEndPts);
            for (var i = 0; i < holes.length; i++) {
                holeIndices.push(holeIndex);
                holeIndex += holes[i].length;
                addContour(vertices, holes[i]);
            }
            //
            var triangles = THREE.Earcut.triangulate(vertices, holeIndices, null);
            //
            for (var i = 0; i < triangles.length; i += 3) {
                faces.push(triangles.slice(i, i + 3));
            }
            return faces;
        }
    }
    THREE.ShapeUtils = ShapeUtils;
    ;
    function removeDupEndPts(points) {
        var l = points.length;
        if (l > 2 && points[l - 1].equals(points[0])) {
            points.pop();
        }
    }
    function addContour(vertices, contour) {
        for (var i = 0; i < contour.length; i++) {
            vertices.push(contour[i].x);
            vertices.push(contour[i].y);
        }
    }
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Curve {
        constructor() {
        }
        getPoint(t, optionalTarget) {
            console.warn('THREE.Curve: .getPoint() not implemented.');
            return null;
        }
        // Get point at relative position in curve according to arc length
        // - u [0 .. 1]
        getPointAt(u, optionalTarget) {
            var t = this.getUtoTmapping(u, null);
            return this.getPoint(t, optionalTarget);
        }
        // Get sequence of points using getPoint( t )
        getPoints(divisions) {
            if (divisions === undefined)
                divisions = 5;
            var points = [];
            for (var d = 0; d <= divisions; d++) {
                points.push(this.getPoint(d / divisions, null));
            }
            return points;
        }
        // Get sequence of points using getPointAt( u )
        getSpacedPoints(divisions) {
            if (divisions === undefined)
                divisions = 5;
            var points = [];
            for (var d = 0; d <= divisions; d++) {
                points.push(this.getPointAt(d / divisions, null));
            }
            return points;
        }
        // Get total curve arc length
        getLength() {
            var lengths = this.getLengths(null);
            return lengths[lengths.length - 1];
        }
        // Get list of cumulative segment lengths
        getLengths(divisions) {
            if (divisions === undefined)
                divisions = this.arcLengthDivisions;
            if (this.cacheArcLengths &&
                (this.cacheArcLengths.length === divisions + 1) &&
                !this.needsUpdate) {
                return this.cacheArcLengths;
            }
            this.needsUpdate = false;
            var cache = [];
            var current, last = this.getPoint(0, null);
            var p, sum = 0;
            cache.push(0);
            for (p = 1; p <= divisions; p++) {
                current = this.getPoint(p / divisions, null);
                sum += current.distanceTo(last);
                cache.push(sum);
                last = current;
            }
            this.cacheArcLengths = cache;
            return cache; // { sums: cache, sum: sum }; Sum is in the last element.
        }
        updateArcLengths() {
            this.needsUpdate = true;
            this.getLengths(null);
        }
        // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
        getUtoTmapping(u, distance) {
            var arcLengths = this.getLengths(null);
            var i = 0, il = arcLengths.length;
            var targetArcLength; // The targeted u distance value to get
            if (distance) {
                targetArcLength = distance;
            }
            else {
                targetArcLength = u * arcLengths[il - 1];
            }
            // binary search for the index with largest value smaller than target u distance
            var low = 0, high = il - 1, comparison;
            while (low <= high) {
                i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
                comparison = arcLengths[i] - targetArcLength;
                if (comparison < 0) {
                    low = i + 1;
                }
                else if (comparison > 0) {
                    high = i - 1;
                }
                else {
                    high = i;
                    break;
                    // DONE
                }
            }
            i = high;
            if (arcLengths[i] === targetArcLength) {
                return i / (il - 1);
            }
            // we could get finer grain at lengths, or use simple interpolation between two points
            var lengthBefore = arcLengths[i];
            var lengthAfter = arcLengths[i + 1];
            var segmentLength = lengthAfter - lengthBefore;
            // determine where we are between the 'before' and 'after' points
            var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
            // add that fractional amount to t
            var t = (i + segmentFraction) / (il - 1);
            return t;
        }
        // Returns a unit vector tangent at t
        // In case any sub curve does not implement its tangent derivation,
        // 2 points a small delta apart will be used to find its gradient
        // which seems to give a reasonable approximation
        getTangent(t) {
            var delta = 0.0001;
            var t1 = t - delta;
            var t2 = t + delta;
            // Capping in case of danger
            if (t1 < 0)
                t1 = 0;
            if (t2 > 1)
                t2 = 1;
            var pt1 = this.getPoint(t1, null);
            var pt2 = this.getPoint(t2, null);
            var vec = pt2.clone().sub(pt1);
            return vec.normalize();
        }
        getTangentAt(u) {
            var t = this.getUtoTmapping(u, null);
            return this.getTangent(t);
        }
        computeFrenetFrames(segments, closed) {
            // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
            var normal = new THREE.Vector3();
            var tangents = [];
            var normals = [];
            var binormals = [];
            var vec = new THREE.Vector3();
            var mat = new THREE.Matrix4();
            var i, u, theta;
            // compute the tangent vectors for each segment on the curve
            for (i = 0; i <= segments; i++) {
                u = i / segments;
                tangents[i] = this.getTangentAt(u);
                tangents[i].normalize();
            }
            // select an initial normal vector perpendicular to the first tangent vector,
            // and in the direction of the minimum tangent xyz component
            normals[0] = new THREE.Vector3();
            binormals[0] = new THREE.Vector3();
            var min = Number.MAX_VALUE;
            var tx = Math.abs(tangents[0].x);
            var ty = Math.abs(tangents[0].y);
            var tz = Math.abs(tangents[0].z);
            if (tx <= min) {
                min = tx;
                normal.set(1, 0, 0);
            }
            if (ty <= min) {
                min = ty;
                normal.set(0, 1, 0);
            }
            if (tz <= min) {
                normal.set(0, 0, 1);
            }
            vec.crossVectors(tangents[0], normal).normalize();
            normals[0].crossVectors(tangents[0], vec);
            binormals[0].crossVectors(tangents[0], normals[0]);
            // compute the slowly-varying normal and binormal vectors for each segment on the curve
            for (i = 1; i <= segments; i++) {
                normals[i] = normals[i - 1].clone();
                binormals[i] = binormals[i - 1].clone();
                vec.crossVectors(tangents[i - 1], tangents[i]);
                if (vec.length() > Number.EPSILON) {
                    vec.normalize();
                    theta = Math.acos(THREE._Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors
                    normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
                }
                binormals[i].crossVectors(tangents[i], normals[i]);
            }
            // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
            if (closed === true) {
                theta = Math.acos(THREE._Math.clamp(normals[0].dot(normals[segments]), -1, 1));
                theta /= segments;
                if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
                    theta = -theta;
                }
                for (i = 1; i <= segments; i++) {
                    // twist a little...
                    normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                    binormals[i].crossVectors(tangents[i], normals[i]);
                }
            }
            return {
                tangents: tangents,
                normals: normals,
                binormals: binormals
            };
        }
        clone() {
            var curve = new Curve();
            curve.copy(this);
            return curve;
        }
        copy(source) {
            this.arcLengthDivisions = source.arcLengthDivisions;
            return this;
        }
        toJSON() {
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Curve',
                    generator: 'Curve.toJSON'
                }
            };
            data.arcLengthDivisions = this.arcLengthDivisions;
            data.type = this.type;
            return data;
        }
        fromJSON(json) {
            this.arcLengthDivisions = json.arcLengthDivisions;
            return this;
        }
    }
    THREE.Curve = Curve;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class CurvePath extends THREE.Curve {
        constructor() {
            super();
            this.type = 'CurvePath';
            this.curves = [];
            this.autoClose = false; // Automatically closes the path
        }
        add(curve) {
            this.curves.push(curve);
        }
        closePath() {
            // Add a line curve if start and end of lines are not connected
            var startPoint = this.curves[0].getPoint(0);
            var endPoint = this.curves[this.curves.length - 1].getPoint(1);
            if (!startPoint.equals(endPoint)) {
                this.curves.push(new THREE.Curves['LineCurve'](endPoint, startPoint));
            }
        }
        // To get accurate point with reference to
        // entire path distance at time t,
        // following has to be done:
        // 1. Length of each sub path have to be known
        // 2. Locate and identify type of curve
        // 3. Get t for the curve
        // 4. Return curve.getPointAt(t')
        getPoint(t) {
            var d = t * this.getLength();
            var curveLengths = this.getCurveLengths();
            var i = 0;
            // To think about boundaries points.
            while (i < curveLengths.length) {
                if (curveLengths[i] >= d) {
                    var diff = curveLengths[i] - d;
                    var curve = this.curves[i];
                    var segmentLength = curve.getLength();
                    var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                    return curve.getPointAt(u);
                }
                i++;
            }
            return null;
            // loop where sum != 0, sum > d , sum+1 <d
        }
        // We cannot use the default THREE.Curve getPoint() with getLength() because in
        // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
        // getPoint() depends on getLength
        getLength() {
            var lens = this.getCurveLengths();
            return lens[lens.length - 1];
        }
        // cacheLengths must be recalculated.
        updateArcLengths() {
            this.needsUpdate = true;
            this.cacheLengths = null;
            this.getCurveLengths();
        }
        // Compute lengths and cache them
        // We cannot overwrite getLengths() because UtoT mapping uses it.
        getCurveLengths() {
            // We use cache values if curves and cache array are same length
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
                return this.cacheLengths;
            }
            // Get length of sub-curve
            // Push sums into cached array
            var lengths = [], sums = 0;
            for (var i = 0, l = this.curves.length; i < l; i++) {
                sums += this.curves[i].getLength();
                lengths.push(sums);
            }
            this.cacheLengths = lengths;
            return lengths;
        }
        getSpacedPoints(divisions) {
            if (divisions === undefined)
                divisions = 40;
            var points = [];
            for (var i = 0; i <= divisions; i++) {
                points.push(this.getPoint(i / divisions));
            }
            if (this.autoClose) {
                points.push(points[0]);
            }
            return points;
        }
        getPoints(divisions) {
            divisions = divisions || 12;
            var points = [], last;
            for (var i = 0, curves = this.curves; i < curves.length; i++) {
                var curve = curves[i];
                var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
                    : (curve && curve.isLineCurve) ? 1
                        : (curve && curve.isSplineCurve) ? divisions * curve.points.length
                            : divisions;
                var pts = curve.getPoints(resolution);
                for (var j = 0; j < pts.length; j++) {
                    var point = pts[j];
                    if (last && last.equals(point))
                        continue; // ensures no consecutive points are duplicates
                    points.push(point);
                    last = point;
                }
            }
            if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
                points.push(points[0]);
            }
            return points;
        }
        copy(source) {
            THREE.Curve.prototype.copy.call(this, source);
            this.curves = [];
            for (var i = 0, l = source.curves.length; i < l; i++) {
                var curve = source.curves[i];
                this.curves.push(curve.clone());
            }
            this.autoClose = source.autoClose;
            return this;
        }
        toJSON() {
            var data = THREE.Curve.prototype.toJSON.call(this);
            data.autoClose = this.autoClose;
            data.curves = [];
            for (var i = 0, l = this.curves.length; i < l; i++) {
                var curve = this.curves[i];
                data.curves.push(curve.toJSON());
            }
            return data;
        }
        fromJSON(json) {
            THREE.Curve.prototype.fromJSON.call(this, json);
            this.autoClose = json.autoClose;
            this.curves = [];
            for (var i = 0, l = json.curves.length; i < l; i++) {
                var curve = json.curves[i];
                this.curves.push(new THREE.Curves[curve.type]().fromJSON(curve));
            }
            return this;
        }
    }
    THREE.CurvePath = CurvePath;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Font {
        constructor(data) {
            this.type = 'Font';
            this.data = data;
            this.isFont = true;
        }
        generateShapes(text, size, divisions) {
            if (size === undefined)
                size = 100;
            if (divisions === undefined)
                divisions = 4;
            var shapes = [];
            var paths = createPaths(text, size, divisions, this.data);
            for (var p = 0, pl = paths.length; p < pl; p++) {
                Array.prototype.push.apply(shapes, paths[p].toShapes());
            }
            return shapes;
        }
    }
    THREE.Font = Font;
    function createPaths(text, size, divisions, data) {
        var chars = String(text).split('');
        var scale = size / data.resolution;
        var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
        var paths = [];
        var offsetX = 0, offsetY = 0;
        for (var i = 0; i < chars.length; i++) {
            var char = chars[i];
            if (char === '\n') {
                offsetX = 0;
                offsetY -= line_height;
            }
            else {
                var ret = createPath(char, divisions, scale, offsetX, offsetY, data);
                offsetX += ret.offsetX;
                paths.push(ret.path);
            }
        }
        return paths;
    }
    THREE.createPaths = createPaths;
    function createPath(char, divisions, scale, offsetX, offsetY, data) {
        var glyph = data.glyphs[char] || data.glyphs['?'];
        if (!glyph)
            return;
        var path = new THREE.ShapePath();
        var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
        if (glyph.o) {
            var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
            for (var i = 0, l = outline.length; i < l;) {
                var action = outline[i++];
                switch (action) {
                    case 'm': // moveTo
                        x = outline[i++] * scale + offsetX;
                        y = outline[i++] * scale + offsetY;
                        path.moveTo(x, y);
                        break;
                    case 'l': // lineTo
                        x = outline[i++] * scale + offsetX;
                        y = outline[i++] * scale + offsetY;
                        path.lineTo(x, y);
                        break;
                    case 'q': // quadraticCurveTo
                        cpx = outline[i++] * scale + offsetX;
                        cpy = outline[i++] * scale + offsetY;
                        cpx1 = outline[i++] * scale + offsetX;
                        cpy1 = outline[i++] * scale + offsetY;
                        path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                        break;
                    case 'b': // bezierCurveTo
                        cpx = outline[i++] * scale + offsetX;
                        cpy = outline[i++] * scale + offsetY;
                        cpx1 = outline[i++] * scale + offsetX;
                        cpy1 = outline[i++] * scale + offsetY;
                        cpx2 = outline[i++] * scale + offsetX;
                        cpy2 = outline[i++] * scale + offsetY;
                        path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                        break;
                }
            }
        }
        return { offsetX: glyph.ha * scale, path: path };
    }
    THREE.createPath = createPath;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    function CatmullRom(t, p0, p1, p2, p3) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    THREE.CatmullRom = CatmullRom;
    //
    function QuadraticBezierP0(t, p) {
        var k = 1 - t;
        return k * k * p;
    }
    THREE.QuadraticBezierP0 = QuadraticBezierP0;
    function QuadraticBezierP1(t, p) {
        return 2 * (1 - t) * t * p;
    }
    THREE.QuadraticBezierP1 = QuadraticBezierP1;
    function QuadraticBezierP2(t, p) {
        return t * t * p;
    }
    THREE.QuadraticBezierP2 = QuadraticBezierP2;
    function QuadraticBezier(t, p0, p1, p2) {
        return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) +
            QuadraticBezierP2(t, p2);
    }
    THREE.QuadraticBezier = QuadraticBezier;
    //
    function CubicBezierP0(t, p) {
        var k = 1 - t;
        return k * k * k * p;
    }
    THREE.CubicBezierP0 = CubicBezierP0;
    function CubicBezierP1(t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
    }
    THREE.CubicBezierP1 = CubicBezierP1;
    function CubicBezierP2(t, p) {
        return 3 * (1 - t) * t * t * p;
    }
    THREE.CubicBezierP2 = CubicBezierP2;
    function CubicBezierP3(t, p) {
        return t * t * t * p;
    }
    THREE.CubicBezierP3 = CubicBezierP3;
    function CubicBezier(t, p0, p1, p2, p3) {
        return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) +
            CubicBezierP3(t, p3);
    }
    THREE.CubicBezier = CubicBezier;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Path extends THREE.CurvePath {
        constructor(points) {
            super();
            this.type = 'Path';
            this.currentPoint = new THREE.Vector2();
            if (points) {
                this.setFromPoints(points);
            }
        }
        setFromPoints(points) {
            this.moveTo(points[0].x, points[0].y);
            for (var i = 1, l = points.length; i < l; i++) {
                this.lineTo(points[i].x, points[i].y);
            }
        }
        moveTo(x, y) {
            this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
        }
        lineTo(x, y) {
            var curve = new THREE.LineCurve(this.currentPoint.clone(), new THREE.Vector2(x, y));
            this.curves.push(curve);
            this.currentPoint.set(x, y);
        }
        quadraticCurveTo(aCPx, aCPy, aX, aY) {
            var curve = new THREE.QuadraticBezierCurve(this.currentPoint.clone(), new THREE.Vector2(aCPx, aCPy), new THREE.Vector2(aX, aY));
            this.curves.push(curve);
            this.currentPoint.set(aX, aY);
        }
        bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            var curve = new THREE.CubicBezierCurve(this.currentPoint.clone(), new THREE.Vector2(aCP1x, aCP1y), new THREE.Vector2(aCP2x, aCP2y), new THREE.Vector2(aX, aY));
            this.curves.push(curve);
            this.currentPoint.set(aX, aY);
        }
        splineThru(pts /*Array of Vector*/) {
            var npts = [this.currentPoint.clone()].concat(pts);
            var curve = new THREE.SplineCurve(npts);
            this.curves.push(curve);
            this.currentPoint.copy(pts[pts.length - 1]);
        }
        arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;
            this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        }
        absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise, null);
        }
        ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;
            this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        }
        absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var curve = new THREE.EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
            if (this.curves.length > 0) {
                // if a previous curve is present, attempt to join
                var firstPoint = curve.getPoint(0, null);
                if (!firstPoint.equals(this.currentPoint)) {
                    this.lineTo(firstPoint.x, firstPoint.y);
                }
            }
            this.curves.push(curve);
            var lastPoint = curve.getPoint(1, null);
            this.currentPoint.copy(lastPoint);
        }
        copy(source) {
            super.copy(source);
            this.currentPoint.copy(source.currentPoint);
            return this;
        }
        toJSON() {
            var data = super.toJSON();
            //var data = CurvePath.prototype.toJSON.call(this);
            data.currentPoint = this.currentPoint.toArray();
            return data;
        }
        fromJSON(json) {
            super.fromJSON(json);
            this.currentPoint.fromArray(json.currentPoint);
            return this;
        }
    }
    THREE.Path = Path;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Shape extends THREE.Path {
        constructor(points) {
            super(points);
            this.uuid = THREE._Math.generateUUID();
            this.type = 'Shape';
            this.holes = [];
        }
        getPointsHoles(divisions) {
            var holesPts = [];
            for (var i = 0, l = this.holes.length; i < l; i++) {
                holesPts[i] = this.holes[i].getPoints(divisions);
            }
            return holesPts;
        }
        // get points of shape and holes (keypoints based on segments parameter)
        extractPoints(divisions) {
            return {
                shape: this.getPoints(divisions),
                holes: this.getPointsHoles(divisions)
            };
        }
        copy(source) {
            THREE.Path.prototype.copy.call(this, source);
            this.holes = [];
            for (var i = 0, l = source.holes.length; i < l; i++) {
                var hole = source.holes[i];
                this.holes.push(hole.clone());
            }
            return this;
        }
        toJSON() {
            var data = THREE.Path.prototype.toJSON.call(this);
            data.uuid = this.uuid;
            data.holes = [];
            for (var i = 0, l = this.holes.length; i < l; i++) {
                var hole = this.holes[i];
                data.holes.push(hole.toJSON());
            }
            return data;
        }
        fromJSON(json) {
            super.fromJSON(json);
            this.uuid = json.uuid;
            this.holes = [];
            for (var i = 0, l = json.holes.length; i < l; i++) {
                var hole = json.holes[i];
                this.holes.push(new THREE.Path(null).fromJSON(hole));
            }
            return this;
        }
    }
    THREE.Shape = Shape;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class ShapePath {
        constructor() {
            this.type = 'ShapePath';
            this.color = new THREE.Color(null);
            this.subPaths = [];
            this.currentPath = null;
        }
        moveTo(x, y) {
            this.currentPath = new THREE.Path(null);
            this.subPaths.push(this.currentPath);
            this.currentPath.moveTo(x, y);
        }
        lineTo(x, y) {
            this.currentPath.lineTo(x, y);
        }
        quadraticCurveTo(aCPx, aCPy, aX, aY) {
            this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        }
        bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        }
        splineThru(pts) {
            this.currentPath.splineThru(pts);
        }
        toShapes(isCCW, noHoles) {
            function toShapesNoHoles(inSubpaths) {
                var shapes = [];
                for (var i = 0, l = inSubpaths.length; i < l; i++) {
                    var tmpPath = inSubpaths[i];
                    var tmpShape = new THREE.Shape(null);
                    tmpShape.curves = tmpPath.curves;
                    shapes.push(tmpShape);
                }
                return shapes;
            }
            function isPointInsidePolygon(inPt, inPolygon) {
                var polyLen = inPolygon.length;
                // inPt on polygon contour => immediate success    or
                // toggling of inside/outside at every single! intersection point of an edge
                //  with the horizontal line through inPt, left of inPt
                //  not counting lowerY endpoints of edges and whole edges on that line
                var inside = false;
                for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                    var edgeLowPt = inPolygon[p];
                    var edgeHighPt = inPolygon[q];
                    var edgeDx = edgeHighPt.x - edgeLowPt.x;
                    var edgeDy = edgeHighPt.y - edgeLowPt.y;
                    if (Math.abs(edgeDy) > Number.EPSILON) {
                        // not parallel
                        if (edgeDy < 0) {
                            edgeLowPt = inPolygon[q];
                            edgeDx = -edgeDx;
                            edgeHighPt = inPolygon[p];
                            edgeDy = -edgeDy;
                        }
                        if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y))
                            continue;
                        if (inPt.y === edgeLowPt.y) {
                            if (inPt.x === edgeLowPt.x)
                                return true; // inPt is on contour ?
                            // continue;				// no intersection or edgeLowPt => doesn't count !!!
                        }
                        else {
                            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                            if (perpEdge === 0)
                                return true; // inPt is on contour ?
                            if (perpEdge < 0)
                                continue;
                            inside = !inside; // true intersection left of inPt
                        }
                    }
                    else {
                        // parallel or collinear
                        if (inPt.y !== edgeLowPt.y)
                            continue; // parallel
                        // edge lies on the same horizontal line as inPt
                        if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) ||
                            ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x)))
                            return true; // inPt: Point on contour !
                        // continue;
                    }
                }
                return inside;
            }
            var isClockWise = THREE.ShapeUtils.isClockWise;
            var subPaths = this.subPaths;
            if (subPaths.length === 0)
                return [];
            if (noHoles === true)
                return toShapesNoHoles(subPaths);
            var solid, tmpPath, tmpShape, shapes = [];
            if (subPaths.length === 1) {
                tmpPath = subPaths[0];
                tmpShape = new THREE.Shape(null);
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
                return shapes;
            }
            var holesFirst = !isClockWise(subPaths[0].getPoints());
            holesFirst = isCCW ? !holesFirst : holesFirst;
            // console.log("Holes first", holesFirst);
            var betterShapeHoles = [];
            var newShapes = [];
            var newShapeHoles = [];
            var mainIdx = 0;
            var tmpPoints;
            newShapes[mainIdx] = undefined;
            newShapeHoles[mainIdx] = [];
            for (var i = 0, l = subPaths.length; i < l; i++) {
                tmpPath = subPaths[i];
                tmpPoints = tmpPath.getPoints();
                solid = isClockWise(tmpPoints);
                solid = isCCW ? !solid : solid;
                if (solid) {
                    if ((!holesFirst) && (newShapes[mainIdx]))
                        mainIdx++;
                    newShapes[mainIdx] = { s: new THREE.Shape(null), p: tmpPoints };
                    newShapes[mainIdx].s.curves = tmpPath.curves;
                    if (holesFirst)
                        mainIdx++;
                    newShapeHoles[mainIdx] = [];
                    //console.log('cw', i);
                }
                else {
                    newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
                    //console.log('ccw', i);
                }
            }
            // only Holes? -> probably all Shapes with wrong orientation
            if (!newShapes[0])
                return toShapesNoHoles(subPaths);
            if (newShapes.length > 1) {
                var ambiguous = false;
                var toChange = [];
                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                    betterShapeHoles[sIdx] = [];
                }
                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                    var sho = newShapeHoles[sIdx];
                    for (var hIdx = 0; hIdx < sho.length; hIdx++) {
                        var ho = sho[hIdx];
                        var hole_unassigned = true;
                        for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                                if (sIdx !== s2Idx)
                                    toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
                                if (hole_unassigned) {
                                    hole_unassigned = false;
                                    betterShapeHoles[s2Idx].push(ho);
                                }
                                else {
                                    ambiguous = true;
                                }
                            }
                        }
                        if (hole_unassigned) {
                            betterShapeHoles[sIdx].push(ho);
                        }
                    }
                }
                // console.log("ambiguous: ", ambiguous);
                if (toChange.length > 0) {
                    // console.log("to change: ", toChange);
                    if (!ambiguous)
                        newShapeHoles = betterShapeHoles;
                }
            }
            var tmpHoles;
            for (var i = 0, il = newShapes.length; i < il; i++) {
                tmpShape = newShapes[i].s;
                shapes.push(tmpShape);
                tmpHoles = newShapeHoles[i];
                for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
                    tmpShape.holes.push(tmpHoles[j].h);
                }
            }
            //console.log("shape", shapes);
            return shapes;
        }
    }
    THREE.ShapePath = ShapePath;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class EllipseCurve extends THREE.Curve {
        constructor(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            super();
            this.type = 'EllipseCurve';
            this.aX = aX || 0;
            this.aY = aY || 0;
            this.xRadius = xRadius || 1;
            this.yRadius = yRadius || 1;
            this.aStartAngle = aStartAngle || 0;
            this.aEndAngle = aEndAngle || 2 * Math.PI;
            this.aClockwise = aClockwise || false;
            this.aRotation = aRotation || 0;
            this.isEllipseCurve = true;
        }
        toJSON() {
            var data = super.toJSON();
            data.aX = this.aX;
            data.aY = this.aY;
            data.xRadius = this.xRadius;
            data.yRadius = this.yRadius;
            data.aStartAngle = this.aStartAngle;
            data.aEndAngle = this.aEndAngle;
            data.aClockwise = this.aClockwise;
            data.aRotation = this.aRotation;
            return data;
        }
        ;
        fromJSON(json) {
            super.fromJSON(json);
            this.aX = json.aX;
            this.aY = json.aY;
            this.xRadius = json.xRadius;
            this.yRadius = json.yRadius;
            this.aStartAngle = json.aStartAngle;
            this.aEndAngle = json.aEndAngle;
            this.aClockwise = json.aClockwise;
            this.aRotation = json.aRotation;
            return this;
        }
        ;
    }
    THREE.EllipseCurve = EllipseCurve;
})(THREE || (THREE = {}));
/// <reference path="./EllipseCurve" />
var THREE;
/// <reference path="./EllipseCurve" />
(function (THREE) {
    class ArcCurve extends THREE.EllipseCurve {
        constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            super(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise, null, null);
            this.type = 'ArcCurve';
            this.isArcCurve = true;
        }
    }
    THREE.ArcCurve = ArcCurve;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    function CubicPoly() {
        var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
        /*
         * Compute coefficients for a cubic polynomial
         *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
         * such that
         *   p(0) = x0, p(1) = x1
         *  and
         *   p'(0) = t0, p'(1) = t1.
         */
        function init(x0, x1, t0, t1) {
            c0 = x0;
            c1 = t0;
            c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
            c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }
        return {
            initCatmullRom: function (x0, x1, x2, x3, tension) {
                init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
            },
            initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
                // compute tangents when parameterized in [t1,t2]
                var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
                var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
                // rescale tangents for parametrization in [0,1]
                t1 *= dt1;
                t2 *= dt1;
                init(x1, x2, t1, t2);
            },
            calc: function (t) {
                var t2 = t * t;
                var t3 = t2 * t;
                return c0 + c1 * t + c2 * t2 + c3 * t3;
            }
        };
    }
    THREE.CubicPoly = CubicPoly;
    var tmp = new THREE.Vector3();
    var px = CubicPoly();
    var py = CubicPoly();
    var pz = CubicPoly();
    class CatmullRomCurve3 {
        constructor(points, closed, curveType, tension) {
            this.type = 'CatmullRomCurve3';
            this.points = points || [];
            this.closed = closed || false;
            this.curveType = curveType || 'centripetal';
            this.tension = tension || 0.5;
            this.isCatmullRomCurve3 = true;
        }
        getPoint(t, optionalTarget) {
            var point = optionalTarget || new THREE.Vector3();
            var points = this.points;
            var l = points.length;
            var p = (l - (this.closed ? 0 : 1)) * t;
            var intPoint = Math.floor(p);
            var weight = p - intPoint;
            if (this.closed) {
                intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
            }
            else if (weight === 0 && intPoint === l - 1) {
                intPoint = l - 2;
                weight = 1;
            }
            var p0, p1, p2, p3; // 4 points
            if (this.closed || intPoint > 0) {
                p0 = points[(intPoint - 1) % l];
            }
            else {
                // extrapolate first point
                tmp.subVectors(points[0], points[1]).add(points[0]);
                p0 = tmp;
            }
            p1 = points[intPoint % l];
            p2 = points[(intPoint + 1) % l];
            if (this.closed || intPoint + 2 < l) {
                p3 = points[(intPoint + 2) % l];
            }
            else {
                // extrapolate last point
                tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
                p3 = tmp;
            }
            if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
                // init Centripetal / Chordal Catmull-Rom
                var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
                var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
                var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
                var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
                // safety check for repeated points
                if (dt1 < 1e-4)
                    dt1 = 1.0;
                if (dt0 < 1e-4)
                    dt0 = dt1;
                if (dt2 < 1e-4)
                    dt2 = dt1;
                px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
                py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
                pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
            }
            else if (this.curveType === 'catmullrom') {
                px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
                py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
                pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
            }
            point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
            return point;
        }
        ;
        copy(source) {
            THREE.Curve.prototype.copy.call(this, source);
            this.points = [];
            for (var i = 0, l = source.points.length; i < l; i++) {
                var point = source.points[i];
                this.points.push(point.clone());
            }
            this.closed = source.closed;
            this.curveType = source.curveType;
            this.tension = source.tension;
            return this;
        }
        ;
        toJSON() {
            var data = THREE.Curve.prototype.toJSON.call(this);
            data.points = [];
            for (var i = 0, l = this.points.length; i < l; i++) {
                var point = this.points[i];
                data.points.push(point.toArray());
            }
            data.closed = this.closed;
            data.curveType = this.curveType;
            data.tension = this.tension;
            return data;
        }
        ;
        fromJSON(json) {
            THREE.Curve.prototype.fromJSON.call(this, json);
            this.points = [];
            for (var i = 0, l = json.points.length; i < l; i++) {
                var point = json.points[i];
                this.points.push(new THREE.Vector3().fromArray(point, null));
            }
            this.closed = json.closed;
            this.curveType = json.curveType;
            this.tension = json.tension;
            return this;
        }
        ;
    }
    THREE.CatmullRomCurve3 = CatmullRomCurve3;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class CubicBezierCurve extends THREE.Curve {
        constructor(v0, v1, v2, v3) {
            super();
            this.type = 'CubicBezierCurve';
            this.v0 = v0 || new THREE.Vector2();
            this.v1 = v1 || new THREE.Vector2();
            this.v2 = v2 || new THREE.Vector2();
            this.v3 = v3 || new THREE.Vector2();
            this.isCubicBezierCurve = true;
        }
        getPoint(t, optionalTarget) {
            var point = optionalTarget || new THREE.Vector2();
            var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
            point.set(THREE.CubicBezier(t, v0.x, v1.x, v2.x, v3.x), THREE.CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
            return point;
        }
        ;
        copy(source) {
            super.copy(source);
            this.v0.copy(source.v0);
            this.v1.copy(source.v1);
            this.v2.copy(source.v2);
            this.v3.copy(source.v3);
            return this;
        }
        ;
        toJSON() {
            var data = super.toJSON();
            data.v0 = this.v0.toArray();
            data.v1 = this.v1.toArray();
            data.v2 = this.v2.toArray();
            data.v3 = this.v3.toArray();
            return data;
        }
        ;
        fromJSON(json) {
            super.fromJSON(json);
            this.v0.fromArray(json.v0);
            this.v1.fromArray(json.v1);
            this.v2.fromArray(json.v2);
            this.v3.fromArray(json.v3);
            return this;
        }
        ;
    }
    THREE.CubicBezierCurve = CubicBezierCurve;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class CubicBezierCurve3 extends THREE.Curve {
        constructor(v0, v1, v2, v3) {
            super();
            this.isCubicBezierCurve3 = true;
        }
        getPoint(t, optionalTarget) {
            var point = optionalTarget || new THREE.Vector3();
            var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
            point.set(THREE.CubicBezier(t, v0.x, v1.x, v2.x, v3.x), THREE.CubicBezier(t, v0.y, v1.y, v2.y, v3.y), THREE.CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
            return point;
        }
        ;
        copy(source) {
            super.copy(source);
            this.v0.copy(source.v0);
            this.v1.copy(source.v1);
            this.v2.copy(source.v2);
            this.v3.copy(source.v3);
            return this;
        }
        ;
        toJSON() {
            var data = super.toJSON();
            data.v0 = this.v0.toArray();
            data.v1 = this.v1.toArray();
            data.v2 = this.v2.toArray();
            data.v3 = this.v3.toArray();
            return data;
        }
        ;
        fromJSON(json) {
            super.fromJSON(json);
            this.v0.fromArray(json.v0);
            this.v1.fromArray(json.v1);
            this.v2.fromArray(json.v2);
            this.v3.fromArray(json.v3);
            return this;
        }
        ;
    }
    THREE.CubicBezierCurve3 = CubicBezierCurve3;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class LineCurve extends THREE.Curve {
        constructor(v1, v2) {
            super();
            this.type = 'LineCurve';
            this.v1 = v1 || new THREE.Vector2();
            this.v2 = v2 || new THREE.Vector2();
        }
        getPoint(t, optionalTarget) {
            var point = optionalTarget || new THREE.Vector2();
            if (t === 1) {
                point.copy(this.v2);
            }
            else {
                point.copy(this.v2).sub(this.v1);
                point.multiplyScalar(t).add(this.v1);
            }
            return point;
        }
        // Line curve is linear, so we can overwrite default getPointAt
        getPointAt(u, optionalTarget) {
            return this.getPoint(u, optionalTarget);
        }
        getTangent( /* t */) {
            var tangent = this.v2.clone().sub(this.v1);
            return tangent.normalize();
        }
        copy(source) {
            super.copy(source);
            this.v1.copy(source.v1);
            this.v2.copy(source.v2);
            return this;
        }
        toJSON() {
            var data = super.toJSON();
            data.v1 = this.v1.toArray();
            data.v2 = this.v2.toArray();
            return data;
        }
        fromJSON(json) {
            super.fromJSON(json);
            this.v1.fromArray(json.v1);
            this.v2.fromArray(json.v2);
            return this;
        }
    }
    THREE.LineCurve = LineCurve;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class LineCurve3 extends THREE.Curve {
        constructor(v1, v2) {
            super();
            this.type = 'LineCurve3';
            this.v1 = v1 || new THREE.Vector3();
            this.v2 = v2 || new THREE.Vector3();
        }
        getPoint(t, optionalTarget) {
            var point = optionalTarget || new THREE.Vector3();
            if (t === 1) {
                point.copy(this.v2);
            }
            else {
                point.copy(this.v2).sub(this.v1);
                point.multiplyScalar(t).add(this.v1);
            }
            return point;
        }
        ;
        // Line curve is linear, so we can overwrite default getPointAt
        getPointAt(u, optionalTarget) {
            return this.getPoint(u, optionalTarget);
        }
        ;
        copy(source) {
            super.copy(source);
            this.v1.copy(source.v1);
            this.v2.copy(source.v2);
            return this;
        }
        ;
        toJSON() {
            var data = super.toJSON();
            data.v1 = this.v1.toArray();
            data.v2 = this.v2.toArray();
            return data;
        }
        ;
        fromJSON(json) {
            super.fromJSON(json);
            this.v1.fromArray(json.v1);
            this.v2.fromArray(json.v2);
            return this;
        }
        ;
    }
    THREE.LineCurve3 = LineCurve3;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class QuadraticBezierCurve extends THREE.Curve {
        constructor(v0, v1, v2) {
            super();
            this.type = 'QuadraticBezierCurve';
            this.v0 = v0 || new THREE.Vector2();
            this.v1 = v1 || new THREE.Vector2();
            this.v2 = v2 || new THREE.Vector2();
            this.isQuadraticBezierCurve = true;
        }
        getPoint(t, optionalTarget) {
            var point = optionalTarget || new THREE.Vector2();
            var v0 = this.v0, v1 = this.v1, v2 = this.v2;
            point.set(THREE.QuadraticBezier(t, v0.x, v1.x, v2.x), THREE.QuadraticBezier(t, v0.y, v1.y, v2.y));
            return point;
        }
        ;
        copy(source) {
            super.copy(source);
            this.v0.copy(source.v0);
            this.v1.copy(source.v1);
            this.v2.copy(source.v2);
            return this;
        }
        ;
        toJSON() {
            var data = super.toJSON();
            data.v0 = this.v0.toArray();
            data.v1 = this.v1.toArray();
            data.v2 = this.v2.toArray();
            return data;
        }
        ;
        fromJSON(json) {
            super.fromJSON(json);
            this.v0.fromArray(json.v0);
            this.v1.fromArray(json.v1);
            this.v2.fromArray(json.v2);
            return this;
        }
        ;
    }
    THREE.QuadraticBezierCurve = QuadraticBezierCurve;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class QuadraticBezierCurve3 extends THREE.Curve {
        constructor(v0, v1, v2) {
            super();
            this.type = 'QuadraticBezierCurve3';
            this.v0 = v0 || new THREE.Vector3();
            this.v1 = v1 || new THREE.Vector3();
            this.v2 = v2 || new THREE.Vector3();
        }
        getPoint(t, optionalTarget) {
            var point = optionalTarget || new THREE.Vector3();
            var v0 = this.v0, v1 = this.v1, v2 = this.v2;
            point.set(THREE.QuadraticBezier(t, v0.x, v1.x, v2.x), THREE.QuadraticBezier(t, v0.y, v1.y, v2.y), THREE.QuadraticBezier(t, v0.z, v1.z, v2.z));
            return point;
        }
        ;
        copy(source) {
            super.copy(source);
            this.v0.copy(source.v0);
            this.v1.copy(source.v1);
            this.v2.copy(source.v2);
            return this;
        }
        ;
        toJSON() {
            var data = super.toJSON();
            data.v0 = this.v0.toArray();
            data.v1 = this.v1.toArray();
            data.v2 = this.v2.toArray();
            return data;
        }
        ;
        fromJSON(json) {
            super.fromJSON(json);
            this.v0.fromArray(json.v0);
            this.v1.fromArray(json.v1);
            this.v2.fromArray(json.v2);
            return this;
        }
        ;
    }
    THREE.QuadraticBezierCurve3 = QuadraticBezierCurve3;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class SplineCurve extends THREE.Curve {
        constructor(points) {
            super();
            this.type = 'SplineCurve';
            this.points = points || [];
            this.isSplineCurve = true;
        }
        getPoint(t, optionalTarget) {
            var point = optionalTarget || new THREE.Vector2();
            var points = this.points;
            var p = (points.length - 1) * t;
            var intPoint = Math.floor(p);
            var weight = p - intPoint;
            var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
            var p1 = points[intPoint];
            var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
            var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
            point.set(THREE.CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), THREE.CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
            return point;
        }
        ;
        copy(source) {
            THREE.Curve.prototype.copy.call(this, source);
            this.points = [];
            for (var i = 0, l = source.points.length; i < l; i++) {
                var point = source.points[i];
                this.points.push(point.clone());
            }
            return this;
        }
        ;
        toJSON() {
            var data = THREE.Curve.prototype.toJSON.call(this);
            data.points = [];
            for (var i = 0, l = this.points.length; i < l; i++) {
                var point = this.points[i];
                data.points.push(point.toArray());
            }
            return data;
        }
        ;
        fromJSON(json) {
            THREE.Curve.prototype.fromJSON.call(this, json);
            this.points = [];
            for (var i = 0, l = json.points.length; i < l; i++) {
                var point = json.points[i];
                this.points.push(new THREE.Vector2(null, null).fromArray(point, null));
            }
            return this;
        }
        ;
    }
    THREE.SplineCurve = SplineCurve;
})(THREE || (THREE = {}));
/// <reference path="./LineCurve" />
/// <reference path="./LineCurve3" />
/// <reference path="./QuadraticBezierCurve" />
/// <reference path="./QuadraticBezierCurve3" />
/// <reference path="./SplineCurve" />
var THREE;
/// <reference path="./LineCurve" />
/// <reference path="./LineCurve3" />
/// <reference path="./QuadraticBezierCurve" />
/// <reference path="./QuadraticBezierCurve3" />
/// <reference path="./SplineCurve" />
(function (THREE) {
    THREE.Curves = {
        "ArcCurve": THREE.ArcCurve,
        "CatmullRomCurve3": THREE.CatmullRomCurve3,
        "CubicBezierCurve": THREE.CubicBezierCurve,
        "CubicBezierCurve3": THREE.CubicBezierCurve3,
        "EllipseCurve": THREE.EllipseCurve,
        "LineCurve": THREE.LineCurve,
        "LineCurve3": THREE.LineCurve3,
        "QuadraticBezierCurve": THREE.QuadraticBezierCurve,
        "QuadraticBezierCurve3": THREE.QuadraticBezierCurve3,
        "SplineCurve": THREE.SplineCurve
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class ImmediateRenderObject extends THREE.Object3D {
        constructor() {
            super();
            this.isImmediateRenderObject = true;
        }
        render() {
        }
    }
    THREE.ImmediateRenderObject = ImmediateRenderObject;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class BoxGeometry extends THREE.Geometry {
        constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
            super();
            //Geometry.call(this);
            this.type = 'BoxGeometry';
            this.parameters = {
                width: width,
                height: height,
                depth: depth,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                depthSegments: depthSegments
            };
            this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
            this.mergeVertices();
        }
    }
    THREE.BoxGeometry = BoxGeometry;
    // BoxBufferGeometry
    class BoxBufferGeometry extends THREE.BufferGeometry {
        constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
            super();
            //BufferGeometry.call(this);
            this.type = 'BoxBufferGeometry';
            this.parameters = {
                width: width,
                height: height,
                depth: depth,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                depthSegments: depthSegments
            };
            var scope = this;
            width = width || 1;
            height = height || 1;
            depth = depth || 1;
            // segments
            widthSegments = Math.floor(widthSegments) || 1;
            heightSegments = Math.floor(heightSegments) || 1;
            depthSegments = Math.floor(depthSegments) || 1;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // helper variables
            var numberOfVertices = 0;
            var groupStart = 0;
            // build each side of the box geometry
            buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
            buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
            buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
            buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
            buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
            buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
            // build geometry
            this.setIndex(indices);
            this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
                var segmentWidth = width / gridX;
                var segmentHeight = height / gridY;
                var widthHalf = width / 2;
                var heightHalf = height / 2;
                var depthHalf = depth / 2;
                var gridX1 = gridX + 1;
                var gridY1 = gridY + 1;
                var vertexCounter = 0;
                var groupCount = 0;
                var ix, iy;
                var vector = new THREE.Vector3();
                // generate vertices, normals and uvs
                for (iy = 0; iy < gridY1; iy++) {
                    var y = iy * segmentHeight - heightHalf;
                    for (ix = 0; ix < gridX1; ix++) {
                        var x = ix * segmentWidth - widthHalf;
                        // set values to correct vector component
                        vector[u] = x * udir;
                        vector[v] = y * vdir;
                        vector[w] = depthHalf;
                        // now apply vector to vertex buffer
                        vertices.push(vector.x, vector.y, vector.z);
                        // set values to correct vector component
                        vector[u] = 0;
                        vector[v] = 0;
                        vector[w] = depth > 0 ? 1 : -1;
                        // now apply vector to normal buffer
                        normals.push(vector.x, vector.y, vector.z);
                        // uvs
                        uvs.push(ix / gridX);
                        uvs.push(1 - (iy / gridY));
                        // counters
                        vertexCounter += 1;
                    }
                }
                // indices
                // 1. you need three indices to draw a single face
                // 2. a single segment consists of two faces
                // 3. so we need to generate six (2*3) indices per segment
                for (iy = 0; iy < gridY; iy++) {
                    for (ix = 0; ix < gridX; ix++) {
                        var a = numberOfVertices + ix + gridX1 * iy;
                        var b = numberOfVertices + ix + gridX1 * (iy + 1);
                        var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                        var d = numberOfVertices + (ix + 1) + gridX1 * iy;
                        // faces
                        indices.push(a, b, d);
                        indices.push(b, c, d);
                        // increase counter
                        groupCount += 6;
                    }
                }
                // add a group to the geometry. this will ensure multi material support
                scope.addGroup(groupStart, groupCount, materialIndex);
                // calculate new start value for groups
                groupStart += groupCount;
                // update total number of vertices
                numberOfVertices += vertexCounter;
            }
        }
    }
    THREE.BoxBufferGeometry = BoxBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class CircleGeometry extends THREE.Geometry {
        constructor(radius, segments, thetaStart, thetaLength) {
            super();
            //Geometry.call( this );
            this.type = 'CircleGeometry';
            this.parameters = {
                radius: radius,
                segments: segments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
            this.mergeVertices();
        }
    }
    THREE.CircleGeometry = CircleGeometry;
    // CircleBufferGeometry
    class CircleBufferGeometry extends THREE.BufferGeometry {
        constructor(radius, segments, thetaStart, thetaLength) {
            super();
            //BufferGeometry.call(this);
            this.type = 'CircleBufferGeometry';
            this.parameters = {
                radius: radius,
                segments: segments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            radius = radius || 1;
            segments = segments !== undefined ? Math.max(3, segments) : 8;
            thetaStart = thetaStart !== undefined ? thetaStart : 0;
            thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // helper variables
            var i, s;
            var vertex = new THREE.Vector3();
            var uv = new THREE.Vector2();
            // center point
            vertices.push(0, 0, 0);
            normals.push(0, 0, 1);
            uvs.push(0.5, 0.5);
            for (s = 0, i = 3; s <= segments; s++, i += 3) {
                var segment = thetaStart + s / segments * thetaLength;
                // vertex
                vertex.x = radius * Math.cos(segment);
                vertex.y = radius * Math.sin(segment);
                vertices.push(vertex.x, vertex.y, vertex.z);
                // normal
                normals.push(0, 0, 1);
                // uvs
                uv.x = (vertices[i] / radius + 1) / 2;
                uv.y = (vertices[i + 1] / radius + 1) / 2;
                uvs.push(uv.x, uv.y);
            }
            // indices
            for (i = 1; i <= segments; i++) {
                indices.push(i, i + 1, 0);
            }
            // build geometry
            this.setIndex(indices);
            this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        }
    }
    THREE.CircleBufferGeometry = CircleBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class CylinderGeometry extends THREE.Geometry {
        constructor(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            super();
            this.type = 'CylinderGeometry';
            this.parameters = {
                radiusTop: radiusTop,
                radiusBottom: radiusBottom,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                openEnded: openEnded,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
            this.mergeVertices();
        }
    }
    THREE.CylinderGeometry = CylinderGeometry;
    // CylinderBufferGeometry
    class CylinderBufferGeometry extends THREE.BufferGeometry {
        constructor(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            super();
            this.type = 'CylinderBufferGeometry';
            this.parameters = {
                radiusTop: radiusTop,
                radiusBottom: radiusBottom,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                openEnded: openEnded,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            var scope = this;
            radiusTop = radiusTop !== undefined ? radiusTop : 1;
            radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
            height = height || 1;
            radialSegments = Math.floor(radialSegments) || 8;
            heightSegments = Math.floor(heightSegments) || 1;
            openEnded = openEnded !== undefined ? openEnded : false;
            thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
            thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // helper variables
            var index = 0;
            var indexArray = [];
            var halfHeight = height / 2;
            var groupStart = 0;
            // generate geometry
            generateTorso();
            if (openEnded === false) {
                if (radiusTop > 0)
                    generateCap(true);
                if (radiusBottom > 0)
                    generateCap(false);
            }
            // build geometry
            this.setIndex(indices);
            this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            function generateTorso() {
                var x, y;
                var normal = new THREE.Vector3();
                var vertex = new THREE.Vector3();
                var groupCount = 0;
                // this will be used to calculate the normal
                var slope = (radiusBottom - radiusTop) / height;
                // generate vertices, normals and uvs
                for (y = 0; y <= heightSegments; y++) {
                    var indexRow = [];
                    var v = y / heightSegments;
                    // calculate the radius of the current row
                    var radius = v * (radiusBottom - radiusTop) + radiusTop;
                    for (x = 0; x <= radialSegments; x++) {
                        var u = x / radialSegments;
                        var theta = u * thetaLength + thetaStart;
                        var sinTheta = Math.sin(theta);
                        var cosTheta = Math.cos(theta);
                        // vertex
                        vertex.x = radius * sinTheta;
                        vertex.y = -v * height + halfHeight;
                        vertex.z = radius * cosTheta;
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        // normal
                        normal.set(sinTheta, slope, cosTheta).normalize();
                        normals.push(normal.x, normal.y, normal.z);
                        // uv
                        uvs.push(u, 1 - v);
                        // save index of vertex in respective row
                        indexRow.push(index++);
                    }
                    // now save vertices of the row in our index array
                    indexArray.push(indexRow);
                }
                // generate indices
                for (x = 0; x < radialSegments; x++) {
                    for (y = 0; y < heightSegments; y++) {
                        // we use the index array to access the correct indices
                        var a = indexArray[y][x];
                        var b = indexArray[y + 1][x];
                        var c = indexArray[y + 1][x + 1];
                        var d = indexArray[y][x + 1];
                        // faces
                        indices.push(a, b, d);
                        indices.push(b, c, d);
                        // update group counter
                        groupCount += 6;
                    }
                }
                // add a group to the geometry. this will ensure multi material support
                scope.addGroup(groupStart, groupCount, 0);
                // calculate new start value for groups
                groupStart += groupCount;
            }
            function generateCap(top) {
                var x, centerIndexStart, centerIndexEnd;
                var uv = new THREE.Vector2();
                var vertex = new THREE.Vector3();
                var groupCount = 0;
                var radius = (top === true) ? radiusTop : radiusBottom;
                var sign = (top === true) ? 1 : -1;
                // save the index of the first center vertex
                centerIndexStart = index;
                // first we generate the center vertex data of the cap.
                // because the geometry needs one set of uvs per face,
                // we must generate a center vertex per face/segment
                for (x = 1; x <= radialSegments; x++) {
                    // vertex
                    vertices.push(0, halfHeight * sign, 0);
                    // normal
                    normals.push(0, sign, 0);
                    // uv
                    uvs.push(0.5, 0.5);
                    // increase index
                    index++;
                }
                // save the index of the last center vertex
                centerIndexEnd = index;
                // now we generate the surrounding vertices, normals and uvs
                for (x = 0; x <= radialSegments; x++) {
                    var u = x / radialSegments;
                    var theta = u * thetaLength + thetaStart;
                    var cosTheta = Math.cos(theta);
                    var sinTheta = Math.sin(theta);
                    // vertex
                    vertex.x = radius * sinTheta;
                    vertex.y = halfHeight * sign;
                    vertex.z = radius * cosTheta;
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // normal
                    normals.push(0, sign, 0);
                    // uv
                    uv.x = (cosTheta * 0.5) + 0.5;
                    uv.y = (sinTheta * 0.5 * sign) + 0.5;
                    uvs.push(uv.x, uv.y);
                    // increase index
                    index++;
                }
                // generate indices
                for (x = 0; x < radialSegments; x++) {
                    var c = centerIndexStart + x;
                    var i = centerIndexEnd + x;
                    if (top === true) {
                        // face top
                        indices.push(i, i + 1, c);
                    }
                    else {
                        // face bottom
                        indices.push(i + 1, i, c);
                    }
                    groupCount += 3;
                }
                // add a group to the geometry. this will ensure multi material support
                scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
                // calculate new start value for groups
                groupStart += groupCount;
            }
        }
    }
    THREE.CylinderBufferGeometry = CylinderBufferGeometry;
})(THREE || (THREE = {}));
/// <reference path="./CylinderGeometry" />
var THREE;
/// <reference path="./CylinderGeometry" />
(function (THREE) {
    class ConeGeometry extends THREE.CylinderGeometry {
        constructor(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
            this.type = 'ConeGeometry';
            this.parameters = {
                radius: radius,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                openEnded: openEnded,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
        }
    }
    THREE.ConeGeometry = ConeGeometry;
    // ConeBufferGeometry
    class ConeBufferGeometry extends THREE.CylinderBufferGeometry {
        constructor(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
            this.type = 'ConeBufferGeometry';
            this.parameters = {
                radius: radius,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                openEnded: openEnded,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
        }
    }
    THREE.ConeBufferGeometry = ConeBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class PolyhedronGeometry extends THREE.Geometry {
        constructor(vertices, indices, radius, detail) {
            super();
            this.type = 'PolyhedronGeometry';
            this.parameters = {
                vertices: vertices,
                indices: indices,
                radius: radius,
                detail: detail
            };
            this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
            this.mergeVertices();
        }
    }
    THREE.PolyhedronGeometry = PolyhedronGeometry;
    // PolyhedronBufferGeometry
    class PolyhedronBufferGeometry extends THREE.BufferGeometry {
        constructor(vertices, indices, radius, detail) {
            super();
            this.type = 'PolyhedronBufferGeometry';
            this.parameters = {
                vertices: vertices,
                indices: indices,
                radius: radius,
                detail: detail
            };
            radius = radius || 1;
            detail = detail || 0;
            // default buffer data
            var vertexBuffer = [];
            var uvBuffer = [];
            // the subdivision creates the vertex buffer data
            subdivide(detail);
            // all vertices should lie on a conceptual sphere with a given radius
            appplyRadius(radius);
            // finally, create the uv data
            generateUVs();
            // build non-indexed geometry
            this.addAttribute('position', new THREE.Float32BufferAttribute(vertexBuffer, 3));
            this.addAttribute('normal', new THREE.Float32BufferAttribute(vertexBuffer.slice(), 3));
            this.addAttribute('uv', new THREE.Float32BufferAttribute(uvBuffer, 2));
            if (detail === 0) {
                this.computeVertexNormals(); // flat normals
            }
            else {
                this.normalizeNormals(); // smooth normals
            }
            // helper functions
            function subdivide(detail) {
                var a = new THREE.Vector3();
                var b = new THREE.Vector3();
                var c = new THREE.Vector3();
                // iterate over all faces and apply a subdivison with the given detail value
                for (var i = 0; i < indices.length; i += 3) {
                    // get the vertices of the face
                    getVertexByIndex(indices[i + 0], a);
                    getVertexByIndex(indices[i + 1], b);
                    getVertexByIndex(indices[i + 2], c);
                    // perform subdivision
                    subdivideFace(a, b, c, detail);
                }
            }
            function subdivideFace(a, b, c, detail) {
                var cols = Math.pow(2, detail);
                // we use this multidimensional array as a data structure for creating the subdivision
                var v = [];
                var i, j;
                // construct all of the vertices for this subdivision
                for (i = 0; i <= cols; i++) {
                    v[i] = [];
                    var aj = a.clone().lerp(c, i / cols);
                    var bj = b.clone().lerp(c, i / cols);
                    var rows = cols - i;
                    for (j = 0; j <= rows; j++) {
                        if (j === 0 && i === cols) {
                            v[i][j] = aj;
                        }
                        else {
                            v[i][j] = aj.clone().lerp(bj, j / rows);
                        }
                    }
                }
                // construct all of the faces
                for (i = 0; i < cols; i++) {
                    for (j = 0; j < 2 * (cols - i) - 1; j++) {
                        var k = Math.floor(j / 2);
                        if (j % 2 === 0) {
                            pushVertex(v[i][k + 1]);
                            pushVertex(v[i + 1][k]);
                            pushVertex(v[i][k]);
                        }
                        else {
                            pushVertex(v[i][k + 1]);
                            pushVertex(v[i + 1][k + 1]);
                            pushVertex(v[i + 1][k]);
                        }
                    }
                }
            }
            function appplyRadius(radius) {
                var vertex = new THREE.Vector3();
                // iterate over the entire buffer and apply the radius to each vertex
                for (var i = 0; i < vertexBuffer.length; i += 3) {
                    vertex.x = vertexBuffer[i + 0];
                    vertex.y = vertexBuffer[i + 1];
                    vertex.z = vertexBuffer[i + 2];
                    vertex.normalize().multiplyScalar(radius);
                    vertexBuffer[i + 0] = vertex.x;
                    vertexBuffer[i + 1] = vertex.y;
                    vertexBuffer[i + 2] = vertex.z;
                }
            }
            function generateUVs() {
                var vertex = new THREE.Vector3();
                for (var i = 0; i < vertexBuffer.length; i += 3) {
                    vertex.x = vertexBuffer[i + 0];
                    vertex.y = vertexBuffer[i + 1];
                    vertex.z = vertexBuffer[i + 2];
                    var u = azimuth(vertex) / 2 / Math.PI + 0.5;
                    var v = inclination(vertex) / Math.PI + 0.5;
                    uvBuffer.push(u, 1 - v);
                }
                correctUVs();
                correctSeam();
            }
            function correctSeam() {
                // handle case when face straddles the seam, see #3269
                for (var i = 0; i < uvBuffer.length; i += 6) {
                    // uv data of a single face
                    var x0 = uvBuffer[i + 0];
                    var x1 = uvBuffer[i + 2];
                    var x2 = uvBuffer[i + 4];
                    var max = Math.max(x0, x1, x2);
                    var min = Math.min(x0, x1, x2);
                    // 0.9 is somewhat arbitrary
                    if (max > 0.9 && min < 0.1) {
                        if (x0 < 0.2)
                            uvBuffer[i + 0] += 1;
                        if (x1 < 0.2)
                            uvBuffer[i + 2] += 1;
                        if (x2 < 0.2)
                            uvBuffer[i + 4] += 1;
                    }
                }
            }
            function pushVertex(vertex) {
                vertexBuffer.push(vertex.x, vertex.y, vertex.z);
            }
            function getVertexByIndex(index, vertex) {
                var stride = index * 3;
                vertex.x = vertices[stride + 0];
                vertex.y = vertices[stride + 1];
                vertex.z = vertices[stride + 2];
            }
            function correctUVs() {
                var a = new THREE.Vector3();
                var b = new THREE.Vector3();
                var c = new THREE.Vector3();
                var centroid = new THREE.Vector3();
                var uvA = new THREE.Vector2();
                var uvB = new THREE.Vector2();
                var uvC = new THREE.Vector2();
                for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
                    a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
                    b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
                    c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
                    uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                    uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                    uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                    centroid.copy(a).add(b).add(c).divideScalar(3);
                    var azi = azimuth(centroid);
                    correctUV(uvA, j + 0, a, azi);
                    correctUV(uvB, j + 2, b, azi);
                    correctUV(uvC, j + 4, c, azi);
                }
            }
            function correctUV(uv, stride, vector, azimuth) {
                if ((azimuth < 0) && (uv.x === 1)) {
                    uvBuffer[stride] = uv.x - 1;
                }
                if ((vector.x === 0) && (vector.z === 0)) {
                    uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
                }
            }
            // Angle around the Y axis, counter-clockwise when looking from above.
            function azimuth(vector) {
                return Math.atan2(vector.z, -vector.x);
            }
            // Angle above the XZ plane.
            function inclination(vector) {
                return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
            }
        }
    }
    THREE.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
})(THREE || (THREE = {}));
/// <reference path="./PolyhedronGeometry.ts" />
var THREE;
/// <reference path="./PolyhedronGeometry.ts" />
(function (THREE) {
    class DodecahedronGeometry extends THREE.Geometry {
        constructor(radius, detail) {
            super();
            this.type = 'DodecahedronGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
            this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
            this.mergeVertices();
        }
    }
    THREE.DodecahedronGeometry = DodecahedronGeometry;
    // DodecahedronBufferGeometry
    class DodecahedronBufferGeometry extends THREE.PolyhedronBufferGeometry {
        constructor(radius, detail) {
            var t = (1 + Math.sqrt(5)) / 2;
            var r = 1 / t;
            var vertices = [
                // (±1, ±1, ±1)
                -1, -1, -1, -1, -1, 1,
                -1, 1, -1, -1, 1, 1,
                1, -1, -1, 1, -1, 1,
                1, 1, -1, 1, 1, 1,
                // (0, ±1/φ, ±φ)
                0, -r, -t, 0, -r, t,
                0, r, -t, 0, r, t,
                // (±1/φ, ±φ, 0)
                -r, -t, 0, -r, t, 0,
                r, -t, 0, r, t, 0,
                // (±φ, 0, ±1/φ)
                -t, 0, -r, t, 0, -r,
                -t, 0, r, t, 0, r
            ];
            var indices = [
                3, 11, 7, 3, 7, 15, 3, 15, 13,
                7, 19, 17, 7, 17, 6, 7, 6, 15,
                17, 4, 8, 17, 8, 10, 17, 10, 6,
                8, 0, 16, 8, 16, 2, 8, 2, 10,
                0, 12, 1, 0, 1, 18, 0, 18, 16,
                6, 10, 2, 6, 2, 13, 6, 13, 15,
                2, 16, 18, 2, 18, 3, 2, 3, 13,
                18, 1, 9, 18, 9, 11, 18, 11, 3,
                4, 14, 12, 4, 12, 0, 4, 0, 8,
                11, 9, 5, 11, 5, 19, 11, 19, 7,
                19, 5, 14, 19, 14, 4, 19, 4, 17,
                1, 12, 14, 1, 14, 5, 1, 5, 9
            ];
            super(vertices, indices, radius, detail);
            this.type = 'DodecahedronBufferGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
        }
    }
    THREE.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class EdgesGeometry extends THREE.BufferGeometry {
        constructor(geometry, thresholdAngle) {
            super();
            this.type = 'EdgesGeometry';
            this.parameters = {
                thresholdAngle: thresholdAngle
            };
            thresholdAngle = (thresholdAngle !== undefined) ? thresholdAngle : 1;
            // buffer
            var vertices = [];
            // helper variables
            var thresholdDot = Math.cos(THREE._Math.DEG2RAD * thresholdAngle);
            var edge = [0, 0], edges = {}, edge1, edge2;
            var key, keys = ['a', 'b', 'c'];
            // prepare source geometry
            var geometry2;
            if (geometry.isBufferGeometry) {
                geometry2 = new THREE.Geometry();
                geometry2.fromBufferGeometry(geometry);
            }
            else {
                geometry2 = geometry.clone();
            }
            geometry2.mergeVertices();
            geometry2.computeFaceNormals();
            var sourceVertices = geometry2.vertices;
            var faces = geometry2.faces;
            // now create a data structure where each entry represents an edge with its adjoining faces
            for (var i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                for (var j = 0; j < 3; j++) {
                    edge1 = face[keys[j]];
                    edge2 = face[keys[(j + 1) % 3]];
                    edge[0] = Math.min(edge1, edge2);
                    edge[1] = Math.max(edge1, edge2);
                    key = edge[0] + ',' + edge[1];
                    if (edges[key] === undefined) {
                        edges[key] = { index1: edge[0], index2: edge[1], face1: i, face2: undefined };
                    }
                    else {
                        edges[key].face2 = i;
                    }
                }
            }
            // generate vertices
            for (key in edges) {
                var e = edges[key];
                // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
                if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
                    var vertex = sourceVertices[e.index1];
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    vertex = sourceVertices[e.index2];
                    vertices.push(vertex.x, vertex.y, vertex.z);
                }
            }
            // build geometry
            this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        }
    }
    THREE.EdgesGeometry = EdgesGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class ExtrudeGeometry extends THREE.Geometry {
        constructor(shapes, options) {
            super();
            this.type = 'ExtrudeGeometry';
            this.parameters = {
                shapes: shapes,
                options: options
            };
            this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
            this.mergeVertices();
        }
    }
    THREE.ExtrudeGeometry = ExtrudeGeometry;
    class ExtrudeBufferGeometry extends THREE.BufferGeometry {
        constructor(shapes, options) {
            super();
            this.type = 'ExtrudeBufferGeometry';
            this.parameters = {
                shapes: shapes,
                options: options
            };
            shapes = Array.isArray(shapes) ? shapes : [shapes];
            var scope = this;
            var verticesArray = [];
            var uvArray = [];
            for (var i = 0, l = shapes.length; i < l; i++) {
                var shape = shapes[i];
                addShape(shape);
            }
            // build geometry
            this.addAttribute('position', new THREE.Float32BufferAttribute(verticesArray, 3));
            this.addAttribute('uv', new THREE.Float32BufferAttribute(uvArray, 2));
            this.computeVertexNormals();
            // functions
            function addShape(shape) {
                var placeholder = [];
                // options
                var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
                var steps = options.steps !== undefined ? options.steps : 1;
                var depth = options.depth !== undefined ? options.depth : 100;
                var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
                var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
                var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
                var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
                var extrudePath = options.extrudePath;
                var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeBufferGeometry.WorldUVGenerator;
                // deprecated options
                if (options.amount !== undefined) {
                    console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
                    depth = options.amount;
                }
                //
                var extrudePts, extrudeByPath = false;
                var splineTube, binormal, normal, position2;
                if (extrudePath) {
                    extrudePts = extrudePath.getSpacedPoints(steps);
                    extrudeByPath = true;
                    bevelEnabled = false; // bevels not supported for path extrusion
                    // SETUP TNB variables
                    // TODO1 - have a .isClosed in spline?
                    splineTube = extrudePath.computeFrenetFrames(steps, false);
                    // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
                    binormal = new THREE.Vector3();
                    normal = new THREE.Vector3();
                    position2 = new THREE.Vector3();
                }
                // Safeguards if bevels are not enabled
                if (!bevelEnabled) {
                    bevelSegments = 0;
                    bevelThickness = 0;
                    bevelSize = 0;
                }
                // Variables initialization
                var ahole, h, hl; // looping of holes
                var shapePoints = shape.extractPoints(curveSegments);
                var vertices = shapePoints.shape;
                var holes = shapePoints.holes;
                var reverse = !THREE.ShapeUtils.isClockWise(vertices);
                if (reverse) {
                    vertices = vertices.reverse();
                    // Maybe we should also check if holes are in the opposite direction, just to be safe ...
                    for (h = 0, hl = holes.length; h < hl; h++) {
                        ahole = holes[h];
                        if (THREE.ShapeUtils.isClockWise(ahole)) {
                            holes[h] = ahole.reverse();
                        }
                    }
                }
                var faces = THREE.ShapeUtils.triangulateShape(vertices, holes);
                /* Vertices */
                var contour = vertices; // vertices has all points but contour has only points of circumference
                for (h = 0, hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    vertices = vertices.concat(ahole);
                }
                function scalePt2(pt, vec, size) {
                    if (!vec)
                        console.error("THREE.ExtrudeGeometry: vec does not exist");
                    return vec.clone().multiplyScalar(size).add(pt);
                }
                var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length;
                // Find directions for point movement
                function getBevelVec(inPt, inPrev, inNext) {
                    // computes for inPt the corresponding point inPt' on a new contour
                    //   shifted by 1 unit (length of normalized vector) to the left
                    // if we walk along contour clockwise, this new contour is outside the old one
                    //
                    // inPt' is the intersection of the two lines parallel to the two
                    //  adjacent edges of inPt at a distance of 1 unit on the left side.
                    var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
                    // good reading for geometry algorithms (here: line-line intersection)
                    // http://geomalgorithms.com/a05-_intersect-1.html
                    var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
                    var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
                    var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
                    // check for collinear edges
                    var collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
                    if (Math.abs(collinear0) > Number.EPSILON) {
                        // not collinear
                        // length of vectors for normalizing
                        var v_prev_len = Math.sqrt(v_prev_lensq);
                        var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                        // shift adjacent points by unit vectors to the left
                        var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
                        var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
                        var ptNextShift_x = (inNext.x - v_next_y / v_next_len);
                        var ptNextShift_y = (inNext.y + v_next_x / v_next_len);
                        // scaling factor for v_prev to intersection point
                        var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
                            (ptNextShift_y - ptPrevShift_y) * v_next_x) /
                            (v_prev_x * v_next_y - v_prev_y * v_next_x);
                        // vector from inPt to intersection point
                        v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
                        v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
                        // Don't normalize!, otherwise sharp corners become ugly
                        //  but prevent crazy spikes
                        var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
                        if (v_trans_lensq <= 2) {
                            return new THREE.Vector2(v_trans_x, v_trans_y);
                        }
                        else {
                            shrink_by = Math.sqrt(v_trans_lensq / 2);
                        }
                    }
                    else {
                        // handle special case of collinear edges
                        var direction_eq = false; // assumes: opposite
                        if (v_prev_x > Number.EPSILON) {
                            if (v_next_x > Number.EPSILON) {
                                direction_eq = true;
                            }
                        }
                        else {
                            if (v_prev_x < -Number.EPSILON) {
                                if (v_next_x < -Number.EPSILON) {
                                    direction_eq = true;
                                }
                            }
                            else {
                                if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                                    direction_eq = true;
                                }
                            }
                        }
                        if (direction_eq) {
                            // console.log("Warning: lines are a straight sequence");
                            v_trans_x = -v_prev_y;
                            v_trans_y = v_prev_x;
                            shrink_by = Math.sqrt(v_prev_lensq);
                        }
                        else {
                            // console.log("Warning: lines are a straight spike");
                            v_trans_x = v_prev_x;
                            v_trans_y = v_prev_y;
                            shrink_by = Math.sqrt(v_prev_lensq / 2);
                        }
                    }
                    return new THREE.Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
                }
                var contourMovements = [];
                for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                    if (j === il)
                        j = 0;
                    if (k === il)
                        k = 0;
                    //  (j)---(i)---(k)
                    // console.log('i,j,k', i, j , k)
                    contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
                }
                var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
                for (h = 0, hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    oneHoleMovements = [];
                    for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                        if (j === il)
                            j = 0;
                        if (k === il)
                            k = 0;
                        //  (j)---(i)---(k)
                        oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
                    }
                    holesMovements.push(oneHoleMovements);
                    verticesMovements = verticesMovements.concat(oneHoleMovements);
                }
                // Loop bevelSegments, 1 for the front, 1 for the back
                for (b = 0; b < bevelSegments; b++) {
                    //for ( b = bevelSegments; b > 0; b -- ) {
                    t = b / bevelSegments;
                    z = bevelThickness * Math.cos(t * Math.PI / 2);
                    bs = bevelSize * Math.sin(t * Math.PI / 2);
                    // contract shape
                    for (i = 0, il = contour.length; i < il; i++) {
                        vert = scalePt2(contour[i], contourMovements[i], bs);
                        v(vert.x, vert.y, -z);
                    }
                    // expand holes
                    for (h = 0, hl = holes.length; h < hl; h++) {
                        ahole = holes[h];
                        oneHoleMovements = holesMovements[h];
                        for (i = 0, il = ahole.length; i < il; i++) {
                            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                            v(vert.x, vert.y, -z);
                        }
                    }
                }
                bs = bevelSize;
                // Back facing vertices
                for (i = 0; i < vlen; i++) {
                    vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                    if (!extrudeByPath) {
                        v(vert.x, vert.y, 0);
                    }
                    else {
                        // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
                        normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                        binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                        position2.copy(extrudePts[0]).add(normal).add(binormal);
                        v(position2.x, position2.y, position2.z);
                    }
                }
                // Add stepped vertices...
                // Including front facing vertices
                var s;
                for (s = 1; s <= steps; s++) {
                    for (i = 0; i < vlen; i++) {
                        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                        if (!extrudeByPath) {
                            v(vert.x, vert.y, depth / steps * s);
                        }
                        else {
                            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
                            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                            position2.copy(extrudePts[s]).add(normal).add(binormal);
                            v(position2.x, position2.y, position2.z);
                        }
                    }
                }
                // Add bevel segments planes
                //for ( b = 1; b <= bevelSegments; b ++ ) {
                for (b = bevelSegments - 1; b >= 0; b--) {
                    t = b / bevelSegments;
                    z = bevelThickness * Math.cos(t * Math.PI / 2);
                    bs = bevelSize * Math.sin(t * Math.PI / 2);
                    // contract shape
                    for (i = 0, il = contour.length; i < il; i++) {
                        vert = scalePt2(contour[i], contourMovements[i], bs);
                        v(vert.x, vert.y, depth + z);
                    }
                    // expand holes
                    for (h = 0, hl = holes.length; h < hl; h++) {
                        ahole = holes[h];
                        oneHoleMovements = holesMovements[h];
                        for (i = 0, il = ahole.length; i < il; i++) {
                            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                            if (!extrudeByPath) {
                                v(vert.x, vert.y, depth + z);
                            }
                            else {
                                v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                            }
                        }
                    }
                }
                /* Faces */
                // Top and bottom faces
                buildLidFaces();
                // Sides faces
                buildSideFaces();
                /////  Internal functions
                function buildLidFaces() {
                    var start = verticesArray.length / 3;
                    if (bevelEnabled) {
                        var layer = 0; // steps + 1
                        var offset = vlen * layer;
                        // Bottom faces
                        for (i = 0; i < flen; i++) {
                            face = faces[i];
                            f3(face[2] + offset, face[1] + offset, face[0] + offset);
                        }
                        layer = steps + bevelSegments * 2;
                        offset = vlen * layer;
                        // Top faces
                        for (i = 0; i < flen; i++) {
                            face = faces[i];
                            f3(face[0] + offset, face[1] + offset, face[2] + offset);
                        }
                    }
                    else {
                        // Bottom faces
                        for (i = 0; i < flen; i++) {
                            face = faces[i];
                            f3(face[2], face[1], face[0]);
                        }
                        // Top faces
                        for (i = 0; i < flen; i++) {
                            face = faces[i];
                            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                        }
                    }
                    scope.addGroup(start, verticesArray.length / 3 - start, 0);
                }
                // Create faces for the z-sides of the shape
                function buildSideFaces() {
                    var start = verticesArray.length / 3;
                    var layeroffset = 0;
                    sidewalls(contour, layeroffset);
                    layeroffset += contour.length;
                    for (h = 0, hl = holes.length; h < hl; h++) {
                        ahole = holes[h];
                        sidewalls(ahole, layeroffset);
                        //, true
                        layeroffset += ahole.length;
                    }
                    scope.addGroup(start, verticesArray.length / 3 - start, 1);
                }
                function sidewalls(contour, layeroffset) {
                    var j, k;
                    i = contour.length;
                    while (--i >= 0) {
                        j = i;
                        k = i - 1;
                        if (k < 0)
                            k = contour.length - 1;
                        //console.log('b', i,j, i-1, k,vertices.length);
                        var s = 0, sl = steps + bevelSegments * 2;
                        for (s = 0; s < sl; s++) {
                            var slen1 = vlen * s;
                            var slen2 = vlen * (s + 1);
                            var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                            f4(a, b, c, d);
                        }
                    }
                }
                function v(x, y, z) {
                    placeholder.push(x);
                    placeholder.push(y);
                    placeholder.push(z);
                }
                function f3(a, b, c) {
                    addVertex(a);
                    addVertex(b);
                    addVertex(c);
                    var nextIndex = verticesArray.length / 3;
                    var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                    addUV(uvs[0]);
                    addUV(uvs[1]);
                    addUV(uvs[2]);
                }
                function f4(a, b, c, d) {
                    addVertex(a);
                    addVertex(b);
                    addVertex(d);
                    addVertex(b);
                    addVertex(c);
                    addVertex(d);
                    var nextIndex = verticesArray.length / 3;
                    var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                    addUV(uvs[0]);
                    addUV(uvs[1]);
                    addUV(uvs[3]);
                    addUV(uvs[1]);
                    addUV(uvs[2]);
                    addUV(uvs[3]);
                }
                function addVertex(index) {
                    verticesArray.push(placeholder[index * 3 + 0]);
                    verticesArray.push(placeholder[index * 3 + 1]);
                    verticesArray.push(placeholder[index * 3 + 2]);
                }
                function addUV(vector2) {
                    uvArray.push(vector2.x);
                    uvArray.push(vector2.y);
                }
            }
        }
    }
    ExtrudeBufferGeometry.WorldUVGenerator = {
        generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
            var a_x = vertices[indexA * 3];
            var a_y = vertices[indexA * 3 + 1];
            var b_x = vertices[indexB * 3];
            var b_y = vertices[indexB * 3 + 1];
            var c_x = vertices[indexC * 3];
            var c_y = vertices[indexC * 3 + 1];
            return [
                new THREE.Vector2(a_x, a_y),
                new THREE.Vector2(b_x, b_y),
                new THREE.Vector2(c_x, c_y)
            ];
        },
        generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
            var a_x = vertices[indexA * 3];
            var a_y = vertices[indexA * 3 + 1];
            var a_z = vertices[indexA * 3 + 2];
            var b_x = vertices[indexB * 3];
            var b_y = vertices[indexB * 3 + 1];
            var b_z = vertices[indexB * 3 + 2];
            var c_x = vertices[indexC * 3];
            var c_y = vertices[indexC * 3 + 1];
            var c_z = vertices[indexC * 3 + 2];
            var d_x = vertices[indexD * 3];
            var d_y = vertices[indexD * 3 + 1];
            var d_z = vertices[indexD * 3 + 2];
            if (Math.abs(a_y - b_y) < 0.01) {
                return [
                    new THREE.Vector2(a_x, 1 - a_z),
                    new THREE.Vector2(b_x, 1 - b_z),
                    new THREE.Vector2(c_x, 1 - c_z),
                    new THREE.Vector2(d_x, 1 - d_z)
                ];
            }
            else {
                return [
                    new THREE.Vector2(a_y, 1 - a_z),
                    new THREE.Vector2(b_y, 1 - b_z),
                    new THREE.Vector2(c_y, 1 - c_z),
                    new THREE.Vector2(d_y, 1 - d_z)
                ];
            }
        }
    };
    THREE.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WireframeGeometry extends THREE.BufferGeometry {
        constructor(geometry) {
            super();
            this.type = 'WireframeGeometry';
            // buffer
            var vertices = [];
            // helper variables
            var i, j, l, o, ol;
            var edge = [0, 0], edges = {}, e, edge1, edge2;
            var key, keys = ['a', 'b', 'c'];
            var vertex;
            // different logic for Geometry and BufferGeometry
            if (geometry && geometry.isGeometry) {
                // create a data structure that contains all edges without duplicates
                var faces = geometry.faces;
                for (i = 0, l = faces.length; i < l; i++) {
                    var face = faces[i];
                    for (j = 0; j < 3; j++) {
                        edge1 = face[keys[j]];
                        edge2 = face[keys[(j + 1) % 3]];
                        edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
                        edge[1] = Math.max(edge1, edge2);
                        key = edge[0] + ',' + edge[1];
                        if (edges[key] === undefined) {
                            edges[key] = { index1: edge[0], index2: edge[1] };
                        }
                    }
                }
                // generate vertices
                for (key in edges) {
                    e = edges[key];
                    vertex = geometry.vertices[e.index1];
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    vertex = geometry.vertices[e.index2];
                    vertices.push(vertex.x, vertex.y, vertex.z);
                }
            }
            else if (geometry && geometry.isBufferGeometry) {
                var position, indices, groups;
                var group, start, count;
                var index1, index2;
                vertex = new THREE.Vector3();
                if (geometry.index !== null) {
                    // indexed BufferGeometry
                    position = geometry.attributes.position;
                    indices = geometry.index;
                    groups = geometry.groups;
                    if (groups.length === 0) {
                        groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
                    }
                    // create a data structure that contains all eges without duplicates
                    for (o = 0, ol = groups.length; o < ol; ++o) {
                        group = groups[o];
                        start = group.start;
                        count = group.count;
                        for (i = start, l = (start + count); i < l; i += 3) {
                            for (j = 0; j < 3; j++) {
                                edge1 = indices.getX(i + j);
                                edge2 = indices.getX(i + (j + 1) % 3);
                                edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
                                edge[1] = Math.max(edge1, edge2);
                                key = edge[0] + ',' + edge[1];
                                if (edges[key] === undefined) {
                                    edges[key] = { index1: edge[0], index2: edge[1] };
                                }
                            }
                        }
                    }
                    // generate vertices
                    for (key in edges) {
                        e = edges[key];
                        vertex.fromBufferAttribute(position, e.index1);
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        vertex.fromBufferAttribute(position, e.index2);
                        vertices.push(vertex.x, vertex.y, vertex.z);
                    }
                }
                else {
                    // non-indexed BufferGeometry
                    position = geometry.attributes.position;
                    for (i = 0, l = (position.count / 3); i < l; i++) {
                        for (j = 0; j < 3; j++) {
                            // three edges per triangle, an edge is represented as (index1, index2)
                            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
                            index1 = 3 * i + j;
                            vertex.fromBufferAttribute(position, index1);
                            vertices.push(vertex.x, vertex.y, vertex.z);
                            index2 = 3 * i + ((j + 1) % 3);
                            vertex.fromBufferAttribute(position, index2);
                            vertices.push(vertex.x, vertex.y, vertex.z);
                        }
                    }
                }
            }
            // build geometry
            this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        }
    }
    THREE.WireframeGeometry = WireframeGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class ParametricGeometry extends THREE.Geometry {
        constructor(func, slices, stacks) {
            super();
            this.type = 'ParametricGeometry';
            this.parameters = {
                func: func,
                slices: slices,
                stacks: stacks
            };
            this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
            this.mergeVertices();
        }
    }
    THREE.ParametricGeometry = ParametricGeometry;
    // ParametricBufferGeometry
    class ParametricBufferGeometry extends THREE.BufferGeometry {
        constructor(func, slices, stacks) {
            super();
            this.type = 'ParametricBufferGeometry';
            this.parameters = {
                func: func,
                slices: slices,
                stacks: stacks
            };
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            var EPS = 0.00001;
            var normal = new THREE.Vector3();
            var p0 = new THREE.Vector3(), p1 = new THREE.Vector3();
            var pu = new THREE.Vector3(), pv = new THREE.Vector3();
            var i, j;
            // generate vertices, normals and uvs
            var sliceCount = slices + 1;
            for (i = 0; i <= stacks; i++) {
                var v = i / stacks;
                for (j = 0; j <= slices; j++) {
                    var u = j / slices;
                    // vertex
                    func(u, v, p0);
                    vertices.push(p0.x, p0.y, p0.z);
                    // normal
                    // approximate tangent vectors via finite differences
                    if (u - EPS >= 0) {
                        func(u - EPS, v, p1);
                        pu.subVectors(p0, p1);
                    }
                    else {
                        func(u + EPS, v, p1);
                        pu.subVectors(p1, p0);
                    }
                    if (v - EPS >= 0) {
                        func(u, v - EPS, p1);
                        pv.subVectors(p0, p1);
                    }
                    else {
                        func(u, v + EPS, p1);
                        pv.subVectors(p1, p0);
                    }
                    // cross product of tangent vectors returns surface normal
                    normal.crossVectors(pu, pv).normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    // uv
                    uvs.push(u, v);
                }
            }
            // generate indices
            for (i = 0; i < stacks; i++) {
                for (j = 0; j < slices; j++) {
                    var a = i * sliceCount + j;
                    var b = i * sliceCount + j + 1;
                    var c = (i + 1) * sliceCount + j + 1;
                    var d = (i + 1) * sliceCount + j;
                    // faces one and two
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
            // build geometry
            this.setIndex(indices);
            this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        }
    }
    THREE.ParametricBufferGeometry = ParametricBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class TetrahedronGeometry extends THREE.Geometry {
        constructor(radius, detail) {
            super();
            this.type = 'TetrahedronGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
            this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
            this.mergeVertices();
        }
    }
    THREE.TetrahedronGeometry = TetrahedronGeometry;
    // TetrahedronBufferGeometry
    class TetrahedronBufferGeometry extends THREE.PolyhedronBufferGeometry {
        constructor(radius, detail) {
            var vertices = [
                1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1
            ];
            var indices = [
                2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1
            ];
            super(vertices, indices, radius, detail);
            this.type = 'TetrahedronBufferGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
        }
    }
    THREE.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class OctahedronGeometry extends THREE.Geometry {
        constructor(radius, detail) {
            super();
            this.type = 'OctahedronGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
            this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
            this.mergeVertices();
        }
    }
    THREE.OctahedronGeometry = OctahedronGeometry;
    // OctahedronBufferGeometry
    class OctahedronBufferGeometry extends THREE.PolyhedronBufferGeometry {
        constructor(radius, detail) {
            var vertices = [
                1, 0, 0, -1, 0, 0, 0, 1, 0,
                0, -1, 0, 0, 0, 1, 0, 0, -1
            ];
            var indices = [
                0, 2, 4, 0, 4, 3, 0, 3, 5,
                0, 5, 2, 1, 2, 5, 1, 5, 3,
                1, 3, 4, 1, 4, 2
            ];
            super(vertices, indices, radius, detail);
            this.type = 'OctahedronBufferGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
        }
    }
    THREE.OctahedronBufferGeometry = OctahedronBufferGeometry;
})(THREE || (THREE = {}));
/// <reference path="./PolyhedronGeometry" />
var THREE;
/// <reference path="./PolyhedronGeometry" />
(function (THREE) {
    class IcosahedronGeometry extends THREE.Geometry {
        constructor(radius, detail) {
            super();
            this.type = 'IcosahedronGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
            this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
            this.mergeVertices();
        }
    }
    THREE.IcosahedronGeometry = IcosahedronGeometry;
    // IcosahedronBufferGeometry
    class IcosahedronBufferGeometry extends THREE.PolyhedronBufferGeometry {
        constructor(radius, detail) {
            var t = (1 + Math.sqrt(5)) / 2;
            var vertices = [
                -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0,
                0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t,
                t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1
            ];
            var indices = [
                0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
                1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
                3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
                4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
            ];
            super(vertices, indices, radius, detail);
            this.type = 'IcosahedronBufferGeometry';
            this.parameters = {
                radius: radius,
                detail: detail
            };
        }
    }
    THREE.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class TubeGeometry extends THREE.Geometry {
        constructor(path, tubularSegments, radius, radialSegments, closed, taper) {
            super();
            this.type = 'TubeGeometry';
            this.parameters = {
                path: path,
                tubularSegments: tubularSegments,
                radius: radius,
                radialSegments: radialSegments,
                closed: closed
            };
            if (taper !== undefined)
                console.warn('THREE.TubeGeometry: taper has been removed.');
            var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
            // expose internals
            this.tangents = bufferGeometry.tangents;
            this.normals = bufferGeometry.normals;
            this.binormals = bufferGeometry.binormals;
            // create geometry
            this.fromBufferGeometry(bufferGeometry);
            this.mergeVertices();
        }
    }
    THREE.TubeGeometry = TubeGeometry;
    // TubeBufferGeometry
    class TubeBufferGeometry extends THREE.BufferGeometry {
        constructor(path, tubularSegments, radius, radialSegments, closed) {
            super();
            this.type = 'TubeBufferGeometry';
            this.parameters = {
                path: path,
                tubularSegments: tubularSegments,
                radius: radius,
                radialSegments: radialSegments,
                closed: closed
            };
            tubularSegments = tubularSegments || 64;
            radius = radius || 1;
            radialSegments = radialSegments || 8;
            closed = closed || false;
            var frames = path.computeFrenetFrames(tubularSegments, closed);
            // expose internals
            this.tangents = frames.tangents;
            this.normals = frames.normals;
            this.binormals = frames.binormals;
            // helper variables
            var vertex = new THREE.Vector3();
            var normal = new THREE.Vector3();
            var uv = new THREE.Vector2();
            var P = new THREE.Vector3();
            var i, j;
            // buffer
            var vertices = [];
            var normals = [];
            var uvs = [];
            var indices = [];
            // create buffer data
            generateBufferData();
            // build geometry
            this.setIndex(indices);
            this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            // functions
            function generateBufferData() {
                for (i = 0; i < tubularSegments; i++) {
                    generateSegment(i);
                }
                // if the geometry is not closed, generate the last row of vertices and normals
                // at the regular position on the given path
                //
                // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
                generateSegment((closed === false) ? tubularSegments : 0);
                // uvs are generated in a separate function.
                // this makes it easy compute correct values for closed geometries
                generateUVs();
                // finally create faces
                generateIndices();
            }
            function generateSegment(i) {
                // we use getPointAt to sample evenly distributed points from the given path
                P = path.getPointAt(i / tubularSegments, P);
                // retrieve corresponding normal and binormal
                var N = frames.normals[i];
                var B = frames.binormals[i];
                // generate normals and vertices for the current segment
                for (j = 0; j <= radialSegments; j++) {
                    var v = j / radialSegments * Math.PI * 2;
                    var sin = Math.sin(v);
                    var cos = -Math.cos(v);
                    // normal
                    normal.x = (cos * N.x + sin * B.x);
                    normal.y = (cos * N.y + sin * B.y);
                    normal.z = (cos * N.z + sin * B.z);
                    normal.normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    // vertex
                    vertex.x = P.x + radius * normal.x;
                    vertex.y = P.y + radius * normal.y;
                    vertex.z = P.z + radius * normal.z;
                    vertices.push(vertex.x, vertex.y, vertex.z);
                }
            }
            function generateIndices() {
                for (j = 1; j <= tubularSegments; j++) {
                    for (i = 1; i <= radialSegments; i++) {
                        var a = (radialSegments + 1) * (j - 1) + (i - 1);
                        var b = (radialSegments + 1) * j + (i - 1);
                        var c = (radialSegments + 1) * j + i;
                        var d = (radialSegments + 1) * (j - 1) + i;
                        // faces
                        indices.push(a, b, d);
                        indices.push(b, c, d);
                    }
                }
            }
            function generateUVs() {
                for (i = 0; i <= tubularSegments; i++) {
                    for (j = 0; j <= radialSegments; j++) {
                        uv.x = i / tubularSegments;
                        uv.y = j / radialSegments;
                        uvs.push(uv.x, uv.y);
                    }
                }
            }
        }
    }
    THREE.TubeBufferGeometry = TubeBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class TorusKnotGeometry extends THREE.Geometry {
        constructor(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
            super();
            this.type = 'TorusKnotGeometry';
            this.parameters = {
                radius: radius,
                tube: tube,
                tubularSegments: tubularSegments,
                radialSegments: radialSegments,
                p: p,
                q: q
            };
            if (heightScale !== undefined)
                console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');
            this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
            this.mergeVertices();
        }
    }
    THREE.TorusKnotGeometry = TorusKnotGeometry;
    // TorusKnotBufferGeometry
    class TorusKnotBufferGeometry extends THREE.BufferGeometry {
        constructor(radius, tube, tubularSegments, radialSegments, p, q) {
            super();
            this.type = 'TorusKnotBufferGeometry';
            this.parameters = {
                radius: radius,
                tube: tube,
                tubularSegments: tubularSegments,
                radialSegments: radialSegments,
                p: p,
                q: q
            };
            radius = radius || 1;
            tube = tube || 0.4;
            tubularSegments = Math.floor(tubularSegments) || 64;
            radialSegments = Math.floor(radialSegments) || 8;
            p = p || 2;
            q = q || 3;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // helper variables
            var i, j;
            var vertex = new THREE.Vector3();
            var normal = new THREE.Vector3();
            var P1 = new THREE.Vector3();
            var P2 = new THREE.Vector3();
            var B = new THREE.Vector3();
            var T = new THREE.Vector3();
            var N = new THREE.Vector3();
            // generate vertices, normals and uvs
            for (i = 0; i <= tubularSegments; ++i) {
                // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
                var u = i / tubularSegments * p * Math.PI * 2;
                // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
                // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
                calculatePositionOnCurve(u, p, q, radius, P1);
                calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
                // calculate orthonormal basis
                T.subVectors(P2, P1);
                N.addVectors(P2, P1);
                B.crossVectors(T, N);
                N.crossVectors(B, T);
                // normalize B, N. T can be ignored, we don't use it
                B.normalize();
                N.normalize();
                for (j = 0; j <= radialSegments; ++j) {
                    // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
                    // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
                    var v = j / radialSegments * Math.PI * 2;
                    var cx = -tube * Math.cos(v);
                    var cy = tube * Math.sin(v);
                    // now calculate the final vertex position.
                    // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
                    vertex.x = P1.x + (cx * N.x + cy * B.x);
                    vertex.y = P1.y + (cx * N.y + cy * B.y);
                    vertex.z = P1.z + (cx * N.z + cy * B.z);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
                    normal.subVectors(vertex, P1).normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    // uv
                    uvs.push(i / tubularSegments);
                    uvs.push(j / radialSegments);
                }
            }
            // generate indices
            for (j = 1; j <= tubularSegments; j++) {
                for (i = 1; i <= radialSegments; i++) {
                    // indices
                    var a = (radialSegments + 1) * (j - 1) + (i - 1);
                    var b = (radialSegments + 1) * j + (i - 1);
                    var c = (radialSegments + 1) * j + i;
                    var d = (radialSegments + 1) * (j - 1) + i;
                    // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
            // build geometry
            this.setIndex(indices);
            this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            // this function calculates the current position on the torus curve
            function calculatePositionOnCurve(u, p, q, radius, position) {
                var cu = Math.cos(u);
                var su = Math.sin(u);
                var quOverP = q / p * u;
                var cs = Math.cos(quOverP);
                position.x = radius * (2 + cs) * 0.5 * cu;
                position.y = radius * (2 + cs) * su * 0.5;
                position.z = radius * Math.sin(quOverP) * 0.5;
            }
        }
    }
    THREE.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class TorusGeometry extends THREE.Geometry {
        constructor(radius, tube, radialSegments, tubularSegments, arc) {
            super();
            this.type = 'TorusGeometry';
            this.parameters = {
                radius: radius,
                tube: tube,
                radialSegments: radialSegments,
                tubularSegments: tubularSegments,
                arc: arc
            };
            this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
            this.mergeVertices();
        }
    }
    THREE.TorusGeometry = TorusGeometry;
    // TorusBufferGeometry
    class TorusBufferGeometry extends THREE.BufferGeometry {
        constructor(radius, tube, radialSegments, tubularSegments, arc) {
            super();
            this.type = 'TorusBufferGeometry';
            this.parameters = {
                radius: radius,
                tube: tube,
                radialSegments: radialSegments,
                tubularSegments: tubularSegments,
                arc: arc
            };
            radius = radius || 1;
            tube = tube || 0.4;
            radialSegments = Math.floor(radialSegments) || 8;
            tubularSegments = Math.floor(tubularSegments) || 6;
            arc = arc || Math.PI * 2;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // helper variables
            var center = new THREE.Vector3();
            var vertex = new THREE.Vector3();
            var normal = new THREE.Vector3();
            var j, i;
            // generate vertices, normals and uvs
            for (j = 0; j <= radialSegments; j++) {
                for (i = 0; i <= tubularSegments; i++) {
                    var u = i / tubularSegments * arc;
                    var v = j / radialSegments * Math.PI * 2;
                    // vertex
                    vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                    vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                    vertex.z = tube * Math.sin(v);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // normal
                    center.x = radius * Math.cos(u);
                    center.y = radius * Math.sin(u);
                    normal.subVectors(vertex, center).normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    // uv
                    uvs.push(i / tubularSegments);
                    uvs.push(j / radialSegments);
                }
            }
            // generate indices
            for (j = 1; j <= radialSegments; j++) {
                for (i = 1; i <= tubularSegments; i++) {
                    // indices
                    var a = (tubularSegments + 1) * j + i - 1;
                    var b = (tubularSegments + 1) * (j - 1) + i - 1;
                    var c = (tubularSegments + 1) * (j - 1) + i;
                    var d = (tubularSegments + 1) * j + i;
                    // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
            // build geometry
            this.setIndex(indices);
            this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        }
    }
    THREE.TorusBufferGeometry = TorusBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class TextGeometry extends THREE.Geometry {
        constructor(text, parameters) {
            super();
            this.type = 'TextGeometry';
            this.parameters = {
                text: text,
                parameters: parameters
            };
            this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
            this.mergeVertices();
        }
    }
    THREE.TextGeometry = TextGeometry;
    class TextBufferGeometry {
        constructor(text, parameters) {
            parameters = parameters || {};
            var font = parameters.font;
            if (!(font && font.isFont)) {
                console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
                return new THREE.Geometry();
            }
            var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
            // translate parameters to ExtrudeGeometry API
            parameters.depth = parameters.height !== undefined ? parameters.height : 50;
            // defaults
            if (parameters.bevelThickness === undefined)
                parameters.bevelThickness = 10;
            if (parameters.bevelSize === undefined)
                parameters.bevelSize = 8;
            if (parameters.bevelEnabled === undefined)
                parameters.bevelEnabled = false;
            THREE.ExtrudeBufferGeometry.call(this, shapes, parameters);
            this.type = 'TextBufferGeometry';
        }
    }
    THREE.TextBufferGeometry = TextBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class SphereGeometry extends THREE.Geometry {
        constructor(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
            super();
            this.type = 'SphereGeometry';
            this.parameters = {
                radius: radius,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                phiStart: phiStart,
                phiLength: phiLength,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
            this.mergeVertices();
        }
    }
    THREE.SphereGeometry = SphereGeometry;
    // SphereBufferGeometry
    class SphereBufferGeometry extends THREE.BufferGeometry {
        constructor(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
            super();
            this.type = 'SphereBufferGeometry';
            this.parameters = {
                radius: radius,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                phiStart: phiStart,
                phiLength: phiLength,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            radius = radius || 1;
            widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
            heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
            phiStart = phiStart !== undefined ? phiStart : 0;
            phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
            thetaStart = thetaStart !== undefined ? thetaStart : 0;
            thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
            var thetaEnd = thetaStart + thetaLength;
            var ix, iy;
            var index = 0;
            var grid = [];
            var vertex = new THREE.Vector3();
            var normal = new THREE.Vector3();
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // generate vertices, normals and uvs
            for (iy = 0; iy <= heightSegments; iy++) {
                var verticesRow = [];
                var v = iy / heightSegments;
                for (ix = 0; ix <= widthSegments; ix++) {
                    var u = ix / widthSegments;
                    // vertex
                    vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                    vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                    vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // normal
                    normal.set(vertex.x, vertex.y, vertex.z).normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    // uv
                    uvs.push(u, 1 - v);
                    verticesRow.push(index++);
                }
                grid.push(verticesRow);
            }
            // indices
            for (iy = 0; iy < heightSegments; iy++) {
                for (ix = 0; ix < widthSegments; ix++) {
                    var a = grid[iy][ix + 1];
                    var b = grid[iy][ix];
                    var c = grid[iy + 1][ix];
                    var d = grid[iy + 1][ix + 1];
                    if (iy !== 0 || thetaStart > 0)
                        indices.push(a, b, d);
                    if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
                        indices.push(b, c, d);
                }
            }
            // build geometry
            this.setIndex(indices);
            this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        }
    }
    THREE.SphereBufferGeometry = SphereBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class RingGeometry extends THREE.Geometry {
        constructor(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
            super();
            this.type = 'RingGeometry';
            this.parameters = {
                innerRadius: innerRadius,
                outerRadius: outerRadius,
                thetaSegments: thetaSegments,
                phiSegments: phiSegments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
            this.mergeVertices();
        }
    }
    THREE.RingGeometry = RingGeometry;
    // RingBufferGeometry
    class RingBufferGeometry extends THREE.BufferGeometry {
        constructor(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
            super();
            this.type = 'RingBufferGeometry';
            this.parameters = {
                innerRadius: innerRadius,
                outerRadius: outerRadius,
                thetaSegments: thetaSegments,
                phiSegments: phiSegments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            innerRadius = innerRadius || 0.5;
            outerRadius = outerRadius || 1;
            thetaStart = thetaStart !== undefined ? thetaStart : 0;
            thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
            thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
            phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // some helper variables
            var segment;
            var radius = innerRadius;
            var radiusStep = ((outerRadius - innerRadius) / phiSegments);
            var vertex = new THREE.Vector3();
            var uv = new THREE.Vector2();
            var j, i;
            // generate vertices, normals and uvs
            for (j = 0; j <= phiSegments; j++) {
                for (i = 0; i <= thetaSegments; i++) {
                    // values are generate from the inside of the ring to the outside
                    segment = thetaStart + i / thetaSegments * thetaLength;
                    // vertex
                    vertex.x = radius * Math.cos(segment);
                    vertex.y = radius * Math.sin(segment);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // normal
                    normals.push(0, 0, 1);
                    // uv
                    uv.x = (vertex.x / outerRadius + 1) / 2;
                    uv.y = (vertex.y / outerRadius + 1) / 2;
                    uvs.push(uv.x, uv.y);
                }
                // increase the radius for next row of vertices
                radius += radiusStep;
            }
            // indices
            for (j = 0; j < phiSegments; j++) {
                var thetaSegmentLevel = j * (thetaSegments + 1);
                for (i = 0; i < thetaSegments; i++) {
                    segment = i + thetaSegmentLevel;
                    var a = segment;
                    var b = segment + thetaSegments + 1;
                    var c = segment + thetaSegments + 2;
                    var d = segment + 1;
                    // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
            // build geometry
            this.setIndex(indices);
            this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        }
    }
    THREE.RingBufferGeometry = RingBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class PlaneGeometry extends THREE.Geometry {
        constructor(width, height, widthSegments, heightSegments) {
            super();
            this.type = 'PlaneGeometry';
            this.parameters = {
                width: width,
                height: height,
                widthSegments: widthSegments,
                heightSegments: heightSegments
            };
            this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
            this.mergeVertices();
        }
    }
    THREE.PlaneGeometry = PlaneGeometry;
    // PlaneBufferGeometry
    class PlaneBufferGeometry extends THREE.BufferGeometry {
        constructor(width, height, widthSegments, heightSegments) {
            super();
            this.type = 'PlaneBufferGeometry';
            this.parameters = {
                width: width,
                height: height,
                widthSegments: widthSegments,
                heightSegments: heightSegments
            };
            width = width || 1;
            height = height || 1;
            var width_half = width / 2;
            var height_half = height / 2;
            var gridX = Math.floor(widthSegments) || 1;
            var gridY = Math.floor(heightSegments) || 1;
            var gridX1 = gridX + 1;
            var gridY1 = gridY + 1;
            var segment_width = width / gridX;
            var segment_height = height / gridY;
            var ix, iy;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // generate vertices, normals and uvs
            for (iy = 0; iy < gridY1; iy++) {
                var y = iy * segment_height - height_half;
                for (ix = 0; ix < gridX1; ix++) {
                    var x = ix * segment_width - width_half;
                    vertices.push(x, -y, 0);
                    normals.push(0, 0, 1);
                    uvs.push(ix / gridX);
                    uvs.push(1 - (iy / gridY));
                }
            }
            // indices
            for (iy = 0; iy < gridY; iy++) {
                for (ix = 0; ix < gridX; ix++) {
                    var a = ix + gridX1 * iy;
                    var b = ix + gridX1 * (iy + 1);
                    var c = (ix + 1) + gridX1 * (iy + 1);
                    var d = (ix + 1) + gridX1 * iy;
                    // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
            // build geometry
            this.setIndex(indices);
            this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        }
    }
    THREE.PlaneBufferGeometry = PlaneBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class LatheGeometry extends THREE.Geometry {
        constructor(points, segments, phiStart, phiLength) {
            super();
            this.type = 'LatheGeometry';
            this.parameters = {
                points: points,
                segments: segments,
                phiStart: phiStart,
                phiLength: phiLength
            };
            this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
            this.mergeVertices();
        }
    }
    THREE.LatheGeometry = LatheGeometry;
    // LatheBufferGeometry
    class LatheBufferGeometry extends THREE.BufferGeometry {
        constructor(points, segments, phiStart, phiLength) {
            super();
            this.type = 'LatheBufferGeometry';
            this.parameters = {
                points: points,
                segments: segments,
                phiStart: phiStart,
                phiLength: phiLength
            };
            segments = Math.floor(segments) || 12;
            phiStart = phiStart || 0;
            phiLength = phiLength || Math.PI * 2;
            // clamp phiLength so it's in range of [ 0, 2PI ]
            phiLength = THREE._Math.clamp(phiLength, 0, Math.PI * 2);
            // buffers
            var indices = [];
            var vertices = [];
            var uvs = [];
            // helper variables
            var base;
            var inverseSegments = 1.0 / segments;
            var vertex = new THREE.Vector3();
            var uv = new THREE.Vector2();
            var i, j;
            // generate vertices and uvs
            for (i = 0; i <= segments; i++) {
                var phi = phiStart + i * inverseSegments * phiLength;
                var sin = Math.sin(phi);
                var cos = Math.cos(phi);
                for (j = 0; j <= (points.length - 1); j++) {
                    // vertex
                    vertex.x = points[j].x * sin;
                    vertex.y = points[j].y;
                    vertex.z = points[j].x * cos;
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // uv
                    uv.x = i / segments;
                    uv.y = j / (points.length - 1);
                    uvs.push(uv.x, uv.y);
                }
            }
            // indices
            for (i = 0; i < segments; i++) {
                for (j = 0; j < (points.length - 1); j++) {
                    base = j + i * points.length;
                    var a = base;
                    var b = base + points.length;
                    var c = base + points.length + 1;
                    var d = base + 1;
                    // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
            // build geometry
            this.setIndex(indices);
            this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            this.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            // generate normals
            this.computeVertexNormals();
            // if the geometry is closed, we need to average the normals along the seam.
            // because the corresponding vertices are identical (but still have different UVs).
            if (phiLength === Math.PI * 2) {
                var normals = this.attributes.normal.array;
                var n1 = new THREE.Vector3();
                var n2 = new THREE.Vector3();
                var n = new THREE.Vector3();
                // this is the buffer offset for the last line of vertices
                base = segments * points.length * 3;
                for (i = 0, j = 0; i < points.length; i++, j += 3) {
                    // select the normal of the vertex in the first line
                    n1.x = normals[j + 0];
                    n1.y = normals[j + 1];
                    n1.z = normals[j + 2];
                    // select the normal of the vertex in the last line
                    n2.x = normals[base + j + 0];
                    n2.y = normals[base + j + 1];
                    n2.z = normals[base + j + 2];
                    // average normals
                    n.addVectors(n1, n2).normalize();
                    // assign the new values to both normals
                    normals[j + 0] = normals[base + j + 0] = n.x;
                    normals[j + 1] = normals[base + j + 1] = n.y;
                    normals[j + 2] = normals[base + j + 2] = n.z;
                }
            }
        }
    }
    THREE.LatheBufferGeometry = LatheBufferGeometry;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class ShapeGeometry extends THREE.Geometry {
        constructor(shapes, curveSegments) {
            super();
            this.type = 'ShapeGeometry';
            if (typeof curveSegments === 'object') {
                console.warn('THREE.ShapeGeometry: Options parameter has been removed.');
                curveSegments = curveSegments.curveSegments;
            }
            this.parameters = {
                shapes: shapes,
                curveSegments: curveSegments
            };
            this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
            this.mergeVertices();
        }
        toJSON() {
            var data = THREE.Geometry.prototype.toJSON.call(this);
            var shapes = this.parameters.shapes;
            return toJSON(shapes, data);
        }
    }
    THREE.ShapeGeometry = ShapeGeometry;
    // ShapeBufferGeometry
    class ShapeBufferGeometry extends THREE.BufferGeometry {
        constructor(shapes, curveSegments) {
            super();
            this.type = 'ShapeBufferGeometry';
            this.parameters = {
                shapes: shapes,
                curveSegments: curveSegments
            };
            curveSegments = curveSegments || 12;
            // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            // helper variables
            var groupStart = 0;
            var groupCount = 0;
            // allow single and array values for "shapes" parameter
            if (Array.isArray(shapes) === false) {
                addShape(shapes);
            }
            else {
                for (var i = 0; i < shapes.length; i++) {
                    addShape(shapes[i]);
                    this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support
                    groupStart += groupCount;
                    groupCount = 0;
                }
            }
            // build geometry
            this.setIndex(indices);
            this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            this.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            this.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            // helper functions
            function addShape(shape) {
                var i, l, shapeHole;
                var indexOffset = vertices.length / 3;
                var points = shape.extractPoints(curveSegments);
                var shapeVertices = points.shape;
                var shapeHoles = points.holes;
                // check direction of vertices
                if (THREE.ShapeUtils.isClockWise(shapeVertices) === false) {
                    shapeVertices = shapeVertices.reverse();
                    // also check if holes are in the opposite direction
                    for (i = 0, l = shapeHoles.length; i < l; i++) {
                        shapeHole = shapeHoles[i];
                        if (THREE.ShapeUtils.isClockWise(shapeHole) === true) {
                            shapeHoles[i] = shapeHole.reverse();
                        }
                    }
                }
                var faces = THREE.ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
                // join vertices of inner and outer paths to a single array
                for (i = 0, l = shapeHoles.length; i < l; i++) {
                    shapeHole = shapeHoles[i];
                    shapeVertices = shapeVertices.concat(shapeHole);
                }
                // vertices, normals, uvs
                for (i = 0, l = shapeVertices.length; i < l; i++) {
                    var vertex = shapeVertices[i];
                    vertices.push(vertex.x, vertex.y, 0);
                    normals.push(0, 0, 1);
                    uvs.push(vertex.x, vertex.y); // world uvs
                }
                // incides
                for (i = 0, l = faces.length; i < l; i++) {
                    var face = faces[i];
                    var a = face[0] + indexOffset;
                    var b = face[1] + indexOffset;
                    var c = face[2] + indexOffset;
                    indices.push(a, b, c);
                    groupCount += 3;
                }
            }
        }
        toJSON() {
            var data = THREE.BufferGeometry.prototype.toJSON.call(this);
            var shapes = this.parameters.shapes;
            return toJSON(shapes, data);
        }
    }
    THREE.ShapeBufferGeometry = ShapeBufferGeometry;
    function toJSON(shapes, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) {
            for (var i = 0, l = shapes.length; i < l; i++) {
                var shape = shapes[i];
                data.shapes.push(shape.uuid);
            }
        }
        else {
            data.shapes.push(shapes.uuid);
        }
        return data;
    }
})(THREE || (THREE = {}));
/// <reference path="./WireframeGeometry.ts" />
/// <reference path="./ParametricGeometry.ts" />
/// <reference path="./TetrahedronGeometry.ts" />
/// <reference path="./OctahedronGeometry.ts" />
/// <reference path="./IcosahedronGeometry.ts" />
/// <reference path="./TubeGeometry.ts" />
/// <reference path="./TorusKnotGeometry.ts" />
/// <reference path="./TorusGeometry.ts" />
/// <reference path="./TextGeometry.ts" />
/// <reference path="./SphereGeometry.ts" />
/// <reference path="./RingGeometry.ts" />
/// <reference path="./PlaneGeometry.ts" />
/// <reference path="./LatheGeometry.ts" />
/// <reference path="./ShapeGeometry.ts" />
var THREE;
/// <reference path="./WireframeGeometry.ts" />
/// <reference path="./ParametricGeometry.ts" />
/// <reference path="./TetrahedronGeometry.ts" />
/// <reference path="./OctahedronGeometry.ts" />
/// <reference path="./IcosahedronGeometry.ts" />
/// <reference path="./TubeGeometry.ts" />
/// <reference path="./TorusKnotGeometry.ts" />
/// <reference path="./TorusGeometry.ts" />
/// <reference path="./TextGeometry.ts" />
/// <reference path="./SphereGeometry.ts" />
/// <reference path="./RingGeometry.ts" />
/// <reference path="./PlaneGeometry.ts" />
/// <reference path="./LatheGeometry.ts" />
/// <reference path="./ShapeGeometry.ts" />
(function (THREE) {
    THREE.Geometries = {
        "WireframeGeometry": THREE.WireframeGeometry,
        "ParametricGeometry": THREE.ParametricGeometry,
        "ParametricBufferGeometry": THREE.ParametricBufferGeometry,
        "TetrahedronGeometry": THREE.TetrahedronGeometry,
        "TetrahedronBufferGeometry": THREE.TetrahedronBufferGeometry,
        "OctahedronGeometry": THREE.OctahedronGeometry,
        "OctahedronBufferGeometry": THREE.OctahedronBufferGeometry,
        "IcosahedronGeometry": THREE.IcosahedronGeometry,
        "IcosahedronBufferGeometry": THREE.IcosahedronBufferGeometry,
        "DodecahedronGeometry": THREE.DodecahedronGeometry,
        "DodecahedronBufferGeometry": THREE.DodecahedronBufferGeometry,
        "PolyhedronGeometry": THREE.PolyhedronGeometry,
        "PolyhedronBufferGeometry": THREE.PolyhedronBufferGeometry,
        "TubeGeometry": THREE.TubeGeometry,
        "TubeBufferGeometry": THREE.TubeBufferGeometry,
        "TorusKnotGeometry": THREE.TorusKnotGeometry,
        "TorusKnotBufferGeometry": THREE.TorusKnotBufferGeometry,
        "TorusGeometry": THREE.TorusGeometry,
        "TorusBufferGeometry": THREE.TorusBufferGeometry,
        "TextGeometry": THREE.TextGeometry,
        "TextBufferGeometry": THREE.TextBufferGeometry,
        "SphereGeometry": THREE.SphereGeometry,
        "SphereBufferGeometry": THREE.SphereBufferGeometry,
        "RingGeometry": THREE.RingGeometry,
        "RingBufferGeometry": THREE.RingBufferGeometry,
        "PlaneGeometry": THREE.PlaneGeometry,
        "PlaneBufferGeometry": THREE.PlaneBufferGeometry,
        "LatheGeometry": THREE.LatheGeometry,
        "LatheBufferGeometry": THREE.LatheBufferGeometry,
        "ShapeGeometry": THREE.ShapeGeometry,
        "ShapeBufferGeometry": THREE.ShapeBufferGeometry,
        "ExtrudeGeometry": THREE.ExtrudeGeometry,
        "ExtrudeBufferGeometry": THREE.ExtrudeBufferGeometry,
        "EdgesGeometry": THREE.EdgesGeometry,
        "ConeGeometry": THREE.ConeGeometry,
        "ConeBufferGeometry": THREE.ConeBufferGeometry,
        "CylinderGeometry": THREE.CylinderGeometry,
        "CylinderBufferGeometry": THREE.CylinderBufferGeometry,
        "CircleGeometry": THREE.CircleGeometry,
        "CircleBufferGeometry": THREE.CircleBufferGeometry,
        "BoxGeometry": THREE.BoxGeometry,
        "BoxBufferGeometry": THREE.BoxBufferGeometry
    };
})(THREE || (THREE = {}));
/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */
var THREE;
/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */
(function (THREE) {
    var lineGeometry, coneGeometry;
    class ArrowHelper extends THREE.Object3D {
        constructor(dir, origin, length, color, headLength, headWidth) {
            super();
            // dir is assumed to be normalized
            if (color === undefined)
                color = 0xffff00;
            if (length === undefined)
                length = 1;
            if (headLength === undefined)
                headLength = 0.2 * length;
            if (headWidth === undefined)
                headWidth = 0.2 * headLength;
            if (lineGeometry === undefined) {
                lineGeometry = new THREE.BufferGeometry();
                lineGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
                coneGeometry = new THREE.CylinderBufferGeometry(0, 0.5, 1, 5, 1, null, null, null);
                coneGeometry.translate(0, -0.5, 0);
            }
            this.position.copy(origin);
            this.line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({ color: color }));
            this.line.matrixAutoUpdate = false;
            this.add(this.line);
            this.cone = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({ color: color }));
            this.cone.matrixAutoUpdate = false;
            this.add(this.cone);
            this.setDirection(dir);
            this.setLength(length, headLength, headWidth);
        }
        setDirection(dir) {
            var axis = new THREE.Vector3();
            var radians;
            // dir is assumed to be normalized
            if (dir.y > 0.99999) {
                this.quaternion.set(0, 0, 0, 1);
            }
            else if (dir.y < -0.99999) {
                this.quaternion.set(1, 0, 0, 0);
            }
            else {
                axis.set(dir.z, 0, -dir.x).normalize();
                radians = Math.acos(dir.y);
                this.quaternion.setFromAxisAngle(axis, radians);
            }
        }
        ;
        setLength(length, headLength, headWidth) {
            if (headLength === undefined)
                headLength = 0.2 * length;
            if (headWidth === undefined)
                headWidth = 0.2 * headLength;
            this.line.scale.set(1, Math.max(0, length - headLength), 1);
            this.line.updateMatrix();
            this.cone.scale.set(headWidth, headLength, headWidth);
            this.cone.position.y = length;
            this.cone.updateMatrix();
        }
        ;
        setColor(color) {
            this.line.material.color.copy(color);
            this.cone.material.color.copy(color);
        }
        ;
    }
    THREE.ArrowHelper = ArrowHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Line extends THREE.Object3D {
        constructor(geometry, material, mode) {
            super();
            this.isLine = true;
            if (mode === 1) {
                console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');
                return new THREE.LineSegments(geometry, material);
            }
            this.type = 'Line';
            this.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();
            this.material = material !== undefined ? material : new THREE.LineBasicMaterial({ color: Math.random() * 0xffffff });
        }
        computeLineDistances() {
            //TODO:
            var start = new THREE.Vector3();
            var end = new THREE.Vector3();
            var geometry = this.geometry;
            if (geometry.isBufferGeometry) {
                // we assume non-indexed geometry
                if (geometry.index === null) {
                    var positionAttribute = geometry.attributes.position;
                    var lineDistances = [0];
                    for (var i = 1, l = positionAttribute.count; i < l; i++) {
                        start.fromBufferAttribute(positionAttribute, i - 1);
                        end.fromBufferAttribute(positionAttribute, i);
                        lineDistances[i] = lineDistances[i - 1];
                        lineDistances[i] += start.distanceTo(end);
                    }
                    geometry.addAttribute('lineDistance', new THREE.Float32BufferAttribute(lineDistances, 1));
                }
                else {
                    console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
                }
            }
            else if (geometry.isGeometry) {
                var vertices = geometry.vertices;
                var lineDistances_1 = geometry.lineDistances;
                lineDistances_1[0] = 0;
                for (var i = 1, l = vertices.length; i < l; i++) {
                    lineDistances_1[i] = lineDistances_1[i - 1];
                    lineDistances_1[i] += vertices[i - 1].distanceTo(vertices[i]);
                }
            }
            return this;
        }
        raycast(raycaster, intersects) {
            //TODO:  
            var inverseMatrix = new THREE.Matrix4();
            var ray = new THREE.Ray();
            var sphere = new THREE.Sphere();
            var precision = raycaster.linePrecision;
            var precisionSq = precision * precision;
            var geometry = this.geometry;
            var matrixWorld = this.matrixWorld;
            // Checking boundingSphere distance to ray
            if (geometry.boundingSphere === null)
                geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere);
            sphere.applyMatrix4(matrixWorld);
            if (raycaster.ray.intersectsSphere(sphere) === false)
                return;
            //
            inverseMatrix.getInverse(matrixWorld);
            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
            var vStart = new THREE.Vector3();
            var vEnd = new THREE.Vector3();
            var interSegment = new THREE.Vector3();
            var interRay = new THREE.Vector3();
            var step = (this && this.isLineSegments) ? 2 : 1;
            if (geometry.isBufferGeometry) {
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positions = attributes.position.array;
                if (index !== null) {
                    var indices = index.array;
                    for (var i = 0, l = indices.length - 1; i < l; i += step) {
                        var a = indices[i];
                        var b = indices[i + 1];
                        vStart.fromArray(positions, a * 3);
                        vEnd.fromArray(positions, b * 3);
                        var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                        if (distSq > precisionSq)
                            continue;
                        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                        var distance = raycaster.ray.origin.distanceTo(interRay);
                        if (distance < raycaster.near || distance > raycaster.far)
                            continue;
                        intersects.push({
                            distance: distance,
                            // What do we want? intersection point on the ray or on the segment??
                            // point: raycaster.ray.at( distance ),
                            point: interSegment.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
                        });
                    }
                }
                else {
                    for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
                        vStart.fromArray(positions, 3 * i);
                        vEnd.fromArray(positions, 3 * i + 3);
                        var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                        if (distSq > precisionSq)
                            continue;
                        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                        var distance = raycaster.ray.origin.distanceTo(interRay);
                        if (distance < raycaster.near || distance > raycaster.far)
                            continue;
                        intersects.push({
                            distance: distance,
                            // What do we want? intersection point on the ray or on the segment??
                            // point: raycaster.ray.at( distance ),
                            point: interSegment.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
                        });
                    }
                }
            }
            else if (geometry.isGeometry) {
                var vertices = geometry.vertices;
                var nbVertices = vertices.length;
                for (var i = 0; i < nbVertices - 1; i += step) {
                    var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                    if (distSq > precisionSq)
                        continue;
                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                    var distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far)
                        continue;
                    intersects.push({
                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            }
        }
        clone() {
            return new Line(this.geometry, this.material).copy(this);
        }
    }
    THREE.Line = Line;
})(THREE || (THREE = {}));
/// <reference path="./Line.ts" />
var THREE;
/// <reference path="./Line.ts" />
(function (THREE) {
    class LineSegments extends THREE.Line {
        constructor(geometry, material) {
            super(geometry, material);
            this.isLineSegments = true;
            this.type = 'LineSegments';
        }
        computeLineDistances() {
            //TODO:   
            var start = new THREE.Vector3();
            var end = new THREE.Vector3();
            var geometry = this.geometry;
            if (geometry.isBufferGeometry) {
                // we assume non-indexed geometry
                if (geometry.index === null) {
                    var positionAttribute = geometry.attributes.position;
                    var lineDistances = [];
                    for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
                        start.fromBufferAttribute(positionAttribute, i);
                        end.fromBufferAttribute(positionAttribute, i + 1);
                        lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1];
                        lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);
                    }
                    geometry.addAttribute('lineDistance', new THREE.Float32BufferAttribute(lineDistances, 1));
                }
                else {
                    console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
                }
            }
            else if (geometry.isGeometry) {
                var vertices = geometry.vertices;
                var lineDistances_1 = geometry.lineDistances;
                for (var i = 0, l = vertices.length; i < l; i += 2) {
                    start.copy(vertices[i]);
                    end.copy(vertices[i + 1]);
                    lineDistances_1[i] = (i === 0) ? 0 : lineDistances_1[i - 1];
                    lineDistances_1[i + 1] = lineDistances_1[i] + start.distanceTo(end);
                }
            }
            return this;
        }
        ;
    }
    THREE.LineSegments = LineSegments;
})(THREE || (THREE = {}));
/// <reference path="../objects/LineSegments.ts" />
var THREE;
/// <reference path="../objects/LineSegments.ts" />
(function (THREE) {
    class AxesHelper extends THREE.LineSegments {
        constructor(size) {
            super(null, null);
            size = size || 1;
            var vertices = [
                0, 0, 0, size, 0, 0,
                0, 0, 0, 0, size, 0,
                0, 0, 0, 0, 0, size
            ];
            var colors = [
                1, 0, 0, 1, 0.6, 0,
                0, 1, 0, 0.6, 1, 0,
                0, 0, 1, 0, 0.6, 1
            ];
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
            THREE.LineSegments.call(this, geometry, material);
        }
    }
    THREE.AxesHelper = AxesHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Box3Helper extends THREE.LineSegments {
        constructor(box, hex) {
            super(null, null);
            this.type = 'Box3Helper';
            this.box = box;
            var color = (hex !== undefined) ? hex : 0xffff00;
            var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
            var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
            var geometry = new THREE.BufferGeometry();
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            geometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({ color: color }));
            this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(force) {
            var box = this.box;
            if (box.isEmpty())
                return;
            box.getCenter(this.position);
            box.getSize(this.scale);
            this.scale.multiplyScalar(0.5);
            super.updateMatrixWorld(force);
        }
        ;
    }
    THREE.Box3Helper = Box3Helper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class BoxHelper extends THREE.LineSegments {
        constructor(object, color) {
            super(null, null);
            this.object = object;
            if (color === undefined)
                color = 0xffff00;
            var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
            var positions = new Float32Array(8 * 3);
            var geometry = new THREE.BufferGeometry();
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
            THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({ color: color }));
            this.matrixAutoUpdate = false;
            this.update(null);
        }
        update(object) {
            var box = new THREE.Box3();
            if (object !== undefined) {
                console.warn('THREE.BoxHelper: .update() has no longer arguments.');
            }
            if (this.object !== undefined) {
                box.setFromObject(this.object);
            }
            if (box.isEmpty())
                return;
            var min = box.min;
            var max = box.max;
            /*
              5____4
            1/___0/|
            | 6__|_7
            2/___3/
      
            0: max.x, max.y, max.z
            1: min.x, max.y, max.z
            2: min.x, min.y, max.z
            3: max.x, min.y, max.z
            4: max.x, max.y, min.z
            5: min.x, max.y, min.z
            6: min.x, min.y, min.z
            7: max.x, min.y, min.z
            */
            var position = this.geometry.attributes.position;
            var array = position.array;
            array[0] = max.x;
            array[1] = max.y;
            array[2] = max.z;
            array[3] = min.x;
            array[4] = max.y;
            array[5] = max.z;
            array[6] = min.x;
            array[7] = min.y;
            array[8] = max.z;
            array[9] = max.x;
            array[10] = min.y;
            array[11] = max.z;
            array[12] = max.x;
            array[13] = max.y;
            array[14] = min.z;
            array[15] = min.x;
            array[16] = max.y;
            array[17] = min.z;
            array[18] = min.x;
            array[19] = min.y;
            array[20] = min.z;
            array[21] = max.x;
            array[22] = min.y;
            array[23] = min.z;
            position.needsUpdate = true;
            this.geometry.computeBoundingSphere();
        }
        ;
        setFromObject(object) {
            this.object = object;
            this.update(null);
            return this;
        }
        ;
    }
    THREE.BoxHelper = BoxHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class CameraHelper extends THREE.LineSegments {
        constructor(camera) {
            super(null, null);
            var geometry = new THREE.BufferGeometry();
            var material = new THREE.LineBasicMaterial({ color: 0xffffff, vertexColors: THREE.FaceColors });
            var vertices = [];
            var colors = [];
            var pointMap = {};
            // colors
            var colorFrustum = new THREE.Color(0xffaa00);
            var colorCone = new THREE.Color(0xff0000);
            var colorUp = new THREE.Color(0x00aaff);
            var colorTarget = new THREE.Color(0xffffff);
            var colorCross = new THREE.Color(0x333333);
            // near
            addLine('n1', 'n2', colorFrustum);
            addLine('n2', 'n4', colorFrustum);
            addLine('n4', 'n3', colorFrustum);
            addLine('n3', 'n1', colorFrustum);
            // far
            addLine('f1', 'f2', colorFrustum);
            addLine('f2', 'f4', colorFrustum);
            addLine('f4', 'f3', colorFrustum);
            addLine('f3', 'f1', colorFrustum);
            // sides
            addLine('n1', 'f1', colorFrustum);
            addLine('n2', 'f2', colorFrustum);
            addLine('n3', 'f3', colorFrustum);
            addLine('n4', 'f4', colorFrustum);
            // cone
            addLine('p', 'n1', colorCone);
            addLine('p', 'n2', colorCone);
            addLine('p', 'n3', colorCone);
            addLine('p', 'n4', colorCone);
            // up
            addLine('u1', 'u2', colorUp);
            addLine('u2', 'u3', colorUp);
            addLine('u3', 'u1', colorUp);
            // target
            addLine('c', 't', colorTarget);
            addLine('p', 'c', colorCross);
            // cross
            addLine('cn1', 'cn2', colorCross);
            addLine('cn3', 'cn4', colorCross);
            addLine('cf1', 'cf2', colorCross);
            addLine('cf3', 'cf4', colorCross);
            function addLine(a, b, color) {
                addPoint(a, color);
                addPoint(b, color);
            }
            function addPoint(id, color) {
                vertices.push(0, 0, 0);
                colors.push(color.r, color.g, color.b);
                if (pointMap[id] === undefined) {
                    pointMap[id] = [];
                }
                pointMap[id].push((vertices.length / 3) - 1);
            }
            geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            THREE.LineSegments.call(this, geometry, material);
            this.camera = camera;
            if (this.camera.updateProjectionMatrix)
                this.camera.updateProjectionMatrix();
            this.matrix = camera.matrixWorld;
            this.matrixAutoUpdate = false;
            this.pointMap = pointMap;
            this.update();
        }
        update() {
            var geometry, pointMap;
            var vector = new THREE.Vector3();
            var camera = new THREE.Camera();
            function setPoint(point, x, y, z) {
                vector.set(x, y, z).unproject(camera);
                var points = pointMap[point];
                if (points !== undefined) {
                    var position = geometry.getAttribute('position');
                    for (var i = 0, l = points.length; i < l; i++) {
                        position.setXYZ(points[i], vector.x, vector.y, vector.z);
                    }
                }
            }
            geometry = this.geometry;
            pointMap = this.pointMap;
            var w = 1, h = 1;
            // we need just camera projection matrix
            // world matrix must be identity
            camera.projectionMatrix.copy(this.camera.projectionMatrix);
            // center / target
            setPoint('c', 0, 0, -1);
            setPoint('t', 0, 0, 1);
            // near
            setPoint('n1', -w, -h, -1);
            setPoint('n2', w, -h, -1);
            setPoint('n3', -w, h, -1);
            setPoint('n4', w, h, -1);
            // far
            setPoint('f1', -w, -h, 1);
            setPoint('f2', w, -h, 1);
            setPoint('f3', -w, h, 1);
            setPoint('f4', w, h, 1);
            // up
            setPoint('u1', w * 0.7, h * 1.1, -1);
            setPoint('u2', -w * 0.7, h * 1.1, -1);
            setPoint('u3', 0, h * 2, -1);
            // cross
            setPoint('cf1', -w, 0, 1);
            setPoint('cf2', w, 0, 1);
            setPoint('cf3', 0, -h, 1);
            setPoint('cf4', 0, h, 1);
            setPoint('cn1', -w, 0, -1);
            setPoint('cn2', w, 0, -1);
            setPoint('cn3', 0, -h, -1);
            setPoint('cn4', 0, h, -1);
            geometry.getAttribute('position').needsUpdate = true;
        }
        ;
    }
    THREE.CameraHelper = CameraHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class DirectionalLightHelper extends THREE.Object3D {
        constructor(light, size, color) {
            super();
            this.light = light;
            this.light.updateMatrixWorld();
            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;
            this.color = color;
            if (size === undefined)
                size = 1;
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute('position', new THREE.Float32BufferAttribute([
                -size, size, 0,
                size, size, 0,
                size, -size, 0,
                -size, -size, 0,
                -size, size, 0
            ], 3));
            var material = new THREE.LineBasicMaterial({ fog: false });
            this.lightPlane = new THREE.Line(geometry, material);
            this.add(this.lightPlane);
            geometry = new THREE.BufferGeometry();
            geometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
            this.targetLine = new THREE.Line(geometry, material);
            this.add(this.targetLine);
            this.update();
        }
        dispose() {
            this.lightPlane.geometry.dispose();
            this.lightPlane.material.dispose();
            this.targetLine.geometry.dispose();
            this.targetLine.material.dispose();
        }
        ;
        update() {
            var v1 = new THREE.Vector3();
            var v2 = new THREE.Vector3();
            var v3 = new THREE.Vector3();
            v1.setFromMatrixPosition(this.light.matrixWorld);
            v2.setFromMatrixPosition(this.light.target.matrixWorld);
            v3.subVectors(v2, v1);
            this.lightPlane.lookAt(v3);
            if (this.color !== undefined) {
                this.lightPlane.material.color.set(this.color);
                this.targetLine.material.color.set(this.color);
            }
            else {
                this.lightPlane.material.color.copy(this.light.color);
                this.targetLine.material.color.copy(this.light.color);
            }
            this.targetLine.lookAt(v3);
            this.targetLine.scale.z = v3.length();
        }
        ;
    }
    THREE.DirectionalLightHelper = DirectionalLightHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class FaceNormalsHelper extends THREE.LineSegments {
        constructor(object, size, hex, linewidth) {
            super(null, null);
            // FaceNormalsHelper only supports THREE.Geometry
            this.object = object;
            this.size = (size !== undefined) ? size : 1;
            var color = (hex !== undefined) ? hex : 0xffff00;
            var width = (linewidth !== undefined) ? linewidth : 1;
            //
            var nNormals = 0;
            var objGeometry = this.object.geometry;
            if (objGeometry && objGeometry.isGeometry) {
                nNormals = objGeometry.faces.length;
            }
            else {
                console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
            }
            //
            var geometry = new THREE.BufferGeometry();
            var positions = new THREE.Float32BufferAttribute(nNormals * 2 * 3, 3);
            geometry.addAttribute('position', positions);
            THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({ color: color, linewidth: width }));
            //
            this.matrixAutoUpdate = false;
            this.update();
        }
        update() {
            var v1 = new THREE.Vector3();
            var v2 = new THREE.Vector3();
            var normalMatrix = new THREE.Matrix3();
            this.object.updateMatrixWorld(true);
            normalMatrix.getNormalMatrix(this.object.matrixWorld);
            var matrixWorld = this.object.matrixWorld;
            var position = this.geometry.attributes.position;
            //
            var objGeometry = this.object.geometry;
            var vertices = objGeometry.vertices;
            var faces = objGeometry.faces;
            var idx = 0;
            for (var i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                var normal = face.normal;
                v1.copy(vertices[face.a])
                    .add(vertices[face.b])
                    .add(vertices[face.c])
                    .divideScalar(3)
                    .applyMatrix4(matrixWorld);
                v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                position.setXYZ(idx, v1.x, v1.y, v1.z);
                idx = idx + 1;
                position.setXYZ(idx, v2.x, v2.y, v2.z);
                idx = idx + 1;
            }
            position.needsUpdate = true;
        }
        ;
    }
    THREE.FaceNormalsHelper = FaceNormalsHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class GridHelper extends THREE.LineSegments {
        constructor(size, divisions, color1, color2) {
            super(null, null);
            size = size || 10;
            divisions = divisions || 10;
            color1 = new THREE.Color(color1 !== undefined ? color1 : 0x444444);
            color2 = new THREE.Color(color2 !== undefined ? color2 : 0x888888);
            var center = divisions / 2;
            var step = size / divisions;
            var halfSize = size / 2;
            var vertices = [], colors = [];
            for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
                vertices.push(-halfSize, 0, k, halfSize, 0, k);
                vertices.push(k, 0, -halfSize, k, 0, halfSize);
                var color = i === center ? color1 : color2;
                color.toArray(colors, j);
                j += 3;
                color.toArray(colors, j);
                j += 3;
                color.toArray(colors, j);
                j += 3;
                color.toArray(colors, j);
                j += 3;
            }
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
            THREE.LineSegments.call(this, geometry, material);
        }
    }
    THREE.GridHelper = GridHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class HemisphereLightHelper extends THREE.Object3D {
        constructor(light, size, color) {
            super();
            this.light = light;
            this.light.updateMatrixWorld();
            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;
            this.color = color;
            var geometry = new THREE.OctahedronBufferGeometry(size, null);
            geometry.rotateY(Math.PI * 0.5);
            this.material = new THREE.MeshBasicMaterial({ wireframe: true, fog: false });
            if (this.color === undefined)
                this.material.vertexColors = THREE.VertexColors;
            var position = geometry.getAttribute('position');
            var colors = new Float32Array(position.count * 3);
            geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
            this.add(new THREE.Mesh(geometry, this.material));
            this.update();
        }
        dispose() {
            this.children[0].geometry.dispose();
            this.children[0].material.dispose();
        }
        ;
        update() {
            var vector = new THREE.Vector3();
            var color1 = new THREE.Color(null);
            var color2 = new THREE.Color(null);
            var mesh = this.children[0];
            if (this.color !== undefined) {
                this.material.color.set(this.color);
            }
            else {
                var colors = mesh.geometry.getAttribute('color');
                color1.copy(this.light.color);
                color2.copy(this.light.groundColor);
                for (var i = 0, l = colors.count; i < l; i++) {
                    var color = (i < (l / 2)) ? color1 : color2;
                    colors.setXYZ(i, color.r, color.g, color.b);
                }
                colors.needsUpdate = true;
            }
            mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
        ;
    }
    THREE.HemisphereLightHelper = HemisphereLightHelper;
})(THREE || (THREE = {}));
/// <reference path="../objects/Line.ts" />
var THREE;
/// <reference path="../objects/Line.ts" />
(function (THREE) {
    class PlaneHelper extends THREE.Line {
        constructor(plane, size, hex) {
            super();
            this.type = 'PlaneHelper';
            this.plane = plane;
            this.size = (size === undefined) ? 1 : size;
            var color = (hex !== undefined) ? hex : 0xffff00;
            var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.computeBoundingSphere();
            THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({ color: color }));
            //
            var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
            var geometry2 = new THREE.BufferGeometry();
            geometry2.addAttribute('position', new THREE.Float32BufferAttribute(positions2, 3));
            geometry2.computeBoundingSphere();
            this.add(new THREE.Mesh(geometry2, new THREE.MeshBasicMaterial({ color: color, opacity: 0.2, transparent: true, depthWrite: false })));
        }
        updateMatrixWorld(force) {
            var scale = -this.plane.constant;
            if (Math.abs(scale) < 1e-8)
                scale = 1e-8; // sign does not matter
            this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
            this.children[0].material.side = (scale < 0) ? THREE.BackSide : THREE.FrontSide; // renderer flips side when determinant < 0; flipping not wanted here
            this.lookAt(this.plane.normal);
            super.updateMatrixWorld(force);
        }
        ;
    }
    THREE.PlaneHelper = PlaneHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Mesh extends THREE.Object3D {
        constructor(geometry, material) {
            super();
            this.isMesh = true;
            this.type = 'Mesh';
            this.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();
            this.material = material !== undefined ? material : new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
            this.drawMode = THREE.TrianglesDrawMode;
            this.updateMorphTargets();
        }
        setDrawMode(value) {
            this.drawMode = value;
        }
        copy(source) {
            //Object3D.prototype.copy.call(this, source);
            super.copy(source);
            this.drawMode = source.drawMode;
            if (source.morphTargetInfluences !== undefined) {
                this.morphTargetInfluences = source.morphTargetInfluences.slice();
            }
            if (source.morphTargetDictionary !== undefined) {
                this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
            }
            return this;
        }
        updateMorphTargets() {
            var geometry = this.geometry;
            var m, ml, name;
            if (geometry.isBufferGeometry) {
                var morphAttributes = geometry.morphAttributes;
                var keys = Object.keys(morphAttributes);
                if (keys.length > 0) {
                    var morphAttribute = morphAttributes[keys[0]];
                    if (morphAttribute !== undefined) {
                        this.morphTargetInfluences = [];
                        this.morphTargetDictionary = {};
                        for (m = 0, ml = morphAttribute.length; m < ml; m++) {
                            name = morphAttribute[m].name || String(m);
                            this.morphTargetInfluences.push(0);
                            this.morphTargetDictionary[name] = m;
                        }
                    }
                }
            }
            else {
                var morphTargets = geometry.morphTargets;
                if (morphTargets !== undefined && morphTargets.length > 0) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for (m = 0, ml = morphTargets.length; m < ml; m++) {
                        name = morphTargets[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        }
        raycast(raycaster, intersects) {
            var inverseMatrix = new THREE.Matrix4();
            var ray = new THREE.Ray();
            var sphere = new THREE.Sphere();
            var vA = new THREE.Vector3();
            var vB = new THREE.Vector3();
            var vC = new THREE.Vector3();
            var tempA = new THREE.Vector3();
            var tempB = new THREE.Vector3();
            var tempC = new THREE.Vector3();
            var uvA = new THREE.Vector2();
            var uvB = new THREE.Vector2();
            var uvC = new THREE.Vector2();
            var barycoord = new THREE.Vector3();
            var intersectionPoint = new THREE.Vector3();
            var intersectionPointWorld = new THREE.Vector3();
            function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
                THREE.Triangle.getBarycoord(point, p1, p2, p3, barycoord);
                uv1.multiplyScalar(barycoord.x);
                uv2.multiplyScalar(barycoord.y);
                uv3.multiplyScalar(barycoord.z);
                uv1.add(uv2).add(uv3);
                return uv1.clone();
            }
            function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
                var intersect;
                if (material.side === THREE.BackSide) {
                    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
                }
                else {
                    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== THREE.DoubleSide, point);
                }
                if (intersect === null)
                    return null;
                intersectionPointWorld.copy(point);
                intersectionPointWorld.applyMatrix4(object.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
                if (distance < raycaster.near || distance > raycaster.far)
                    return null;
                return {
                    distance: distance,
                    point: intersectionPointWorld.clone(),
                    object: object
                };
            }
            function checkBufferGeometryIntersection(object, raycaster, ray, position, uv, a, b, c) {
                vA.fromBufferAttribute(position, a);
                vB.fromBufferAttribute(position, b);
                vC.fromBufferAttribute(position, c);
                var intersection = checkIntersection(object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint);
                if (intersection) {
                    if (uv) {
                        uvA.fromBufferAttribute(uv, a);
                        uvB.fromBufferAttribute(uv, b);
                        uvC.fromBufferAttribute(uv, c);
                        intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
                    }
                    var face = new THREE.Face3(a, b, c);
                    THREE.Triangle.getNormal(vA, vB, vC, face.normal);
                    intersection.face = face;
                }
                return intersection;
            }
            var geometry = this.geometry;
            var material = this.material;
            var matrixWorld = this.matrixWorld;
            if (material === undefined)
                return;
            // Checking boundingSphere distance to ray
            if (geometry.boundingSphere === null)
                geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere);
            sphere.applyMatrix4(matrixWorld);
            if (raycaster.ray.intersectsSphere(sphere) === false)
                return;
            //
            inverseMatrix.getInverse(matrixWorld);
            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
            // Check boundingBox before continuing
            if (geometry.boundingBox !== null) {
                if (ray.intersectsBox(geometry.boundingBox) === false)
                    return;
            }
            var intersection;
            if (geometry.isBufferGeometry) {
                var a, b, c;
                var index = geometry.index;
                var position = geometry.attributes.position;
                var uv = geometry.attributes.uv;
                var i, l;
                if (index !== null) {
                    // indexed buffer geometry
                    for (i = 0, l = index.count; i < l; i += 3) {
                        a = index.getX(i);
                        b = index.getX(i + 1);
                        c = index.getX(i + 2);
                        intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics
                            intersects.push(intersection);
                        }
                    }
                }
                else if (position !== undefined) {
                    // non-indexed buffer geometry
                    for (i = 0, l = position.count; i < l; i += 3) {
                        a = i;
                        b = i + 1;
                        c = i + 2;
                        intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics
                            intersects.push(intersection);
                        }
                    }
                }
            }
            else if (geometry.isGeometry) {
                var fvA, fvB, fvC;
                var isMultiMaterial = Array.isArray(material);
                var vertices = geometry.vertices;
                var faces = geometry.faces;
                var uvs;
                var faceVertexUvs = geometry.faceVertexUvs[0];
                if (faceVertexUvs.length > 0)
                    uvs = faceVertexUvs;
                for (var f = 0, fl = faces.length; f < fl; f++) {
                    var face = faces[f];
                    var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
                    if (faceMaterial === undefined)
                        continue;
                    fvA = vertices[face.a];
                    fvB = vertices[face.b];
                    fvC = vertices[face.c];
                    if (faceMaterial.morphTargets === true) {
                        var morphTargets = geometry.morphTargets;
                        var morphInfluences = this.morphTargetInfluences;
                        vA.set(0, 0, 0);
                        vB.set(0, 0, 0);
                        vC.set(0, 0, 0);
                        for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                            var influence = morphInfluences[t];
                            if (influence === 0)
                                continue;
                            var targets = morphTargets[t].vertices;
                            vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                            vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                            vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
                        }
                        vA.add(fvA);
                        vB.add(fvB);
                        vC.add(fvC);
                        fvA = vA;
                        fvB = vB;
                        fvC = vC;
                    }
                    intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
                    if (intersection) {
                        if (uvs && uvs[f]) {
                            var uvs_f = uvs[f];
                            uvA.copy(uvs_f[0]);
                            uvB.copy(uvs_f[1]);
                            uvC.copy(uvs_f[2]);
                            intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
                        }
                        intersection.face = face;
                        intersection.faceIndex = f;
                        intersects.push(intersection);
                    }
                }
            }
        }
        clone() {
            return new Mesh(this.geometry, this.material).copy(this);
        }
    }
    THREE.Mesh = Mesh;
})(THREE || (THREE = {}));
/// <reference path="../objects/Mesh.ts" />
var THREE;
/// <reference path="../objects/Mesh.ts" />
(function (THREE) {
    class PointLightHelper extends THREE.Mesh {
        constructor(light, sphereSize, color) {
            super(null, null);
            this.light = light;
            this.light.updateMatrixWorld();
            this.color = color;
            var geometry = new THREE.SphereBufferGeometry(sphereSize, 4, 2, null, null, null, null);
            var material = new THREE.MeshBasicMaterial({ wireframe: true, fog: false });
            THREE.Mesh.call(this, geometry, material);
            this.matrix = this.light.matrixWorld;
            this.matrixAutoUpdate = false;
            this.update();
        }
        dispose() {
            this.geometry.dispose();
            this.material.dispose();
        }
        ;
        update() {
            if (this.color !== undefined) {
                this.material.color.set(this.color);
            }
            else {
                this.material.color.copy(this.light.color);
            }
        }
        ;
    }
    THREE.PointLightHelper = PointLightHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class PolarGridHelper extends THREE.LineSegments {
        constructor(radius, radials, circles, divisions, color1, color2) {
            super(null, null);
            radius = radius || 10;
            radials = radials || 16;
            circles = circles || 8;
            divisions = divisions || 64;
            color1 = new THREE.Color(color1 !== undefined ? color1 : 0x444444);
            color2 = new THREE.Color(color2 !== undefined ? color2 : 0x888888);
            var vertices = [];
            var colors = [];
            var x, z;
            var v, i, j, r, color;
            // create the radials
            for (i = 0; i <= radials; i++) {
                v = (i / radials) * (Math.PI * 2);
                x = Math.sin(v) * radius;
                z = Math.cos(v) * radius;
                vertices.push(0, 0, 0);
                vertices.push(x, 0, z);
                color = (i & 1) ? color1 : color2;
                colors.push(color.r, color.g, color.b);
                colors.push(color.r, color.g, color.b);
            }
            // create the circles
            for (i = 0; i <= circles; i++) {
                color = (i & 1) ? color1 : color2;
                r = radius - (radius / circles * i);
                for (j = 0; j < divisions; j++) {
                    // first vertex
                    v = (j / divisions) * (Math.PI * 2);
                    x = Math.sin(v) * r;
                    z = Math.cos(v) * r;
                    vertices.push(x, 0, z);
                    colors.push(color.r, color.g, color.b);
                    // second vertex
                    v = ((j + 1) / divisions) * (Math.PI * 2);
                    x = Math.sin(v) * r;
                    z = Math.cos(v) * r;
                    vertices.push(x, 0, z);
                    colors.push(color.r, color.g, color.b);
                }
            }
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
            THREE.LineSegments.call(this, geometry, material);
        }
    }
    THREE.PolarGridHelper = PolarGridHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class RectAreaLightHelper extends THREE.Object3D {
        constructor(light, color) {
            super();
            this.light = light;
            this.light.updateMatrixWorld();
            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;
            this.color = color;
            var material = new THREE.LineBasicMaterial({ fog: false });
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(5 * 3), 3));
            this.line = new THREE.Line(geometry, material);
            this.add(this.line);
            this.update();
        }
        dispose() {
            this.children[0].geometry.dispose();
            this.children[0].material.dispose();
        }
        ;
        update() {
            // calculate new dimensions of the helper
            var hx = this.light.width * 0.5;
            var hy = this.light.height * 0.5;
            var position = this.line.geometry.attributes.position;
            var array = position.array;
            // update vertices
            array[0] = hx;
            array[1] = -hy;
            array[2] = 0;
            array[3] = hx;
            array[4] = hy;
            array[5] = 0;
            array[6] = -hx;
            array[7] = hy;
            array[8] = 0;
            array[9] = -hx;
            array[10] = -hy;
            array[11] = 0;
            array[12] = hx;
            array[13] = -hy;
            array[14] = 0;
            position.needsUpdate = true;
            if (this.color !== undefined) {
                this.line.material.color.set(this.color);
            }
            else {
                this.line.material.color.copy(this.light.color);
            }
        }
        ;
    }
    THREE.RectAreaLightHelper = RectAreaLightHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    function getBoneList(object) {
        var boneList = [];
        if (object && object.isBone) {
            boneList.push(object);
        }
        for (var i = 0; i < object.children.length; i++) {
            boneList.push.apply(boneList, getBoneList(object.children[i]));
        }
        return boneList;
    }
    class SkeletonHelper extends THREE.LineSegments {
        constructor(object) {
            super(null, null);
            var bones = getBoneList(object);
            var geometry = new THREE.BufferGeometry();
            var vertices = [];
            var colors = [];
            var color1 = new THREE.Color(0, 0, 1);
            var color2 = new THREE.Color(0, 1, 0);
            for (var i = 0; i < bones.length; i++) {
                var bone = bones[i];
                if (bone.parent && bone.parent.isBone) {
                    vertices.push(0, 0, 0);
                    vertices.push(0, 0, 0);
                    colors.push(color1.r, color1.g, color1.b);
                    colors.push(color2.r, color2.g, color2.b);
                }
            }
            geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true });
            THREE.LineSegments.call(this, geometry, material);
            this.root = object;
            this.bones = bones;
            this.matrix = object.matrixWorld;
            this.matrixAutoUpdate = false;
        }
        updateMatrixWorld(force) {
            var vector = new THREE.Vector3();
            var boneMatrix = new THREE.Matrix4();
            var matrixWorldInv = new THREE.Matrix4();
            var bones = this.bones;
            var geometry = this.geometry;
            var position = geometry.getAttribute('position');
            matrixWorldInv.getInverse(this.root.matrixWorld);
            for (var i = 0, j = 0; i < bones.length; i++) {
                var bone = bones[i];
                if (bone.parent && bone.parent.isBone) {
                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
                    vector.setFromMatrixPosition(boneMatrix);
                    position.setXYZ(j, vector.x, vector.y, vector.z);
                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
                    vector.setFromMatrixPosition(boneMatrix);
                    position.setXYZ(j + 1, vector.x, vector.y, vector.z);
                    j += 2;
                }
            }
            geometry.getAttribute('position').needsUpdate = true;
            super.updateMatrixWorld(force);
        }
        ;
    }
    THREE.SkeletonHelper = SkeletonHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class SpotLightHelper extends THREE.Object3D {
        constructor(light, color) {
            super();
            this.light = light;
            this.light.updateMatrixWorld();
            this.matrix = light.matrixWorld;
            this.matrixAutoUpdate = false;
            this.color = color;
            var geometry = new THREE.BufferGeometry();
            var positions = [
                0, 0, 0, 0, 0, 1,
                0, 0, 0, 1, 0, 1,
                0, 0, 0, -1, 0, 1,
                0, 0, 0, 0, 1, 1,
                0, 0, 0, 0, -1, 1
            ];
            for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
                var p1 = (i / l) * Math.PI * 2;
                var p2 = (j / l) * Math.PI * 2;
                positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
            }
            geometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            var material = new THREE.LineBasicMaterial({ fog: false });
            this.cone = new THREE.LineSegments(geometry, material);
            this.add(this.cone);
            this.update();
        }
        dispose() {
            this.cone.geometry.dispose();
            this.cone.material.dispose();
        }
        ;
        update() {
            var vector = new THREE.Vector3();
            var vector2 = new THREE.Vector3();
            this.light.updateMatrixWorld();
            var coneLength = this.light.distance ? this.light.distance : 1000;
            var coneWidth = coneLength * Math.tan(this.light.angle);
            this.cone.scale.set(coneWidth, coneWidth, coneLength);
            vector.setFromMatrixPosition(this.light.matrixWorld);
            vector2.setFromMatrixPosition(this.light.target.matrixWorld);
            this.cone.lookAt(vector2.sub(vector));
            if (this.color !== undefined) {
                this.cone.material.color.set(this.color);
            }
            else {
                this.cone.material.color.copy(this.light.color);
            }
        }
        ;
    }
    THREE.SpotLightHelper = SpotLightHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class VertexNormalsHelper extends THREE.LineSegments {
        constructor(object, size, hex, linewidth) {
            super(null, null);
            this.object = object;
            this.size = (size !== undefined) ? size : 1;
            var color = (hex !== undefined) ? hex : 0xff0000;
            var width = (linewidth !== undefined) ? linewidth : 1;
            //
            var nNormals = 0;
            var objGeometry = this.object.geometry;
            if (objGeometry && objGeometry.isGeometry) {
                nNormals = objGeometry.faces.length * 3;
            }
            else if (objGeometry && objGeometry.isBufferGeometry) {
                nNormals = objGeometry.attributes.normal.count;
            }
            //
            var geometry = new THREE.BufferGeometry();
            var positions = new THREE.Float32BufferAttribute(nNormals * 2 * 3, 3);
            geometry.addAttribute('position', positions);
            THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({ color: color, linewidth: width }));
            //
            this.matrixAutoUpdate = false;
            this.update();
        }
        update() {
            var v1 = new THREE.Vector3();
            var v2 = new THREE.Vector3();
            var normalMatrix = new THREE.Matrix3();
            var keys = ['a', 'b', 'c'];
            this.object.updateMatrixWorld(true);
            normalMatrix.getNormalMatrix(this.object.matrixWorld);
            var matrixWorld = this.object.matrixWorld;
            var position = this.geometry.attributes.position;
            //
            var objGeometry = this.object.geometry;
            if (objGeometry && objGeometry.isGeometry) {
                var vertices = objGeometry.vertices;
                var faces = objGeometry.faces;
                var idx = 0;
                for (var i = 0, l = faces.length; i < l; i++) {
                    var face = faces[i];
                    for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                        var vertex = vertices[face[keys[j]]];
                        var normal = face.vertexNormals[j];
                        v1.copy(vertex).applyMatrix4(matrixWorld);
                        v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                        position.setXYZ(idx, v1.x, v1.y, v1.z);
                        idx = idx + 1;
                        position.setXYZ(idx, v2.x, v2.y, v2.z);
                        idx = idx + 1;
                    }
                }
            }
            else if (objGeometry && objGeometry.isBufferGeometry) {
                var objPos = objGeometry.attributes.position;
                var objNorm = objGeometry.attributes.normal;
                var idx = 0;
                // for simplicity, ignore index and drawcalls, and render every normal
                for (var j = 0, jl = objPos.count; j < jl; j++) {
                    v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
                    v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
                    v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                    position.setXYZ(idx, v1.x, v1.y, v1.z);
                    idx = idx + 1;
                    position.setXYZ(idx, v2.x, v2.y, v2.z);
                    idx = idx + 1;
                }
            }
            position.needsUpdate = true;
        }
        ;
    }
    THREE.VertexNormalsHelper = VertexNormalsHelper;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Light extends THREE.Object3D {
        constructor(color, intensity) {
            super();
            this.type = 'Light';
            this.color = new THREE.Color(color);
            this.intensity = intensity !== undefined ? intensity : 1;
            this.receiveShadow = undefined;
            this.isLight = true;
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            this.intensity = source.intensity;
            return this;
        }
        toJSON(meta) {
            var data = super.toJSON(meta);
            data.object.color = this.color.getHex();
            data.object.intensity = this.intensity;
            if (this.groundColor !== undefined)
                data.object.groundColor = this.groundColor.getHex();
            if (this.distance !== undefined)
                data.object.distance = this.distance;
            if (this.angle !== undefined)
                data.object.angle = this.angle;
            if (this.decay !== undefined)
                data.object.decay = this.decay;
            if (this.penumbra !== undefined)
                data.object.penumbra = this.penumbra;
            if (this.shadow !== undefined)
                data.object.shadow = this.shadow.toJSON();
            return data;
        }
    }
    THREE.Light = Light;
})(THREE || (THREE = {}));
/// <reference path="./Light.ts" />
var THREE;
/// <reference path="./Light.ts" />
(function (THREE) {
    class AmbientLight extends THREE.Light {
        constructor(color, intensity) {
            super(color, intensity);
            this.type = 'AmbientLight';
            this.castShadow = undefined;
            this.isAmbientLight = true;
        }
    }
    THREE.AmbientLight = AmbientLight;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class DirectionalLight extends THREE.Light {
        constructor(color, intensity) {
            super(color, intensity);
            this.type = 'DirectionalLight';
            this.position.copy(THREE.Object3D.DefaultUp);
            this.updateMatrix();
            this.target = new THREE.Object3D();
            this.shadow = new THREE.DirectionalLightShadow();
            this.isDirectionalLight = true;
        }
        copy(source) {
            super.copy(source);
            this.target = source.target.clone();
            this.shadow = source.shadow.clone();
            return this;
        }
    }
    THREE.DirectionalLight = DirectionalLight;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class LightShadow {
        constructor(camera) {
            this.camera = camera;
            this.bias = 0;
            this.radius = 1;
            this.mapSize = new THREE.Vector2(512, 512);
            this.map = null;
            this.matrix = new THREE.Matrix4();
        }
        copy(source) {
            this.camera = source.camera.clone();
            this.bias = source.bias;
            this.radius = source.radius;
            this.mapSize.copy(source.mapSize);
            return this;
        }
        clone() {
            var lightShaow = new LightShadow(null);
            lightShaow.copy(this);
            return lightShaow;
        }
        toJSON() {
            var object = {};
            if (this.bias !== 0)
                object.bias = this.bias;
            if (this.radius !== 1)
                object.radius = this.radius;
            if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
                object.mapSize = this.mapSize.toArray();
            object.camera = this.camera.toJSON(false).object;
            delete object.camera.matrix;
            return object;
        }
    }
    THREE.LightShadow = LightShadow;
})(THREE || (THREE = {}));
/// <reference path="./LightShadow.ts" />
var THREE;
/// <reference path="./LightShadow.ts" />
(function (THREE) {
    class DirectionalLightShadow extends THREE.LightShadow {
        constructor() {
            super(new THREE.OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
        }
    }
    THREE.DirectionalLightShadow = DirectionalLightShadow;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class HemisphereLight extends THREE.Light {
        constructor(skyColor, groundColor, intensity) {
            super(skyColor, intensity);
            this.type = 'HemisphereLight';
            this.castShadow = undefined;
            this.position.copy(THREE.Object3D.DefaultUp);
            this.updateMatrix();
            this.groundColor = new THREE.Color(groundColor);
            this.isHemisphereLight = true;
        }
        copy(source) {
            super.copy(source);
            this.groundColor.copy(source.groundColor);
            return this;
        }
    }
    THREE.HemisphereLight = HemisphereLight;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class PointLight extends THREE.Light {
        constructor(color, intensity, distance, decay) {
            super(color, intensity);
            this.type = 'PointLight';
            this.distance = (distance !== undefined) ? distance : 0;
            this.decay = (decay !== undefined) ? decay : 1; // for physically correct lights, should be 2.
            this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(90, 1, 0.5, 500));
            this.isPointLight = true;
        }
        get power() {
            return this.intensity * 4 * Math.PI;
        }
        set power(value) {
            // this.power = value;
        }
        copy(source) {
            super.copy(source);
            this.distance = source.distance;
            this.decay = source.decay;
            this.shadow = source.shadow.clone();
            return this;
        }
    }
    THREE.PointLight = PointLight;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class RectAreaLight extends THREE.Light {
        constructor(color, intensity, width, height) {
            super(color, intensity);
            this.type = 'RectAreaLight';
            this.width = (width !== undefined) ? width : 10;
            this.height = (height !== undefined) ? height : 10;
            this.isRectAreaLight = true;
        }
        copy(source) {
            super.copy(source);
            this.width = source.width;
            this.height = source.height;
            return this;
        }
        toJSON(meta) {
            var data = super.toJSON(meta);
            data.object.width = this.width;
            data.object.height = this.height;
            return data;
        }
    }
    THREE.RectAreaLight = RectAreaLight;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class SpotLight extends THREE.Light {
        constructor(color, intensity, distance, angle, penumbra, decay) {
            super(color, intensity);
            this.type = 'SpotLight';
            this.position.copy(THREE.Object3D.DefaultUp);
            this.updateMatrix();
            this.target = new THREE.Object3D();
            this.isSpotLight = true,
                this.distance = (distance !== undefined) ? distance : 0;
            this.angle = (angle !== undefined) ? angle : Math.PI / 3;
            this.penumbra = (penumbra !== undefined) ? penumbra : 0;
            this.decay = (decay !== undefined) ? decay : 1; // for physically correct lights, should be 2.
            this.shadow = new THREE.SpotLightShadow();
        }
        set power(power) {
            this.intensity = power / Math.PI;
        }
        get power() {
            return this.intensity * Math.PI;
        }
        copy(source) {
            super.copy(source);
            this.distance = source.distance;
            this.angle = source.angle;
            this.penumbra = source.penumbra;
            this.decay = source.decay;
            this.target = source.target.clone();
            this.shadow = source.shadow.clone();
            return this;
        }
    }
    THREE.SpotLight = SpotLight;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class SpotLightShadow extends THREE.LightShadow {
        constructor() {
            super(new THREE.PerspectiveCamera(50, 1, 0.5, 500));
            this.isSpotLightShadow = true;
        }
        update(light) {
            var camera = this.camera;
            var fov = THREE._Math.RAD2DEG * 2 * light.angle;
            var aspect = this.mapSize.width / this.mapSize.height;
            var far = light.distance || camera.far;
            if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
                camera.fov = fov;
                camera.aspect = aspect;
                camera.far = far;
                camera.updateProjectionMatrix();
            }
        }
    }
    THREE.SpotLightShadow = SpotLightShadow;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class AnimationLoader {
        constructor(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        }
        load(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new THREE.FileLoader(scope.manager);
            loader.load(url, function (text) {
                onLoad(scope.parse(JSON.parse(text), null));
            }, onProgress, onError);
        }
        parse(json, onLoad) {
            var animations = [];
            for (var i = 0; i < json.length; i++) {
                var clip = THREE.AnimationClip.parse(json[i]);
                animations.push(clip);
            }
            onLoad(animations);
        }
    }
    THREE.AnimationLoader = AnimationLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class AudioLoader {
        constructor(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        }
        load(url, onLoad, onProgress, onError) {
            var loader = new THREE.FileLoader(this.manager);
            loader.setResponseType('arraybuffer');
            loader.load(url, function (buffer) {
                var context = THREE.AudioContext.getContext();
                context.decodeAudioData(buffer, function (audioBuffer) {
                    onLoad(audioBuffer);
                });
            }, onProgress, onError);
        }
    }
    THREE.AudioLoader = AudioLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class BufferGeometryLoader {
        constructor(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        }
        load(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new THREE.FileLoader(scope.manager);
            loader.load(url, function (text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        }
        parse(json) {
            var geometry = new THREE.BufferGeometry();
            var index = json.data.index;
            if (index !== undefined) {
                var typedArray = new THREE.TYPED_ARRAYS[index.type](index.array);
                geometry.setIndex(new THREE.BufferAttribute(typedArray, 1));
            }
            var attributes = json.data.attributes;
            for (var key in attributes) {
                var attribute = attributes[key];
                var typedArray = new THREE.TYPED_ARRAYS[attribute.type](attribute.array);
                geometry.addAttribute(key, new THREE.BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
            }
            var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
            if (groups !== undefined) {
                for (var i = 0, n = groups.length; i !== n; ++i) {
                    var group = groups[i];
                    geometry.addGroup(group.start, group.count, group.materialIndex);
                }
            }
            var boundingSphere = json.data.boundingSphere;
            if (boundingSphere !== undefined) {
                var center = new THREE.Vector3();
                if (boundingSphere.center !== undefined) {
                    center.fromArray(boundingSphere.center, null);
                }
                geometry.boundingSphere = new THREE.Sphere(center, boundingSphere.radius);
            }
            return geometry;
        }
    }
    THREE.BufferGeometryLoader = BufferGeometryLoader;
    THREE.TYPED_ARRAYS = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        // Workaround for IE11 pre KB2929437. See #11440
        Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    THREE.Cache = {
        enabled: false,
        files: {},
        add: function (key, file) {
            if (this.enabled === false)
                return;
            // console.log( 'THREE.Cache', 'Adding key:', key );
            this.files[key] = file;
        },
        get: function (key) {
            if (this.enabled === false)
                return;
            // console.log( 'THREE.Cache', 'Checking key:', key );
            return this.files[key];
        },
        remove: function (key) {
            delete this.files[key];
        },
        clear: function () {
            this.files = {};
        }
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class CompressedTextureLoader {
        constructor(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
            // override in sub classes
            this._parser = null;
        }
        load(url, onLoad, onProgress, onError) {
            var scope = this;
            var images = [];
            var texture = new THREE.CompressedTexture();
            texture.image = images;
            var loader = new THREE.FileLoader(this.manager);
            loader.setPath(this.path);
            loader.setResponseType('arraybuffer');
            function loadTexture(i) {
                loader.load(url[i], function (buffer) {
                    var texDatas = scope._parser(buffer, true);
                    images[i] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    };
                    loaded += 1;
                    if (loaded === 6) {
                        if (texDatas.mipmapCount === 1)
                            texture.minFilter = THREE.LinearFilter;
                        texture.format = texDatas.format;
                        texture.needsUpdate = true;
                        if (onLoad)
                            onLoad(texture);
                    }
                }, onProgress, onError);
            }
            if (Array.isArray(url)) {
                var loaded = 0;
                for (var i = 0, il = url.length; i < il; ++i) {
                    loadTexture(i);
                }
            }
            else {
                // compressed cubemap texture stored in a single DDS file
                loader.load(url, function (buffer) {
                    var texDatas = scope._parser(buffer, true);
                    if (texDatas.isCubemap) {
                        var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                        for (var f = 0; f < faces; f++) {
                            images[f] = { mipmaps: [] };
                            for (var i = 0; i < texDatas.mipmapCount; i++) {
                                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                                images[f].format = texDatas.format;
                                images[f].width = texDatas.width;
                                images[f].height = texDatas.height;
                            }
                        }
                    }
                    else {
                        texture.image.width = texDatas.width;
                        texture.image.height = texDatas.height;
                        texture.mipmaps = texDatas.mipmaps;
                    }
                    if (texDatas.mipmapCount === 1) {
                        texture.minFilter = THREE.LinearFilter;
                    }
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad)
                        onLoad(texture);
                }, onProgress, onError);
            }
            return texture;
        }
        setPath(value) {
            this.path = value;
            return this;
        }
    }
    THREE.CompressedTextureLoader = CompressedTextureLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class CubeTextureLoader {
        constructor(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
            this.crossOrigin = 'Anonymous';
        }
        load(urls, onLoad, onProgress, onError) {
            var texture = new THREE.CubeTexture();
            var loader = new THREE.ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);
            var loaded = 0;
            function loadTexture(i) {
                loader.load(urls[i], function (image) {
                    texture.images[i] = image;
                    loaded++;
                    if (loaded === 6) {
                        texture.needsUpdate = true;
                        if (onLoad)
                            onLoad(texture);
                    }
                }, undefined, onError);
            }
            for (var i = 0; i < urls.length; ++i) {
                loadTexture(i);
            }
            return texture;
        }
        setCrossOrigin(value) {
            this.crossOrigin = value;
            return this;
        }
        setPath(value) {
            this.path = value;
            return this;
        }
    }
    THREE.CubeTextureLoader = CubeTextureLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class DataTextureLoader {
        constructor(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
            // override in sub classes
            this._parser = null;
        }
        load(url, onLoad, onProgress, onError) {
            var scope = this;
            var texture = new THREE.DataTexture();
            var loader = new THREE.FileLoader(this.manager);
            loader.setResponseType('arraybuffer');
            loader.load(url, function (buffer) {
                var texData = scope._parser(buffer);
                if (!texData)
                    return;
                if (undefined !== texData.image) {
                    texture.image = texData.image;
                }
                else if (undefined !== texData.data) {
                    texture.image.width = texData.width;
                    texture.image.height = texData.height;
                    texture.image.data = texData.data;
                }
                texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
                texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;
                texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
                texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;
                texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
                if (undefined !== texData.format) {
                    texture.format = texData.format;
                }
                if (undefined !== texData.type) {
                    texture.type = texData.type;
                }
                if (undefined !== texData.mipmaps) {
                    texture.mipmaps = texData.mipmaps;
                }
                if (1 === texData.mipmapCount) {
                    texture.minFilter = THREE.LinearFilter;
                }
                texture.needsUpdate = true;
                if (onLoad)
                    onLoad(texture, texData);
            }, onProgress, onError);
            return texture;
        }
    }
    THREE.DataTextureLoader = DataTextureLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var loading = {};
    class FileLoader {
        constructor(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        }
        load(url, onLoad, onProgress, onError) {
            if (url === undefined)
                url = '';
            if (this.path !== undefined)
                url = this.path + url;
            url = this.manager.resolveURL(url);
            var scope = this;
            var cached = THREE.Cache.get(url);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function () {
                    if (onLoad)
                        onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            // Check if request is duplicate
            if (loading[url] !== undefined) {
                loading[url].push({
                    onLoad: onLoad,
                    onProgress: onProgress,
                    onError: onError
                });
                return;
            }
            // Check for data: URI
            var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
            var dataUriRegexResult = url.match(dataUriRegex);
            // Safari can not handle Data URIs through XMLHttpRequest so process manually
            if (dataUriRegexResult) {
                var mimeType = dataUriRegexResult[1];
                var isBase64 = !!dataUriRegexResult[2];
                var data = dataUriRegexResult[3];
                data = window.decodeURIComponent(data);
                if (isBase64)
                    data = window.atob(data);
                try {
                    var response;
                    var responseType = (this.responseType || '').toLowerCase();
                    switch (responseType) {
                        case 'arraybuffer':
                        case 'blob':
                            var view = new Uint8Array(data.length);
                            for (var i = 0; i < data.length; i++) {
                                view[i] = data.charCodeAt(i);
                            }
                            if (responseType === 'blob') {
                                response = new Blob([view.buffer], { type: mimeType });
                            }
                            else {
                                response = view.buffer;
                            }
                            break;
                        case 'document':
                            var parser = new DOMParser();
                            response = parser.parseFromString(data, mimeType);
                            break;
                        case 'json':
                            response = JSON.parse(data);
                            break;
                        default: // 'text' or other
                            response = data;
                            break;
                    }
                    // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                    window.setTimeout(function () {
                        if (onLoad)
                            onLoad(response);
                        scope.manager.itemEnd(url);
                    }, 0);
                }
                catch (error) {
                    // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                    window.setTimeout(function () {
                        if (onError)
                            onError(error);
                        scope.manager.itemEnd(url);
                        scope.manager.itemError(url);
                    }, 0);
                }
            }
            else {
                // Initialise array for duplicate requests
                loading[url] = [];
                loading[url].push({
                    onLoad: onLoad,
                    onProgress: onProgress,
                    onError: onError
                });
                var request = new XMLHttpRequest();
                request.open('GET', url, true);
                request.addEventListener('load', function (event) {
                    var response = this.response;
                    THREE.Cache.add(url, response);
                    var callbacks = loading[url];
                    delete loading[url];
                    if (this.status === 200) {
                        for (var i = 0, il = callbacks.length; i < il; i++) {
                            var callback = callbacks[i];
                            if (callback.onLoad)
                                callback.onLoad(response);
                        }
                        scope.manager.itemEnd(url);
                    }
                    else if (this.status === 0) {
                        // Some browsers return HTTP Status 0 when using non-http protocol
                        // e.g. 'file://' or 'data://'. Handle as success.
                        console.warn('THREE.FileLoader: HTTP Status 0 received.');
                        for (var i = 0, il = callbacks.length; i < il; i++) {
                            var callback = callbacks[i];
                            if (callback.onLoad)
                                callback.onLoad(response);
                        }
                        scope.manager.itemEnd(url);
                    }
                    else {
                        for (var i = 0, il = callbacks.length; i < il; i++) {
                            var callback = callbacks[i];
                            if (callback.onError)
                                callback.onError(event);
                        }
                        scope.manager.itemEnd(url);
                        scope.manager.itemError(url);
                    }
                }, false);
                request.addEventListener('progress', function (event) {
                    var callbacks = loading[url];
                    for (var i = 0, il = callbacks.length; i < il; i++) {
                        var callback = callbacks[i];
                        if (callback.onProgress)
                            callback.onProgress(event);
                    }
                }, false);
                request.addEventListener('error', function (event) {
                    var callbacks = loading[url];
                    delete loading[url];
                    for (var i = 0, il = callbacks.length; i < il; i++) {
                        var callback = callbacks[i];
                        if (callback.onError)
                            callback.onError(event);
                    }
                    scope.manager.itemEnd(url);
                    scope.manager.itemError(url);
                }, false);
                if (this.responseType !== undefined)
                    request.responseType = this.responseType;
                if (this.withCredentials !== undefined)
                    request.withCredentials = this.withCredentials;
                if (request.overrideMimeType)
                    request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');
                for (var header in this.requestHeader) {
                    request.setRequestHeader(header, this.requestHeader[header]);
                }
                request.send(null);
            }
            scope.manager.itemStart(url);
            return request;
        }
        setPath(value) {
            this.path = value;
            return this;
        }
        setResponseType(value) {
            this.responseType = value;
            return this;
        }
        setWithCredentials(value) {
            this.withCredentials = value;
            return this;
        }
        setMimeType(value) {
            this.mimeType = value;
            return this;
        }
        setRequestHeader(value) {
            this.requestHeader = value;
            return this;
        }
    }
    THREE.FileLoader = FileLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class FontLoader {
        constructor(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        }
        load(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new THREE.FileLoader(this.manager);
            loader.setPath(this.path);
            loader.load(url, function (text) {
                var json;
                try {
                    json = JSON.parse(text);
                }
                catch (e) {
                    console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                    json = JSON.parse(text.substring(65, text.length - 2));
                }
                var font = scope.parse(json);
                if (onLoad)
                    onLoad(font);
            }, onProgress, onError);
        }
        parse(json) {
            return new THREE.Font(json);
        }
        setPath(value) {
            this.path = value;
            return this;
        }
    }
    THREE.FontLoader = FontLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class ImageBitmapLoader {
        constructor(manager) {
            if (typeof createImageBitmap === 'undefined') {
                console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
            }
            if (typeof fetch === 'undefined') {
                console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
            }
            this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
            this.options = undefined;
        }
        setOptions(options) {
            this.options = options;
            return this;
        }
        load(url, onLoad, onProgress, onError) {
            if (url === undefined)
                url = '';
            if (this.path !== undefined)
                url = this.path + url;
            var scope = this;
            var cached = THREE.Cache.get(url);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function () {
                    if (onLoad)
                        onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            fetch(url).then(function (res) {
                return res.blob();
            }).then(function (blob) {
                return createImageBitmap(blob, scope.options);
            }).then(function (imageBitmap) {
                THREE.Cache.add(url, imageBitmap);
                if (onLoad)
                    onLoad(imageBitmap);
                scope.manager.itemEnd(url);
            }).catch(function (e) {
                if (onError)
                    onError(e);
                scope.manager.itemEnd(url);
                scope.manager.itemError(url);
            });
        }
        setCrossOrigin( /* value */) {
            return this;
        }
        setPath(value) {
            this.path = value;
            return this;
        }
    }
    THREE.ImageBitmapLoader = ImageBitmapLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class ImageLoader {
        constructor(manager) {
            this.crossOrigin = 'Anonymous';
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        }
        //      Object.assign(ImageLoader.prototype, {
        load(url, onLoad, onProgress, onError) {
            if (url === undefined)
                url = '';
            if (this.path !== undefined)
                url = this.path + url;
            url = this.manager.resolveURL(url);
            var scope = this;
            var cached = THREE.Cache.get(url);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function () {
                    if (onLoad)
                        onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
            image.addEventListener('load', function () {
                THREE.Cache.add(url, this);
                if (onLoad)
                    onLoad(this);
                scope.manager.itemEnd(url);
            }, false);
            /*
            image.addEventListener( 'progress', function ( event ) {
      
               if ( onProgress ) onProgress( event );
      
            }, false );
            */
            image.addEventListener('error', function (event) {
                if (onError)
                    onError(event);
                scope.manager.itemEnd(url);
                scope.manager.itemError(url);
            }, false);
            if (url.substr(0, 5) !== 'data:') {
                if (this.crossOrigin !== undefined)
                    image.crossOrigin = this.crossOrigin;
            }
            scope.manager.itemStart(url);
            image.src = url;
            return image;
        }
        setCrossOrigin(value) {
            this.crossOrigin = value;
            return this;
        }
        setPath(value) {
            this.path = value;
            return this;
        }
    }
    THREE.ImageLoader = ImageLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class JSONLoader {
        constructor(manager) {
            if (typeof manager === 'boolean') {
                console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');
                manager = undefined;
            }
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
            this.withCredentials = false;
        }
        crossOrigin(arg0, arg1, arg2) {
            throw new Error("Method not implemented.");
        }
        load(url, onLoad, onProgress, onError) {
            var scope = this;
            var texturePath = this.texturePath && (typeof this.texturePath === 'string') ? this.texturePath : THREE.LoaderUtils.extractUrlBase(url);
            var loader = new THREE.FileLoader(this.manager);
            loader.setWithCredentials(this.withCredentials);
            loader.load(url, function (text) {
                var json = JSON.parse(text);
                var metadata = json.metadata;
                if (metadata !== undefined) {
                    var type = metadata.type;
                    if (type !== undefined) {
                        if (type.toLowerCase() === 'object') {
                            console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
                            return;
                        }
                    }
                }
                var object = scope.parse(json, texturePath);
                onLoad(object.geometry, object.materials);
            }, onProgress, onError);
        }
        setTexturePath(value) {
            this.texturePath = value;
        }
        parse(json, texturePath) {
            function parseModel(json, geometry) {
                function isBitSet(value, position) {
                    return value & (1 << position);
                }
                var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, scale = json.scale, nUvLayers = 0;
                if (json.uvs !== undefined) {
                    // disregard empty arrays
                    for (i = 0; i < json.uvs.length; i++) {
                        if (json.uvs[i].length)
                            nUvLayers++;
                    }
                    for (i = 0; i < nUvLayers; i++) {
                        geometry.faceVertexUvs[i] = [];
                    }
                }
                offset = 0;
                zLength = vertices.length;
                while (offset < zLength) {
                    vertex = new THREE.Vector3();
                    vertex.x = vertices[offset++] * scale;
                    vertex.y = vertices[offset++] * scale;
                    vertex.z = vertices[offset++] * scale;
                    geometry.vertices.push(vertex);
                }
                offset = 0;
                zLength = faces.length;
                while (offset < zLength) {
                    type = faces[offset++];
                    isQuad = isBitSet(type, 0);
                    hasMaterial = isBitSet(type, 1);
                    hasFaceVertexUv = isBitSet(type, 3);
                    hasFaceNormal = isBitSet(type, 4);
                    hasFaceVertexNormal = isBitSet(type, 5);
                    hasFaceColor = isBitSet(type, 6);
                    hasFaceVertexColor = isBitSet(type, 7);
                    // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
                    if (isQuad) {
                        faceA = new THREE.Face3();
                        faceA.a = faces[offset];
                        faceA.b = faces[offset + 1];
                        faceA.c = faces[offset + 3];
                        faceB = new THREE.Face3();
                        faceB.a = faces[offset + 1];
                        faceB.b = faces[offset + 2];
                        faceB.c = faces[offset + 3];
                        offset += 4;
                        if (hasMaterial) {
                            materialIndex = faces[offset++];
                            faceA.materialIndex = materialIndex;
                            faceB.materialIndex = materialIndex;
                        }
                        // to get face <=> uv index correspondence
                        fi = geometry.faces.length;
                        if (hasFaceVertexUv) {
                            for (i = 0; i < nUvLayers; i++) {
                                uvLayer = json.uvs[i];
                                geometry.faceVertexUvs[i][fi] = [];
                                geometry.faceVertexUvs[i][fi + 1] = [];
                                for (j = 0; j < 4; j++) {
                                    uvIndex = faces[offset++];
                                    u = uvLayer[uvIndex * 2];
                                    v = uvLayer[uvIndex * 2 + 1];
                                    uv = new THREE.Vector2(u, v);
                                    if (j !== 2)
                                        geometry.faceVertexUvs[i][fi].push(uv);
                                    if (j !== 0)
                                        geometry.faceVertexUvs[i][fi + 1].push(uv);
                                }
                            }
                        }
                        if (hasFaceNormal) {
                            normalIndex = faces[offset++] * 3;
                            faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                            faceB.normal.copy(faceA.normal);
                        }
                        if (hasFaceVertexNormal) {
                            for (i = 0; i < 4; i++) {
                                normalIndex = faces[offset++] * 3;
                                normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                                if (i !== 2)
                                    faceA.vertexNormals.push(normal);
                                if (i !== 0)
                                    faceB.vertexNormals.push(normal);
                            }
                        }
                        if (hasFaceColor) {
                            colorIndex = faces[offset++];
                            hex = colors[colorIndex];
                            faceA.color.setHex(hex);
                            faceB.color.setHex(hex);
                        }
                        if (hasFaceVertexColor) {
                            for (i = 0; i < 4; i++) {
                                colorIndex = faces[offset++];
                                hex = colors[colorIndex];
                                if (i !== 2)
                                    faceA.vertexColors.push(new THREE.Color(hex));
                                if (i !== 0)
                                    faceB.vertexColors.push(new THREE.Color(hex));
                            }
                        }
                        geometry.faces.push(faceA);
                        geometry.faces.push(faceB);
                    }
                    else {
                        face = new THREE.Face3();
                        face.a = faces[offset++];
                        face.b = faces[offset++];
                        face.c = faces[offset++];
                        if (hasMaterial) {
                            materialIndex = faces[offset++];
                            face.materialIndex = materialIndex;
                        }
                        // to get face <=> uv index correspondence
                        fi = geometry.faces.length;
                        if (hasFaceVertexUv) {
                            for (i = 0; i < nUvLayers; i++) {
                                uvLayer = json.uvs[i];
                                geometry.faceVertexUvs[i][fi] = [];
                                for (j = 0; j < 3; j++) {
                                    uvIndex = faces[offset++];
                                    u = uvLayer[uvIndex * 2];
                                    v = uvLayer[uvIndex * 2 + 1];
                                    uv = new THREE.Vector2(u, v);
                                    geometry.faceVertexUvs[i][fi].push(uv);
                                }
                            }
                        }
                        if (hasFaceNormal) {
                            normalIndex = faces[offset++] * 3;
                            face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                        }
                        if (hasFaceVertexNormal) {
                            for (i = 0; i < 3; i++) {
                                normalIndex = faces[offset++] * 3;
                                normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                                face.vertexNormals.push(normal);
                            }
                        }
                        if (hasFaceColor) {
                            colorIndex = faces[offset++];
                            face.color.setHex(colors[colorIndex]);
                        }
                        if (hasFaceVertexColor) {
                            for (i = 0; i < 3; i++) {
                                colorIndex = faces[offset++];
                                face.vertexColors.push(new THREE.Color(colors[colorIndex]));
                            }
                        }
                        geometry.faces.push(face);
                    }
                }
            }
            function parseSkin(json, geometry) {
                var influencesPerVertex = (json.influencesPerVertex !== undefined) ? json.influencesPerVertex : 2;
                if (json.skinWeights) {
                    for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
                        var x = json.skinWeights[i];
                        var y = (influencesPerVertex > 1) ? json.skinWeights[i + 1] : 0;
                        var z = (influencesPerVertex > 2) ? json.skinWeights[i + 2] : 0;
                        var w = (influencesPerVertex > 3) ? json.skinWeights[i + 3] : 0;
                        geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));
                    }
                }
                if (json.skinIndices) {
                    for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
                        var a = json.skinIndices[i];
                        var b = (influencesPerVertex > 1) ? json.skinIndices[i + 1] : 0;
                        var c = (influencesPerVertex > 2) ? json.skinIndices[i + 2] : 0;
                        var d = (influencesPerVertex > 3) ? json.skinIndices[i + 3] : 0;
                        geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));
                    }
                }
                geometry.bones = json.bones;
                if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
                    console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
                        geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
                }
            }
            function parseMorphing(json, geometry) {
                var scale = json.scale;
                if (json.morphTargets !== undefined) {
                    for (var i = 0, l = json.morphTargets.length; i < l; i++) {
                        geometry.morphTargets[i] = {};
                        geometry.morphTargets[i].name = json.morphTargets[i].name;
                        geometry.morphTargets[i].vertices = [];
                        var dstVertices = geometry.morphTargets[i].vertices;
                        var srcVertices = json.morphTargets[i].vertices;
                        for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {
                            var vertex = new THREE.Vector3();
                            vertex.x = srcVertices[v] * scale;
                            vertex.y = srcVertices[v + 1] * scale;
                            vertex.z = srcVertices[v + 2] * scale;
                            dstVertices.push(vertex);
                        }
                    }
                }
                if (json.morphColors !== undefined && json.morphColors.length > 0) {
                    console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                    var faces = geometry.faces;
                    var morphColors = json.morphColors[0].colors;
                    for (var i = 0, l = faces.length; i < l; i++) {
                        faces[i].color.fromArray(morphColors, i * 3);
                    }
                }
            }
            function parseAnimations(json, geometry) {
                var outputAnimations = [];
                // parse old style Bone/Hierarchy animations
                var animations = [];
                if (json.animation !== undefined) {
                    animations.push(json.animation);
                }
                if (json.animations !== undefined) {
                    if (json.animations.length) {
                        animations = animations.concat(json.animations);
                    }
                    else {
                        animations.push(json.animations);
                    }
                }
                for (var i = 0; i < animations.length; i++) {
                    var clip = THREE.AnimationClip.parseAnimation(animations[i], geometry.bones);
                    if (clip)
                        outputAnimations.push(clip);
                }
                // parse implicit morph animations
                if (geometry.morphTargets) {
                    // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
                    var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
                    outputAnimations = outputAnimations.concat(morphAnimationClips);
                }
                if (outputAnimations.length > 0)
                    geometry.animations = outputAnimations;
            }
            // return function parse(json, texturePath) {
            if (json.data !== undefined) {
                // Geometry 4.0 spec
                json = json.data;
            }
            if (json.scale !== undefined) {
                json.scale = 1.0 / json.scale;
            }
            else {
                json.scale = 1.0;
            }
            var geometry = new THREE.Geometry();
            parseModel(json, geometry);
            parseSkin(json, geometry);
            parseMorphing(json, geometry);
            parseAnimations(json, geometry);
            geometry.computeFaceNormals();
            geometry.computeBoundingSphere();
            if (json.materials === undefined || json.materials.length === 0) {
                return { geometry: geometry };
            }
            else {
                //TODO:
                //var materials = Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
                var materials = new THREE.Loader().initMaterials(json.materials, texturePath, this.crossOrigin);
                return { geometry: geometry, materials: materials };
            }
        }
        ;
    }
    THREE.JSONLoader = JSONLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Loader {
        constructor() {
            this.crossOrigin = undefined;
        }
        onLoadStart() { }
        onLoadProgress() { }
        onLoadComplete() { }
        initMaterials(materials, texturePath, crossOrigin) {
            var array = [];
            for (var i = 0; i < materials.length; ++i) {
                array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
            }
            return array;
        }
        createMaterial(m, texturePath, crossOrigin) {
            //TODO:
            var BlendingMode = {
                NoBlending: THREE.NoBlending,
                NormalBlending: THREE.NormalBlending,
                AdditiveBlending: THREE.AdditiveBlending,
                SubtractiveBlending: THREE.SubtractiveBlending,
                MultiplyBlending: THREE.MultiplyBlending,
                CustomBlending: THREE.CustomBlending
            };
            var color = new THREE.Color();
            var textureLoader = new THREE.TextureLoader();
            var materialLoader = new THREE.MaterialLoader();
            // convert from old material format
            var textures = {};
            function loadTexture(path, repeat, offset, wrap, anisotropy) {
                var fullPath = texturePath + path;
                var loader = Loader.Handlers.get(fullPath);
                var texture;
                if (loader !== null) {
                    texture = loader.load(fullPath);
                }
                else {
                    textureLoader.setCrossOrigin(crossOrigin);
                    texture = textureLoader.load(fullPath);
                }
                if (repeat !== undefined) {
                    texture.repeat.fromArray(repeat);
                    if (repeat[0] !== 1)
                        texture.wrapS = THREE.RepeatWrapping;
                    if (repeat[1] !== 1)
                        texture.wrapT = THREE.RepeatWrapping;
                }
                if (offset !== undefined) {
                    texture.offset.fromArray(offset);
                }
                if (wrap !== undefined) {
                    if (wrap[0] === 'repeat')
                        texture.wrapS = THREE.RepeatWrapping;
                    if (wrap[0] === 'mirror')
                        texture.wrapS = THREE.MirroredRepeatWrapping;
                    if (wrap[1] === 'repeat')
                        texture.wrapT = THREE.RepeatWrapping;
                    if (wrap[1] === 'mirror')
                        texture.wrapT = THREE.MirroredRepeatWrapping;
                }
                if (anisotropy !== undefined) {
                    texture.anisotropy = anisotropy;
                }
                var uuid = THREE._Math.generateUUID();
                textures[uuid] = texture;
                return uuid;
            }
            //
            var json = {
                uuid: THREE._Math.generateUUID(),
                type: 'MeshLambertMaterial'
            };
            for (var name in m) {
                var value = m[name];
                switch (name) {
                    case 'DbgColor':
                    case 'DbgIndex':
                    case 'opticalDensity':
                    case 'illumination':
                        break;
                    case 'DbgName':
                        json.name = value;
                        break;
                    case 'blending':
                        json.blending = BlendingMode[value];
                        break;
                    case 'colorAmbient':
                    case 'mapAmbient':
                        console.warn('THREE.Loader.createMaterial:', name, 'is no longer supported.');
                        break;
                    case 'colorDiffuse':
                        json.color = color.fromArray(value).getHex();
                        break;
                    case 'colorSpecular':
                        json.specular = color.fromArray(value).getHex();
                        break;
                    case 'colorEmissive':
                        json.emissive = color.fromArray(value).getHex();
                        break;
                    case 'specularCoef':
                        json.shininess = value;
                        break;
                    case 'shading':
                        if (value.toLowerCase() === 'basic')
                            json.type = 'MeshBasicMaterial';
                        if (value.toLowerCase() === 'phong')
                            json.type = 'MeshPhongMaterial';
                        if (value.toLowerCase() === 'standard')
                            json.type = 'MeshStandardMaterial';
                        break;
                    case 'mapDiffuse':
                        json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                        break;
                    case 'mapDiffuseRepeat':
                    case 'mapDiffuseOffset':
                    case 'mapDiffuseWrap':
                    case 'mapDiffuseAnisotropy':
                        break;
                    case 'mapEmissive':
                        json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                        break;
                    case 'mapEmissiveRepeat':
                    case 'mapEmissiveOffset':
                    case 'mapEmissiveWrap':
                    case 'mapEmissiveAnisotropy':
                        break;
                    case 'mapLight':
                        json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                        break;
                    case 'mapLightRepeat':
                    case 'mapLightOffset':
                    case 'mapLightWrap':
                    case 'mapLightAnisotropy':
                        break;
                    case 'mapAO':
                        json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                        break;
                    case 'mapAORepeat':
                    case 'mapAOOffset':
                    case 'mapAOWrap':
                    case 'mapAOAnisotropy':
                        break;
                    case 'mapBump':
                        json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                        break;
                    case 'mapBumpScale':
                        json.bumpScale = value;
                        break;
                    case 'mapBumpRepeat':
                    case 'mapBumpOffset':
                    case 'mapBumpWrap':
                    case 'mapBumpAnisotropy':
                        break;
                    case 'mapNormal':
                        json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                        break;
                    case 'mapNormalFactor':
                        json.normalScale = value;
                        break;
                    case 'mapNormalRepeat':
                    case 'mapNormalOffset':
                    case 'mapNormalWrap':
                    case 'mapNormalAnisotropy':
                        break;
                    case 'mapSpecular':
                        json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                        break;
                    case 'mapSpecularRepeat':
                    case 'mapSpecularOffset':
                    case 'mapSpecularWrap':
                    case 'mapSpecularAnisotropy':
                        break;
                    case 'mapMetalness':
                        json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                        break;
                    case 'mapMetalnessRepeat':
                    case 'mapMetalnessOffset':
                    case 'mapMetalnessWrap':
                    case 'mapMetalnessAnisotropy':
                        break;
                    case 'mapRoughness':
                        json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                        break;
                    case 'mapRoughnessRepeat':
                    case 'mapRoughnessOffset':
                    case 'mapRoughnessWrap':
                    case 'mapRoughnessAnisotropy':
                        break;
                    case 'mapAlpha':
                        json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                        break;
                    case 'mapAlphaRepeat':
                    case 'mapAlphaOffset':
                    case 'mapAlphaWrap':
                    case 'mapAlphaAnisotropy':
                        break;
                    case 'flipSided':
                        json.side = THREE.BackSide;
                        break;
                    case 'doubleSided':
                        json.side = THREE.DoubleSide;
                        break;
                    case 'transparency':
                        console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
                        json.opacity = value;
                        break;
                    case 'depthTest':
                    case 'depthWrite':
                    case 'colorWrite':
                    case 'opacity':
                    case 'reflectivity':
                    case 'transparent':
                    case 'visible':
                    case 'wireframe':
                        json[name] = value;
                        break;
                    case 'vertexColors':
                        if (value === true)
                            json.vertexColors = THREE.VertexColors;
                        if (value === 'face')
                            json.vertexColors = THREE.FaceColors;
                        break;
                    default:
                        console.error('THREE.Loader.createMaterial: Unsupported', name, value);
                        break;
                }
            }
            if (json.type === 'MeshBasicMaterial')
                delete json.emissive;
            if (json.type !== 'MeshPhongMaterial')
                delete json.specular;
            if (json.opacity < 1)
                json.transparent = true;
            materialLoader.setTextures(textures);
            return materialLoader.parse(json);
        }
        ;
    }
    Loader.Handlers = {
        handlers: [],
        add: function (regex, loader) {
            this.handlers.push(regex, loader);
        },
        get: function (file) {
            var handlers = this.handlers;
            for (var i = 0, l = handlers.length; i < l; i += 2) {
                var regex = handlers[i];
                var loader = handlers[i + 1];
                if (regex.test(file)) {
                    return loader;
                }
            }
            return null;
        }
    };
    THREE.Loader = Loader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class LoaderUtils {
        static decodeText(array) {
            if (typeof TextDecoder !== 'undefined') {
                return new TextDecoder().decode(array);
            }
            // Avoid the String.fromCharCode.apply(null, array) shortcut, which
            // throws a "maximum call stack size exceeded" error for large arrays.
            var s = '';
            for (var i = 0, il = array.length; i < il; i++) {
                // Implicitly assumes little-endian.
                s += String.fromCharCode(array[i]);
            }
            // Merges multi-byte utf-8 characters.
            return decodeURIComponent(escape(s));
        }
        static extractUrlBase(url) {
            var index = url.lastIndexOf('/');
            if (index === -1)
                return './';
            return url.substr(0, index + 1);
        }
    }
    THREE.LoaderUtils = LoaderUtils;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class LoadingManager {
        constructor(onLoad, onProgress, onError) {
            this.isLoading = false;
            this.itemsLoaded = 0;
            this.itemsTotal = 0;
            this.urlModifier = undefined;
            this.itemEnd = function (url) {
                this.itemsLoaded++;
                if (this.onProgress !== undefined) {
                    this.onProgress(url, this.itemsLoaded, this.itemsTotal);
                }
                if (this.itemsLoaded === this.itemsTotal) {
                    this.isLoading = false;
                    if (this.onLoad !== undefined) {
                        this.onLoad();
                    }
                }
            };
            //var scope = this;
            this.onStart = undefined;
            this.onLoad = onLoad;
            this.onProgress = onProgress;
            this.onError = onError;
        }
        itemStart(url) {
            this.itemsTotal++;
            if (this.isLoading === false) {
                if (this.onStart !== undefined) {
                    this.onStart(url, this.itemsLoaded, this.itemsTotal);
                }
            }
            this.isLoading = true;
        }
        itemError(url) {
            if (this.onError !== undefined) {
                this.onError(url);
            }
        }
        resolveURL(url) {
            if (this.urlModifier) {
                return this.urlModifier(url);
            }
            return url;
        }
        setURLModifier(transform) {
            this.urlModifier = transform;
            return this;
        }
    }
    THREE.LoadingManager = LoadingManager;
    THREE.DefaultLoadingManager = new LoadingManager();
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class MaterialLoader {
        constructor(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
            this.textures = {};
        }
        // Object.assign(MaterialLoader.prototype, {
        load(url, onLoad, onProgress, onError) {
            //var scope = this;
            var loader = new THREE.FileLoader(this.manager);
            loader.load(url, function (text) {
                onLoad(this.parse(JSON.parse(text)));
            }, onProgress, onError);
        }
        setTextures(value) {
            this.textures = value;
        }
        parse(json) {
            var textures = this.textures;
            function getTexture(name) {
                if (textures[name] === undefined) {
                    console.warn('THREE.MaterialLoader: Undefined texture', name);
                }
                return textures[name];
            }
            var material = new THREE.Materials[json.type]();
            if (json.uuid !== undefined)
                material.uuid = json.uuid;
            if (json.name !== undefined)
                material.name = json.name;
            if (json.color !== undefined)
                material.color.setHex(json.color);
            if (json.roughness !== undefined)
                material.roughness = json.roughness;
            if (json.metalness !== undefined)
                material.metalness = json.metalness;
            if (json.emissive !== undefined)
                material.emissive.setHex(json.emissive);
            if (json.specular !== undefined)
                material.specular.setHex(json.specular);
            if (json.shininess !== undefined)
                material.shininess = json.shininess;
            if (json.clearCoat !== undefined)
                material.clearCoat = json.clearCoat;
            if (json.clearCoatRoughness !== undefined)
                material.clearCoatRoughness = json.clearCoatRoughness;
            if (json.uniforms !== undefined)
                material.uniforms = json.uniforms;
            if (json.vertexShader !== undefined)
                material.vertexShader = json.vertexShader;
            if (json.fragmentShader !== undefined)
                material.fragmentShader = json.fragmentShader;
            if (json.vertexColors !== undefined)
                material.vertexColors = json.vertexColors;
            if (json.fog !== undefined)
                material.fog = json.fog;
            if (json.flatShading !== undefined)
                material.flatShading = json.flatShading;
            if (json.blending !== undefined)
                material.blending = json.blending;
            if (json.side !== undefined)
                material.side = json.side;
            if (json.opacity !== undefined)
                material.opacity = json.opacity;
            if (json.transparent !== undefined)
                material.transparent = json.transparent;
            if (json.alphaTest !== undefined)
                material.alphaTest = json.alphaTest;
            if (json.depthTest !== undefined)
                material.depthTest = json.depthTest;
            if (json.depthWrite !== undefined)
                material.depthWrite = json.depthWrite;
            if (json.colorWrite !== undefined)
                material.colorWrite = json.colorWrite;
            if (json.wireframe !== undefined)
                material.wireframe = json.wireframe;
            if (json.wireframeLinewidth !== undefined)
                material.wireframeLinewidth = json.wireframeLinewidth;
            if (json.wireframeLinecap !== undefined)
                material.wireframeLinecap = json.wireframeLinecap;
            if (json.wireframeLinejoin !== undefined)
                material.wireframeLinejoin = json.wireframeLinejoin;
            if (json.rotation !== undefined)
                material.rotation = json.rotation;
            if (json.linewidth !== 1)
                material.linewidth = json.linewidth;
            if (json.dashSize !== undefined)
                material.dashSize = json.dashSize;
            if (json.gapSize !== undefined)
                material.gapSize = json.gapSize;
            if (json.scale !== undefined)
                material.scale = json.scale;
            if (json.polygonOffset !== undefined)
                material.polygonOffset = json.polygonOffset;
            if (json.polygonOffsetFactor !== undefined)
                material.polygonOffsetFactor = json.polygonOffsetFactor;
            if (json.polygonOffsetUnits !== undefined)
                material.polygonOffsetUnits = json.polygonOffsetUnits;
            if (json.skinning !== undefined)
                material.skinning = json.skinning;
            if (json.morphTargets !== undefined)
                material.morphTargets = json.morphTargets;
            if (json.dithering !== undefined)
                material.dithering = json.dithering;
            if (json.visible !== undefined)
                material.visible = json.visible;
            if (json.userData !== undefined)
                material.userData = json.userData;
            // Deprecated
            if (json.shading !== undefined)
                material.flatShading = json.shading === 1; // THREE.FlatShading
            // for PointsMaterial
            if (json.size !== undefined)
                material.size = json.size;
            if (json.sizeAttenuation !== undefined)
                material.sizeAttenuation = json.sizeAttenuation;
            // maps
            if (json.map !== undefined)
                material.map = getTexture(json.map);
            if (json.alphaMap !== undefined) {
                material.alphaMap = getTexture(json.alphaMap);
                material.transparent = true;
            }
            if (json.bumpMap !== undefined)
                material.bumpMap = getTexture(json.bumpMap);
            if (json.bumpScale !== undefined)
                material.bumpScale = json.bumpScale;
            if (json.normalMap !== undefined)
                material.normalMap = getTexture(json.normalMap);
            if (json.normalScale !== undefined) {
                var normalScale = json.normalScale;
                if (Array.isArray(normalScale) === false) {
                    // Blender exporter used to export a scalar. See #7459
                    normalScale = [normalScale, normalScale];
                }
                material.normalScale = new THREE.Vector2().fromArray(normalScale);
            }
            if (json.displacementMap !== undefined)
                material.displacementMap = getTexture(json.displacementMap);
            if (json.displacementScale !== undefined)
                material.displacementScale = json.displacementScale;
            if (json.displacementBias !== undefined)
                material.displacementBias = json.displacementBias;
            if (json.roughnessMap !== undefined)
                material.roughnessMap = getTexture(json.roughnessMap);
            if (json.metalnessMap !== undefined)
                material.metalnessMap = getTexture(json.metalnessMap);
            if (json.emissiveMap !== undefined)
                material.emissiveMap = getTexture(json.emissiveMap);
            if (json.emissiveIntensity !== undefined)
                material.emissiveIntensity = json.emissiveIntensity;
            if (json.specularMap !== undefined)
                material.specularMap = getTexture(json.specularMap);
            if (json.envMap !== undefined)
                material.envMap = getTexture(json.envMap);
            if (json.reflectivity !== undefined)
                material.reflectivity = json.reflectivity;
            if (json.lightMap !== undefined)
                material.lightMap = getTexture(json.lightMap);
            if (json.lightMapIntensity !== undefined)
                material.lightMapIntensity = json.lightMapIntensity;
            if (json.aoMap !== undefined)
                material.aoMap = getTexture(json.aoMap);
            if (json.aoMapIntensity !== undefined)
                material.aoMapIntensity = json.aoMapIntensity;
            if (json.gradientMap !== undefined)
                material.gradientMap = getTexture(json.gradientMap);
            return material;
        }
    }
    THREE.MaterialLoader = MaterialLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class ObjectLoader {
        constructor(manager) {
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
            this.texturePath = '';
        }
        //Object.assign(ObjectLoader.prototype, {
        load(url, onLoad, onProgress, onError) {
            if (this.texturePath === '') {
                this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
            }
            var scope = this;
            var loader = new THREE.FileLoader(scope.manager);
            loader.load(url, function (text) {
                var json = null;
                try {
                    json = JSON.parse(text);
                }
                catch (error) {
                    if (onError !== undefined)
                        onError(error);
                    console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
                    return;
                }
                var metadata = json.metadata;
                if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                    console.error('THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.');
                    return;
                }
                scope.parse(json, onLoad);
            }, onProgress, onError);
        }
        setTexturePath(value) {
            this.texturePath = value;
            return this;
        }
        setCrossOrigin(value) {
            this.crossOrigin = value;
            return this;
        }
        parse(json, onLoad) {
            var shapes = this.parseShape(json.shapes);
            var geometries = this.parseGeometries(json.geometries, shapes);
            var images = this.parseImages(json.images, function () {
                if (onLoad !== undefined)
                    onLoad(object);
            });
            var textures = this.parseTextures(json.textures, images);
            var materials = this.parseMaterials(json.materials, textures);
            var object = this.parseObject(json.object, geometries, materials);
            if (json.animations) {
                object.animations = this.parseAnimations(json.animations);
            }
            if (json.images === undefined || json.images.length === 0) {
                if (onLoad !== undefined)
                    onLoad(object);
            }
            return object;
        }
        parseShape(json) {
            var shapes = {};
            if (json !== undefined) {
                for (var i = 0, l = json.length; i < l; i++) {
                    var shape = new THREE.Shape().fromJSON(json[i]);
                    shapes[shape.uuid] = shape;
                }
            }
            return shapes;
        }
        parseGeometries(json, shapes) {
            var geometries = {};
            if (json !== undefined) {
                var geometryLoader = new THREE.JSONLoader();
                var bufferGeometryLoader = new THREE.BufferGeometryLoader();
                for (var i = 0, l = json.length; i < l; i++) {
                    var geometry;
                    var data = json[i];
                    switch (data.type) {
                        case 'PlaneGeometry':
                        case 'PlaneBufferGeometry':
                            geometry = new THREE.Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                            break;
                        case 'BoxGeometry':
                        case 'BoxBufferGeometry':
                        case 'CubeGeometry': // backwards compatible
                            geometry = new THREE.Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                            break;
                        case 'CircleGeometry':
                        case 'CircleBufferGeometry':
                            geometry = new THREE.Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                            break;
                        case 'CylinderGeometry':
                        case 'CylinderBufferGeometry':
                            geometry = new THREE.Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                            break;
                        case 'ConeGeometry':
                        case 'ConeBufferGeometry':
                            geometry = new THREE.Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                            break;
                        case 'SphereGeometry':
                        case 'SphereBufferGeometry':
                            geometry = new THREE.Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                            break;
                        case 'DodecahedronGeometry':
                        case 'DodecahedronBufferGeometry':
                        case 'IcosahedronGeometry':
                        case 'IcosahedronBufferGeometry':
                        case 'OctahedronGeometry':
                        case 'OctahedronBufferGeometry':
                        case 'TetrahedronGeometry':
                        case 'TetrahedronBufferGeometry':
                            geometry = new THREE.Geometries[data.type](data.radius, data.detail);
                            break;
                        case 'RingGeometry':
                        case 'RingBufferGeometry':
                            geometry = new THREE.Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                            break;
                        case 'TorusGeometry':
                        case 'TorusBufferGeometry':
                            geometry = new THREE.Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                            break;
                        case 'TorusKnotGeometry':
                        case 'TorusKnotBufferGeometry':
                            geometry = new THREE.Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                            break;
                        case 'LatheGeometry':
                        case 'LatheBufferGeometry':
                            geometry = new THREE.Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                            break;
                        case 'PolyhedronGeometry':
                        case 'PolyhedronBufferGeometry':
                            geometry = new THREE.Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
                            break;
                        case 'ShapeGeometry':
                        case 'ShapeBufferGeometry':
                            var geometryShapes = [];
                            for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                                var shape = shapes[data.shapes[j]];
                                geometryShapes.push(shape);
                            }
                            geometry = new THREE.Geometries[data.type](geometryShapes, data.curveSegments);
                            break;
                        case 'BufferGeometry':
                            geometry = bufferGeometryLoader.parse(data);
                            break;
                        case 'Geometry':
                            geometry = geometryLoader.parse(data, this.texturePath).geometry;
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                            continue;
                    }
                    geometry.uuid = data.uuid;
                    if (data.name !== undefined)
                        geometry.name = data.name;
                    geometries[data.uuid] = geometry;
                }
            }
            return geometries;
        }
        parseMaterials(json, textures) {
            var materials = {};
            if (json !== undefined) {
                var loader = new THREE.MaterialLoader();
                loader.setTextures(textures);
                for (var i = 0, l = json.length; i < l; i++) {
                    var data = json[i];
                    if (data.type === 'MultiMaterial') {
                        // Deprecated
                        var array = [];
                        for (var j = 0; j < data.materials.length; j++) {
                            array.push(loader.parse(data.materials[j]));
                        }
                        materials[data.uuid] = array;
                    }
                    else {
                        materials[data.uuid] = loader.parse(data);
                    }
                }
            }
            return materials;
        }
        parseAnimations(json) {
            var animations = [];
            for (var i = 0; i < json.length; i++) {
                var data = json[i];
                var clip = THREE.AnimationClip.parse(data);
                if (data.uuid !== undefined)
                    clip.uuid = data.uuid;
                animations.push(clip);
            }
            return animations;
        }
        parseImages(json, onLoad) {
            var scope = this;
            var images = {};
            function loadImage(url) {
                scope.manager.itemStart(url);
                return loader.load(url, function () {
                    scope.manager.itemEnd(url);
                }, undefined, function () {
                    scope.manager.itemEnd(url);
                    scope.manager.itemError(url);
                });
            }
            if (json !== undefined && json.length > 0) {
                var manager = new THREE.LoadingManager(onLoad);
                var loader = new THREE.ImageLoader(manager);
                loader.setCrossOrigin(this.crossOrigin);
                for (var i = 0, l = json.length; i < l; i++) {
                    var image = json[i];
                    var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
                    images[image.uuid] = loadImage(path);
                }
            }
            return images;
        }
        parseTextures(json, images) {
            function parseConstant(value, type) {
                if (typeof value === 'number')
                    return value;
                console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
                return type[value];
            }
            var textures = {};
            if (json !== undefined) {
                for (var i = 0, l = json.length; i < l; i++) {
                    var data = json[i];
                    if (data.image === undefined) {
                        console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
                    }
                    if (images[data.image] === undefined) {
                        console.warn('THREE.ObjectLoader: Undefined image', data.image);
                    }
                    var texture = new THREE.Texture(images[data.image]);
                    texture.needsUpdate = true;
                    texture.uuid = data.uuid;
                    if (data.name !== undefined)
                        texture.name = data.name;
                    if (data.mapping !== undefined)
                        texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
                    if (data.offset !== undefined)
                        texture.offset.fromArray(data.offset);
                    if (data.repeat !== undefined)
                        texture.repeat.fromArray(data.repeat);
                    if (data.center !== undefined)
                        texture.center.fromArray(data.center);
                    if (data.rotation !== undefined)
                        texture.rotation = data.rotation;
                    if (data.wrap !== undefined) {
                        texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                        texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
                    }
                    if (data.format !== undefined)
                        texture.format = data.format;
                    if (data.minFilter !== undefined)
                        texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
                    if (data.magFilter !== undefined)
                        texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
                    if (data.anisotropy !== undefined)
                        texture.anisotropy = data.anisotropy;
                    if (data.flipY !== undefined)
                        texture.flipY = data.flipY;
                    textures[data.uuid] = texture;
                }
            }
            return textures;
        }
        parseObject(data, geometries, materials) {
            var object;
            function getGeometry(name) {
                if (geometries[name] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined geometry', name);
                }
                return geometries[name];
            }
            function getMaterial(name) {
                if (name === undefined)
                    return undefined;
                if (Array.isArray(name)) {
                    var array = [];
                    for (var i = 0, l = name.length; i < l; i++) {
                        var uuid = name[i];
                        if (materials[uuid] === undefined) {
                            console.warn('THREE.ObjectLoader: Undefined material', uuid);
                        }
                        array.push(materials[uuid]);
                    }
                    return array;
                }
                if (materials[name] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined material', name);
                }
                return materials[name];
            }
            switch (data.type) {
                case 'Scene':
                    object = new THREE.Scene();
                    if (data.background !== undefined) {
                        if (Number.isInteger(data.background)) {
                            object.background = new THREE.Color(data.background);
                        }
                    }
                    if (data.fog !== undefined) {
                        if (data.fog.type === 'Fog') {
                            object.fog = new THREE.Fog(data.fog.color, data.fog.near, data.fog.far);
                        }
                        else if (data.fog.type === 'FogExp2') {
                            object.fog = new THREE.FogExp2(data.fog.color, data.fog.density);
                        }
                    }
                    break;
                case 'PerspectiveCamera':
                    object = new THREE.PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                    if (data.focus !== undefined)
                        object.focus = data.focus;
                    if (data.zoom !== undefined)
                        object.zoom = data.zoom;
                    if (data.filmGauge !== undefined)
                        object.filmGauge = data.filmGauge;
                    if (data.filmOffset !== undefined)
                        object.filmOffset = data.filmOffset;
                    if (data.view !== undefined)
                        object.view = Object.assign({}, data.view);
                    break;
                case 'OrthographicCamera':
                    object = new THREE.OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                    if (data.zoom !== undefined)
                        object.zoom = data.zoom;
                    if (data.view !== undefined)
                        object.view = Object.assign({}, data.view);
                    break;
                case 'AmbientLight':
                    object = new THREE.AmbientLight(data.color, data.intensity);
                    break;
                case 'DirectionalLight':
                    object = new THREE.DirectionalLight(data.color, data.intensity);
                    break;
                case 'PointLight':
                    object = new THREE.PointLight(data.color, data.intensity, data.distance, data.decay);
                    break;
                case 'RectAreaLight':
                    object = new THREE.RectAreaLight(data.color, data.intensity, data.width, data.height);
                    break;
                case 'SpotLight':
                    object = new THREE.SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                    break;
                case 'HemisphereLight':
                    object = new THREE.HemisphereLight(data.color, data.groundColor, data.intensity);
                    break;
                case 'SkinnedMesh':
                    console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');
                case 'Mesh':
                    var geometry = getGeometry(data.geometry);
                    var material = getMaterial(data.material);
                    if (geometry.bones && geometry.bones.length > 0) {
                        object = new THREE.SkinnedMesh(geometry, material);
                    }
                    else {
                        object = new THREE.Mesh(geometry, material);
                    }
                    break;
                case 'LOD':
                    object = new THREE.LOD();
                    break;
                case 'Line':
                    object = new THREE.Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                    break;
                case 'LineLoop':
                    object = new THREE.LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                case 'LineSegments':
                    object = new THREE.LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                case 'PointCloud':
                case 'Points':
                    object = new THREE.Points(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                case 'Sprite':
                    object = new THREE.Sprite(getMaterial(data.material));
                    break;
                case 'Group':
                    object = new THREE.Group();
                    break;
                default:
                    object = new THREE.Object3D();
            }
            object.uuid = data.uuid;
            if (data.name !== undefined)
                object.name = data.name;
            if (data.matrix !== undefined) {
                object.matrix.fromArray(data.matrix);
                if (data.matrixAutoUpdate !== undefined)
                    object.matrixAutoUpdate = data.matrixAutoUpdate;
                if (object.matrixAutoUpdate)
                    object.matrix.decompose(object.position, object.quaternion, object.scale);
            }
            else {
                if (data.position !== undefined)
                    object.position.fromArray(data.position);
                if (data.rotation !== undefined)
                    object.rotation.fromArray(data.rotation);
                if (data.quaternion !== undefined)
                    object.quaternion.fromArray(data.quaternion);
                if (data.scale !== undefined)
                    object.scale.fromArray(data.scale);
            }
            if (data.castShadow !== undefined)
                object.castShadow = data.castShadow;
            if (data.receiveShadow !== undefined)
                object.receiveShadow = data.receiveShadow;
            if (data.shadow) {
                if (data.shadow.bias !== undefined)
                    object.shadow.bias = data.shadow.bias;
                if (data.shadow.radius !== undefined)
                    object.shadow.radius = data.shadow.radius;
                if (data.shadow.mapSize !== undefined)
                    object.shadow.mapSize.fromArray(data.shadow.mapSize);
                if (data.shadow.camera !== undefined)
                    object.shadow.camera = this.parseObject(data.shadow.camera);
            }
            if (data.visible !== undefined)
                object.visible = data.visible;
            if (data.frustumCulled !== undefined)
                object.frustumCulled = data.frustumCulled;
            if (data.renderOrder !== undefined)
                object.renderOrder = data.renderOrder;
            if (data.userData !== undefined)
                object.userData = data.userData;
            if (data.children !== undefined) {
                var children = data.children;
                for (var i = 0; i < children.length; i++) {
                    object.add(this.parseObject(children[i], geometries, materials));
                }
            }
            if (data.type === 'LOD') {
                var levels = data.levels;
                for (var l = 0; l < levels.length; l++) {
                    var level = levels[l];
                    var child = object.getObjectByProperty('uuid', level.object);
                    if (child !== undefined) {
                        object.addLevel(child, level.distance);
                    }
                }
            }
            return object;
        }
    }
    THREE.ObjectLoader = ObjectLoader;
    var TEXTURE_MAPPING = {
        UVMapping: THREE.UVMapping,
        CubeReflectionMapping: THREE.CubeReflectionMapping,
        CubeRefractionMapping: THREE.CubeRefractionMapping,
        EquirectangularReflectionMapping: THREE.EquirectangularReflectionMapping,
        EquirectangularRefractionMapping: THREE.EquirectangularRefractionMapping,
        SphericalReflectionMapping: THREE.SphericalReflectionMapping,
        CubeUVReflectionMapping: THREE.CubeUVReflectionMapping,
        CubeUVRefractionMapping: THREE.CubeUVRefractionMapping
    };
    var TEXTURE_WRAPPING = {
        RepeatWrapping: THREE.RepeatWrapping,
        ClampToEdgeWrapping: THREE.ClampToEdgeWrapping,
        MirroredRepeatWrapping: THREE.MirroredRepeatWrapping
    };
    var TEXTURE_FILTER = {
        NearestFilter: THREE.NearestFilter,
        NearestMipMapNearestFilter: THREE.NearestMipMapNearestFilter,
        NearestMipMapLinearFilter: THREE.NearestMipMapLinearFilter,
        LinearFilter: THREE.LinearFilter,
        LinearMipMapNearestFilter: THREE.LinearMipMapNearestFilter,
        LinearMipMapLinearFilter: THREE.LinearMipMapLinearFilter
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class TextureLoader {
        constructor(manager) {
            this.crossOrigin = 'Anonymous';
            this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        }
        //Object.assign(TextureLoader.prototype, {
        // crossOrigin: 'Anonymous',
        load(url, onLoad, onProgress, onError) {
            var texture = new THREE.Texture();
            var loader = new THREE.ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);
            loader.load(url, function (image) {
                texture.image = image;
                // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
                var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;
                texture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;
                texture.needsUpdate = true;
                if (onLoad !== undefined) {
                    onLoad(texture);
                }
            }, onProgress, onError);
            return texture;
        }
        setCrossOrigin(value) {
            this.crossOrigin = value;
            return this;
        }
        setPath(value) {
            this.path = value;
            return this;
        }
    }
    THREE.TextureLoader = TextureLoader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Material extends THREE.EventDispatcher {
        constructor() {
            super();
            this.isMaterial = true;
            this.id = Material.materialId++;
            this.uuid = THREE._Math.generateUUID();
            this.name = '';
            this.type = 'Material';
            this.fog = true;
            this.lights = true;
            this.blending = THREE.NormalBlending;
            this.side = THREE.FrontSide;
            this.flatShading = false;
            this.vertexColors = THREE.NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors
            this.opacity = 1;
            this.transparent = false;
            this.blendSrc = THREE.SrcAlphaFactor;
            this.blendDst = THREE.OneMinusSrcAlphaFactor;
            this.blendEquation = THREE.AddEquation;
            this.blendSrcAlpha = null;
            this.blendDstAlpha = null;
            this.blendEquationAlpha = null;
            this.depthFunc = THREE.LessEqualDepth;
            this.depthTest = true;
            this.depthWrite = true;
            this.clippingPlanes = null;
            this.clipIntersection = false;
            this.clipShadows = false;
            this.shadowSide = null;
            this.colorWrite = true;
            this.precision = null; // override the renderer's default precision for this material
            this.polygonOffset = false;
            this.polygonOffsetFactor = 0;
            this.polygonOffsetUnits = 0;
            this.dithering = false;
            this.alphaTest = 0;
            this.premultipliedAlpha = false;
            this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
            this.visible = true;
            this.userData = {};
            this.needsUpdate = true;
        }
        onBeforeCompile() { }
        setValues(values) {
            if (values === undefined)
                return;
            for (var key in values) {
                var newValue = values[key];
                if (newValue === undefined) {
                    console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                    continue;
                }
                // for backward compatability if shading is set in the constructor
                if (key === 'shading') {
                    console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                    this.flatShading = (newValue === THREE.FlatShading) ? true : false;
                    continue;
                }
                var currentValue = this[key];
                if (currentValue === undefined) {
                    console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                    continue;
                }
                if (currentValue && currentValue.isColor) {
                    currentValue.set(newValue);
                }
                else if ((currentValue && currentValue.isVector3) && (newValue && newValue.isVector3)) {
                    currentValue.copy(newValue);
                }
                else if (key === 'overdraw') {
                    // ensure overdraw is backwards-compatible with legacy boolean type
                    this[key] = Number(newValue);
                }
                else {
                    this[key] = newValue;
                }
            }
        }
        toJSON(meta) {
            var isRoot = (meta === undefined || typeof meta === 'string');
            if (isRoot) {
                meta = {
                    textures: {},
                    images: {}
                };
            }
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Material',
                    generator: 'Material.toJSON'
                }
            };
            // standard Material serialization
            data.uuid = this.uuid;
            data.type = this.type;
            var this_self = this;
            if (this_self.name !== '')
                data.name = this_self.name;
            if (this_self.color && this_self.color.isColor)
                data.color = this_self.color.getHex();
            if (this_self.roughness !== undefined)
                data.roughness = this_self.roughness;
            if (this_self.metalness !== undefined)
                data.metalness = this_self.metalness;
            if (this_self.emissive && this_self.emissive.isColor)
                data.emissive = this_self.emissive.getHex();
            if (this_self.emissiveIntensity !== 1)
                data.emissiveIntensity = this_self.emissiveIntensity;
            if (this_self.specular && this_self.specular.isColor)
                data.specular = this_self.specular.getHex();
            if (this_self.shininess !== undefined)
                data.shininess = this_self.shininess;
            if (this_self.clearCoat !== undefined)
                data.clearCoat = this_self.clearCoat;
            if (this_self.clearCoatRoughness !== undefined)
                data.clearCoatRoughness = this_self.clearCoatRoughness;
            if (this_self.map && this_self.map.isTexture)
                data.map = this_self.map.toJSON(meta).uuid;
            if (this_self.alphaMap && this_self.alphaMap.isTexture)
                data.alphaMap = this_self.alphaMap.toJSON(meta).uuid;
            if (this_self.lightMap && this_self.lightMap.isTexture)
                data.lightMap = this_self.lightMap.toJSON(meta).uuid;
            if (this_self.aoMap && this_self.aoMap.isTexture) {
                data.aoMap = this_self.aoMap.toJSON(meta).uuid;
                data.aoMapIntensity = this_self.aoMapIntensity;
            }
            if (this_self.bumpMap && this_self.bumpMap.isTexture) {
                data.bumpMap = this_self.bumpMap.toJSON(meta).uuid;
                data.bumpScale = this_self.bumpScale;
            }
            if (this_self.normalMap && this_self.normalMap.isTexture) {
                data.normalMap = this_self.normalMap.toJSON(meta).uuid;
                data.normalScale = this_self.normalScale.toArray();
            }
            if (this_self.displacementMap && this_self.displacementMap.isTexture) {
                data.displacementMap = this_self.displacementMap.toJSON(meta).uuid;
                data.displacementScale = this_self.displacementScale;
                data.displacementBias = this_self.displacementBias;
            }
            if (this_self.roughnessMap && this_self.roughnessMap.isTexture)
                data.roughnessMap = this_self.roughnessMap.toJSON(meta).uuid;
            if (this_self.metalnessMap && this_self.metalnessMap.isTexture)
                data.metalnessMap = this_self.metalnessMap.toJSON(meta).uuid;
            if (this_self.emissiveMap && this_self.emissiveMap.isTexture)
                data.emissiveMap = this_self.emissiveMap.toJSON(meta).uuid;
            if (this_self.specularMap && this_self.specularMap.isTexture)
                data.specularMap = this_self.specularMap.toJSON(meta).uuid;
            if (this_self.envMap && this_self.envMap.isTexture) {
                data.envMap = this_self.envMap.toJSON(meta).uuid;
                data.reflectivity = this_self.reflectivity; // Scale behind envMap
            }
            if (this_self.gradientMap && this_self.gradientMap.isTexture) {
                data.gradientMap = this_self.gradientMap.toJSON(meta).uuid;
            }
            if (this_self.size !== undefined)
                data.size = this_self.size;
            if (this_self.sizeAttenuation !== undefined)
                data.sizeAttenuation = this_self.sizeAttenuation;
            if (this_self.blending !== THREE.NormalBlending)
                data.blending = this_self.blending;
            if (this_self.flatShading === true)
                data.flatShading = this_self.flatShading;
            if (this_self.side !== THREE.FrontSide)
                data.side = this_self.side;
            if (this_self.vertexColors !== THREE.NoColors)
                data.vertexColors = this_self.vertexColors;
            if (this_self.opacity < 1)
                data.opacity = this_self.opacity;
            if (this_self.transparent === true)
                data.transparent = this_self.transparent;
            data.depthFunc = this_self.depthFunc;
            data.depthTest = this_self.depthTest;
            data.depthWrite = this_self.depthWrite;
            // rotation (SpriteMaterial)
            if (this_self.rotation !== 0)
                data.rotation = this_self.rotation;
            if (this_self.linewidth !== 1)
                data.linewidth = this_self.linewidth;
            if (this_self.dashSize !== undefined)
                data.dashSize = this_self.dashSize;
            if (this_self.gapSize !== undefined)
                data.gapSize = this_self.gapSize;
            if (this_self.scale !== undefined)
                data.scale = this_self.scale;
            if (this_self.dithering === true)
                data.dithering = true;
            if (this_self.alphaTest > 0)
                data.alphaTest = this_self.alphaTest;
            if (this_self.premultipliedAlpha === true)
                data.premultipliedAlpha = this_self.premultipliedAlpha;
            if (this_self.wireframe === true)
                data.wireframe = this_self.wireframe;
            if (this_self.wireframeLinewidth > 1)
                data.wireframeLinewidth = this_self.wireframeLinewidth;
            if (this_self.wireframeLinecap !== 'round')
                data.wireframeLinecap = this_self.wireframeLinecap;
            if (this_self.wireframeLinejoin !== 'round')
                data.wireframeLinejoin = this_self.wireframeLinejoin;
            if (this_self.morphTargets === true)
                data.morphTargets = true;
            if (this_self.skinning === true)
                data.skinning = true;
            if (this_self.visible === false)
                data.visible = false;
            if (JSON.stringify(this_self.userData) !== '{}')
                data.userData = this_self.userData;
            // TODO: Copied from Object3D.toJSON
            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
            if (isRoot) {
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                if (textures.length > 0)
                    data.textures = textures;
                if (images.length > 0)
                    data.images = images;
            }
            return data;
        }
        clone() {
            return new Material().copy(this);
        }
        copy(source) {
            this.name = source.name;
            this.fog = source.fog;
            this.lights = source.lights;
            this.blending = source.blending;
            this.side = source.side;
            this.flatShading = source.flatShading;
            this.vertexColors = source.vertexColors;
            this.opacity = source.opacity;
            this.transparent = source.transparent;
            this.blendSrc = source.blendSrc;
            this.blendDst = source.blendDst;
            this.blendEquation = source.blendEquation;
            this.blendSrcAlpha = source.blendSrcAlpha;
            this.blendDstAlpha = source.blendDstAlpha;
            this.blendEquationAlpha = source.blendEquationAlpha;
            this.depthFunc = source.depthFunc;
            this.depthTest = source.depthTest;
            this.depthWrite = source.depthWrite;
            this.colorWrite = source.colorWrite;
            this.precision = source.precision;
            this.polygonOffset = source.polygonOffset;
            this.polygonOffsetFactor = source.polygonOffsetFactor;
            this.polygonOffsetUnits = source.polygonOffsetUnits;
            this.dithering = source.dithering;
            this.alphaTest = source.alphaTest;
            this.premultipliedAlpha = source.premultipliedAlpha;
            this.overdraw = source.overdraw;
            this.visible = source.visible;
            this.userData = JSON.parse(JSON.stringify(source.userData));
            this.clipShadows = source.clipShadows;
            this.clipIntersection = source.clipIntersection;
            var srcPlanes = source.clippingPlanes, dstPlanes = null;
            if (srcPlanes !== null) {
                var n = srcPlanes.length;
                dstPlanes = new Array(n);
                for (var i = 0; i !== n; ++i)
                    dstPlanes[i] = srcPlanes[i].clone();
            }
            this.clippingPlanes = dstPlanes;
            this.shadowSide = source.shadowSide;
            return this;
        }
        dispose() {
            this.dispatchEvent({ type: 'dispose' });
        }
    }
    Material.materialId = 0;
    THREE.Material = Material;
})(THREE || (THREE = {}));
/// <reference path="./Material.ts" />
var THREE;
/// <reference path="./Material.ts" />
(function (THREE) {
    class LineBasicMaterial extends THREE.Material {
        constructor(parameters) {
            super();
            this.isLineBasicMaterial = true;
            this.type = 'LineBasicMaterial';
            this.color = new THREE.Color(0xffffff);
            this.linewidth = 1;
            this.linecap = 'round';
            this.linejoin = 'round';
            this.lights = false;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            this.linewidth = source.linewidth;
            this.linecap = source.linecap;
            this.linejoin = source.linejoin;
            return this;
        }
    }
    THREE.LineBasicMaterial = LineBasicMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class LineDashedMaterial extends THREE.LineBasicMaterial {
        constructor(parameters) {
            super();
            this.isLineDashedMaterial = true;
            this.type = 'LineDashedMaterial';
            this.scale = 1;
            this.dashSize = 3;
            this.gapSize = 1;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.scale = source.scale;
            this.dashSize = source.dashSize;
            this.gapSize = source.gapSize;
            return this;
        }
    }
    THREE.LineDashedMaterial = LineDashedMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class ShadowMaterial extends THREE.Material {
        constructor(parameters) {
            super();
            this.isShadowMaterial = true;
            this.type = 'ShadowMaterial';
            this.color = new THREE.Color(0x000000);
            this.transparent = true;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            return this;
        }
    }
    THREE.ShadowMaterial = ShadowMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class SpriteMaterial extends THREE.Material {
        constructor(parameters) {
            super();
            this.isSpriteMaterial = true;
            this.type = 'SpriteMaterial';
            this.color = new THREE.Color(0xffffff);
            this.map = null;
            this.rotation = 0;
            this.fog = false;
            this.lights = false;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            this.map = source.map;
            this.rotation = source.rotation;
            return this;
        }
    }
    THREE.SpriteMaterial = SpriteMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class ShaderMaterial extends THREE.Material {
        constructor(parameters) {
            super();
            this.isShaderMaterial = true;
            this.type = 'ShaderMaterial';
            this.defines = {};
            this.uniforms = {};
            this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
            this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
            this.linewidth = 1;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.fog = false; // set to use scene fog
            this.lights = false; // set to use scene lights
            this.clipping = false; // set to use user-defined clipping planes
            this.skinning = false; // set to use skinning attribute streams
            this.morphTargets = false; // set to use morph targets
            this.morphNormals = false; // set to use morph normals
            this.extensions = {
                derivatives: false,
                fragDepth: false,
                drawBuffers: false,
                shaderTextureLOD: false // set to use shader texture LOD
            };
            // When rendered geometry doesn't include these attributes but the material does,
            // use these default values in WebGL. This avoids errors when buffer data is missing.
            this.defaultAttributeValues = {
                'color': [1, 1, 1],
                'uv': [0, 0],
                'uv2': [0, 0]
            };
            this.index0AttributeName = undefined;
            this.uniformsNeedUpdate = false;
            if (parameters !== undefined) {
                if (parameters.attributes !== undefined) {
                    console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
                }
                this.setValues(parameters);
            }
        }
        copy(source) {
            super.copy(source);
            this.fragmentShader = source.fragmentShader;
            this.vertexShader = source.vertexShader;
            this.uniforms = UniformsUtils.clone(source.uniforms);
            this.defines = Object.assign({}, source.defines);
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.lights = source.lights;
            this.clipping = source.clipping;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;
            this.extensions = source.extensions;
            return this;
        }
        toJSON(meta) {
            var data = THREE.Material.prototype.toJSON.call(this, meta);
            data.uniforms = this.uniforms;
            data.vertexShader = this.vertexShader;
            data.fragmentShader = this.fragmentShader;
            return data;
        }
    }
    THREE.ShaderMaterial = ShaderMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class MeshStandardMaterial extends THREE.Material {
        constructor(parameters) {
            super();
            this.isMeshStandardMaterial = true;
            this.defines = { 'STANDARD': '' };
            this.type = 'MeshStandardMaterial';
            this.color = new THREE.Color(0xffffff); // diffuse
            this.roughness = 0.5;
            this.metalness = 0.5;
            this.map = null;
            this.lightMap = null;
            this.lightMapIntensity = 1.0;
            this.aoMap = null;
            this.aoMapIntensity = 1.0;
            this.emissive = new THREE.Color(0x000000);
            this.emissiveIntensity = 1.0;
            this.emissiveMap = null;
            this.bumpMap = null;
            this.bumpScale = 1;
            this.normalMap = null;
            this.normalScale = new THREE.Vector2(1, 1);
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.roughnessMap = null;
            this.metalnessMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.envMapIntensity = 1.0;
            this.refractionRatio = 0.98;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';
            this.skinning = false;
            this.morphTargets = false;
            this.morphNormals = false;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.defines = { 'STANDARD': '' };
            this.color.copy(source.color);
            this.roughness = source.roughness;
            this.metalness = source.metalness;
            this.map = source.map;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.emissive.copy(source.emissive);
            this.emissiveMap = source.emissiveMap;
            this.emissiveIntensity = source.emissiveIntensity;
            this.bumpMap = source.bumpMap;
            this.bumpScale = source.bumpScale;
            this.normalMap = source.normalMap;
            this.normalScale.copy(source.normalScale);
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.roughnessMap = source.roughnessMap;
            this.metalnessMap = source.metalnessMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.envMapIntensity = source.envMapIntensity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;
            return this;
        }
    }
    THREE.MeshStandardMaterial = MeshStandardMaterial;
})(THREE || (THREE = {}));
/// <reference path="./MeshStandardMaterial.ts" />
var THREE;
/// <reference path="./MeshStandardMaterial.ts" />
(function (THREE) {
    class MeshPhysicalMaterial extends THREE.MeshStandardMaterial {
        constructor(parameters) {
            super();
            this.isMeshPhysicalMaterial = true;
            this.defines = { 'PHYSICAL': '' };
            this.type = 'MeshPhysicalMaterial';
            this.reflectivity = 0.5; // maps to F0 = 0.04
            this.clearCoat = 0.0;
            this.clearCoatRoughness = 0.0;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.defines = { 'PHYSICAL': '' };
            this.reflectivity = source.reflectivity;
            this.clearCoat = source.clearCoat;
            this.clearCoatRoughness = source.clearCoatRoughness;
            return this;
        }
    }
    THREE.MeshPhysicalMaterial = MeshPhysicalMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class PointsMaterial extends THREE.Material {
        constructor(parameters) {
            super();
            this.isPointsMaterial = true;
            this.type = 'PointsMaterial';
            this.color = new THREE.Color(0xffffff);
            this.map = null;
            this.size = 1;
            this.sizeAttenuation = true;
            this.lights = false;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            this.map = source.map;
            this.size = source.size;
            this.sizeAttenuation = source.sizeAttenuation;
            return this;
        }
    }
    THREE.PointsMaterial = PointsMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class RawShaderMaterial extends THREE.ShaderMaterial {
        constructor(parameters) {
            // ShaderMaterial.call(this, parameters);
            super(parameters);
            this.isRawShaderMaterial = true;
            this.type = 'RawShaderMaterial';
        }
    }
    THREE.RawShaderMaterial = RawShaderMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class MeshPhongMaterial extends THREE.Material {
        constructor(parameters) {
            super();
            this.isMeshPhongMaterial = true;
            this.type = 'MeshPhongMaterial';
            this.color = new THREE.Color(0xffffff); // diffuse
            this.specular = new THREE.Color(0x111111);
            this.shininess = 30;
            this.map = null;
            this.lightMap = null;
            this.lightMapIntensity = 1.0;
            this.aoMap = null;
            this.aoMapIntensity = 1.0;
            this.emissive = new THREE.Color(0x000000);
            this.emissiveIntensity = 1.0;
            this.emissiveMap = null;
            this.bumpMap = null;
            this.bumpScale = 1;
            this.normalMap = null;
            this.normalScale = new THREE.Vector2(1, 1);
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.specularMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.combine = THREE.MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = 0.98;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';
            this.skinning = false;
            this.morphTargets = false;
            this.morphNormals = false;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            this.specular.copy(source.specular);
            this.shininess = source.shininess;
            this.map = source.map;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.emissive.copy(source.emissive);
            this.emissiveMap = source.emissiveMap;
            this.emissiveIntensity = source.emissiveIntensity;
            this.bumpMap = source.bumpMap;
            this.bumpScale = source.bumpScale;
            this.normalMap = source.normalMap;
            this.normalScale.copy(source.normalScale);
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.specularMap = source.specularMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;
            return this;
        }
    }
    THREE.MeshPhongMaterial = MeshPhongMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class MeshToonMaterial extends THREE.MeshPhongMaterial {
        constructor(parameters) {
            super();
            this.isMeshToonMaterial = true;
            this.defines = { 'TOON': '' };
            this.type = 'MeshToonMaterial';
            this.gradientMap = null;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.gradientMap = source.gradientMap;
            return this;
        }
    }
    THREE.MeshToonMaterial = MeshToonMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class MeshNormalMaterial extends THREE.Material {
        constructor(parameters) {
            super();
            this.isMeshNormalMaterial = true;
            this.type = 'MeshNormalMaterial';
            this.bumpMap = null;
            this.bumpScale = 1;
            this.normalMap = null;
            this.normalScale = new THREE.Vector2(1, 1);
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.fog = false;
            this.lights = false;
            this.skinning = false;
            this.morphTargets = false;
            this.morphNormals = false;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.bumpMap = source.bumpMap;
            this.bumpScale = source.bumpScale;
            this.normalMap = source.normalMap;
            this.normalScale.copy(source.normalScale);
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;
            return this;
        }
    }
    THREE.MeshNormalMaterial = MeshNormalMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class MeshLambertMaterial extends THREE.Material {
        constructor(parameters) {
            super();
            this.isMeshLambertMaterial = true;
            this.type = 'MeshLambertMaterial';
            this.color = new THREE.Color(0xffffff); // diffuse
            this.map = null;
            this.lightMap = null;
            this.lightMapIntensity = 1.0;
            this.aoMap = null;
            this.aoMapIntensity = 1.0;
            this.emissive = new THREE.Color(0x000000);
            this.emissiveIntensity = 1.0;
            this.emissiveMap = null;
            this.specularMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.combine = THREE.MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = 0.98;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';
            this.skinning = false;
            this.morphTargets = false;
            this.morphNormals = false;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            this.map = source.map;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.emissive.copy(source.emissive);
            this.emissiveMap = source.emissiveMap;
            this.emissiveIntensity = source.emissiveIntensity;
            this.specularMap = source.specularMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.morphNormals = source.morphNormals;
            return this;
        }
    }
    THREE.MeshLambertMaterial = MeshLambertMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class MeshDepthMaterial extends THREE.Material {
        constructor(parameters) {
            super();
            this.isMeshDepthMaterial = true;
            this.type = 'MeshDepthMaterial';
            this.depthPacking = THREE.BasicDepthPacking;
            this.skinning = false;
            this.morphTargets = false;
            this.map = null;
            this.alphaMap = null;
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.fog = false;
            this.lights = false;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.depthPacking = source.depthPacking;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.map = source.map;
            this.alphaMap = source.alphaMap;
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            return this;
        }
    }
    THREE.MeshDepthMaterial = MeshDepthMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class MeshDistanceMaterial extends THREE.Material {
        constructor(parameters) {
            super();
            this.isMeshDistanceMaterial = true;
            this.type = 'MeshDistanceMaterial';
            this.referencePosition = new THREE.Vector3();
            this.nearDistance = 1;
            this.farDistance = 1000;
            this.skinning = false;
            this.morphTargets = false;
            this.map = null;
            this.alphaMap = null;
            this.displacementMap = null;
            this.displacementScale = 1;
            this.displacementBias = 0;
            this.fog = false;
            this.lights = false;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.referencePosition.copy(source.referencePosition);
            this.nearDistance = source.nearDistance;
            this.farDistance = source.farDistance;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            this.map = source.map;
            this.alphaMap = source.alphaMap;
            this.displacementMap = source.displacementMap;
            this.displacementScale = source.displacementScale;
            this.displacementBias = source.displacementBias;
            return this;
        }
    }
    THREE.MeshDistanceMaterial = MeshDistanceMaterial;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class MeshBasicMaterial extends THREE.Material {
        constructor(parameters) {
            super();
            this.isMeshBasicMaterial = true;
            this.type = 'MeshBasicMaterial';
            this.color = new THREE.Color(0xffffff); // emissive
            this.map = null;
            this.lightMap = null;
            this.lightMapIntensity = 1.0;
            this.aoMap = null;
            this.aoMapIntensity = 1.0;
            this.specularMap = null;
            this.alphaMap = null;
            this.envMap = null;
            this.combine = THREE.MultiplyOperation;
            this.reflectivity = 1;
            this.refractionRatio = 0.98;
            this.wireframe = false;
            this.wireframeLinewidth = 1;
            this.wireframeLinecap = 'round';
            this.wireframeLinejoin = 'round';
            this.skinning = false;
            this.morphTargets = false;
            this.lights = false;
            this.setValues(parameters);
        }
        copy(source) {
            super.copy(source);
            this.color.copy(source.color);
            this.map = source.map;
            this.lightMap = source.lightMap;
            this.lightMapIntensity = source.lightMapIntensity;
            this.aoMap = source.aoMap;
            this.aoMapIntensity = source.aoMapIntensity;
            this.specularMap = source.specularMap;
            this.alphaMap = source.alphaMap;
            this.envMap = source.envMap;
            this.combine = source.combine;
            this.reflectivity = source.reflectivity;
            this.refractionRatio = source.refractionRatio;
            this.wireframe = source.wireframe;
            this.wireframeLinewidth = source.wireframeLinewidth;
            this.wireframeLinecap = source.wireframeLinecap;
            this.wireframeLinejoin = source.wireframeLinejoin;
            this.skinning = source.skinning;
            this.morphTargets = source.morphTargets;
            return this;
        }
    }
    THREE.MeshBasicMaterial = MeshBasicMaterial;
})(THREE || (THREE = {}));
/// <reference path="./ShadowMaterial.ts" />
/// <reference path="./SpriteMaterial.ts" />
/// <reference path="./ShaderMaterial.ts" />
/// <reference path="./MeshPhysicalMaterial.ts" />
/// <reference path="./PointsMaterial.ts" />
/// <reference path="./RawShaderMaterial.ts" />
/// <reference path="./MeshStandardMaterial.ts" />
/// <reference path="./MeshPhongMaterial.ts" />
/// <reference path="./MeshToonMaterial.ts" />
/// <reference path="./MeshNormalMaterial.ts" />
/// <reference path="./MeshLambertMaterial.ts" />
/// <reference path="./MeshDepthMaterial.ts" />
/// <reference path="./MeshDistanceMaterial.ts" />
/// <reference path="./MeshBasicMaterial.ts" />
var THREE;
/// <reference path="./ShadowMaterial.ts" />
/// <reference path="./SpriteMaterial.ts" />
/// <reference path="./ShaderMaterial.ts" />
/// <reference path="./MeshPhysicalMaterial.ts" />
/// <reference path="./PointsMaterial.ts" />
/// <reference path="./RawShaderMaterial.ts" />
/// <reference path="./MeshStandardMaterial.ts" />
/// <reference path="./MeshPhongMaterial.ts" />
/// <reference path="./MeshToonMaterial.ts" />
/// <reference path="./MeshNormalMaterial.ts" />
/// <reference path="./MeshLambertMaterial.ts" />
/// <reference path="./MeshDepthMaterial.ts" />
/// <reference path="./MeshDistanceMaterial.ts" />
/// <reference path="./MeshBasicMaterial.ts" />
(function (THREE) {
    THREE.Materials = {
        "ShadowMaterial": THREE.ShadowMaterial,
        "SpriteMaterial": THREE.SpriteMaterial,
        "RawShaderMaterial": THREE.RawShaderMaterial,
        "ShaderMaterial": THREE.ShaderMaterial,
        "PointsMaterial": THREE.PointsMaterial,
        "MeshPhysicalMaterial": THREE.MeshPhysicalMaterial,
        "MeshStandardMaterial": THREE.MeshStandardMaterial,
        "MeshPhongMaterial": THREE.MeshPhongMaterial,
        "MeshToonMaterial": THREE.MeshToonMaterial,
        "MeshNormalMaterial": THREE.MeshNormalMaterial,
        "MeshLambertMaterial": THREE.MeshLambertMaterial,
        "MeshDepthMaterial": THREE.MeshDepthMaterial,
        "MeshDistanceMaterial": THREE.MeshDistanceMaterial,
        "MeshBasicMaterial": THREE.MeshBasicMaterial,
        "LineDashedMaterial": THREE.LineDashedMaterial,
        "LineBasicMaterial": THREE.LineBasicMaterial,
        "Material": THREE.Material
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    /**
     * @author Yanbei.HUANG
     * @description 2018/5/15
     */
    class Box2 {
        /**构造函数 */
        constructor(min, max) {
            this.min = (min !== undefined) ? min : new THREE.Vector2(+Infinity, +Infinity);
            this.max = (max !== undefined) ? max : new THREE.Vector2(-Infinity, -Infinity);
        }
        /**
         * 设置最大值和最小值
         * @param min
         * @param max
         */
        set(min, max) {
            this.min.copy(min);
            this.max.copy(max);
            return this;
        }
        /**
         * 由点序列生成box
         * @param points
         */
        setFromPoints(points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
            }
            return this;
        }
        /**
         * 把box置空
         */
        makeEmpty() {
            this.min.x = this.min.y = +Infinity;
            this.max.x = this.max.y = -Infinity;
            return this;
        }
        /**
         * 由点扩充
         * @param point
         */
        expandByPoint(point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        }
        /**
         * 根据中心点和尺寸
         * @param center
         * @param size
         */
        setFromCenterAndSize(center, size) {
            var v1 = new THREE.Vector2();
            var halfSize = v1.setScalar(size).multiplyScalar(0.5);
            this.min.copy(center).sub(halfSize);
            this.max.copy(center).add(halfSize);
            return this;
        }
        ;
        /**
         * 克隆
         */
        clone() {
            var box = new Box2().copy(this);
            return box;
        }
        /**
         * box2
         * @param box
         */
        copy(box) {
            this.min.copy(box.min);
            this.max.copy(box.max);
            return this;
        }
        /**
         * 判断是否为空
         */
        isEmpty() {
            return (this.max.x < this.min.x) || (this.max.y < this.min.y);
        }
        /**
         * 得到中心点
         * @param target
         */
        getCenter(target) {
            if (target === undefined) {
                console.warn('THREE.Box2: .getCenter() target is now required');
                target = new THREE.Vector2();
            }
            return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        /**
         * 得到对角线长度
         * @param target
         */
        getSize(target) {
            if (target === undefined) {
                console.warn('THREE.Box2: .getSize() target is now required');
                target = new THREE.Vector2();
            }
            return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
        }
        /**
         * 由一个向量扩展
         * @param vector
         */
        expandByVector(vector) {
            this.min.sub(vector);
            this.max.add(vector);
            return this;
        }
        /**
         * 由缩放倍数扩展
         * @param scalar
         */
        expandByScalar(scalar) {
            this.min.addScalar(-scalar);
            this.max.addScalar(scalar);
            return this;
        }
        /**
         * 判断点是否在盒子内
         * @param point
         */
        containsPoint(point) {
            return point.x < this.min.x || point.x > this.max.x ||
                point.y < this.min.y || point.y > this.max.y ? false : true;
        }
        /**
         * 判断盒子是否在大盒子内
         * @param box
         */
        containsBox(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x &&
                this.min.y <= box.min.y && box.max.y <= this.max.y;
        }
        /**
         * 获取点在空间内的位置，归一化的位置，
         * @param point
         * @param target
         */
        getParameter(point, target) {
            if (target === undefined) {
                console.warn('THREE.Box2: .getParameter() target is now required');
                target = new THREE.Vector2();
            }
            return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
        }
        /**
         * 盒子交叉
         * @param box
         */
        intersectsBox(box) {
            // using 4 splitting planes to rule out intersections
            return box.max.x < this.min.x || box.min.x > this.max.x ||
                box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
        }
        /**
         * 获取点在对角线上的比例
         * @param point
         * @param target
         */
        clampPoint(point, target) {
            if (target === undefined) {
                console.warn('THREE.Box2: .clampPoint() target is now required');
                target = new THREE.Vector2();
            }
            return target.copy(point).clamp(this.min, this.max);
        }
        /**
         *
         * @param point
         */
        distanceToPoint(point) {
            var v1 = new THREE.Vector2();
            var clampedPoint = v1.copy(point).clamp(this.min, this.max);
            return clampedPoint.sub(point).length();
        }
        /**
         * 交叉
         * @param box
         */
        intersect(box) {
            this.min.max(box.min);
            this.max.min(box.max);
            return this;
        }
        /**
         * 合并
         * @param box
         */
        union(box) {
            this.min.min(box.min);
            this.max.max(box.max);
            return this;
        }
        /**
         * 平移
         * @param offset
         */
        translate(offset) {
            this.min.add(offset);
            this.max.add(offset);
            return this;
        }
        /**
         * 判断两个盒子是否相等
         * @param box
         */
        equals(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
    }
    THREE.Box2 = Box2;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Box3 {
        constructor(min, max) {
            this.isBox3 = true;
            this.min = (min !== undefined) ? min : new THREE.Vector3(+Infinity, +Infinity, +Infinity);
            this.max = (max !== undefined) ? max : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
        }
        set(min, max) {
            this.min.copy(min);
            this.max.copy(max);
            return this;
        }
        setFromArray(array) {
            var minX = +Infinity;
            var minY = +Infinity;
            var minZ = +Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            var maxZ = -Infinity;
            for (var i = 0, l = array.length; i < l; i += 3) {
                var x = array[i];
                var y = array[i + 1];
                var z = array[i + 2];
                if (x < minX)
                    minX = x;
                if (y < minY)
                    minY = y;
                if (z < minZ)
                    minZ = z;
                if (x > maxX)
                    maxX = x;
                if (y > maxY)
                    maxY = y;
                if (z > maxZ)
                    maxZ = z;
            }
            this.min.set(minX, minY, minZ);
            this.max.set(maxX, maxY, maxZ);
            return this;
        }
        /**
         *
         * @param attribute bufferAttribute带有getX方法的点集
         */
        setFromBufferAttribute(attribute) {
            var minX = +Infinity;
            var minY = +Infinity;
            var minZ = +Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            var maxZ = -Infinity;
            for (var i = 0, l = attribute.count; i < l; i++) {
                var x = attribute.getX(i);
                var y = attribute.getY(i);
                var z = attribute.getZ(i);
                if (x < minX)
                    minX = x;
                if (y < minY)
                    minY = y;
                if (z < minZ)
                    minZ = z;
                if (x > maxX)
                    maxX = x;
                if (y > maxY)
                    maxY = y;
                if (z > maxZ)
                    maxZ = z;
            }
            this.min.set(minX, minY, minZ);
            this.max.set(maxX, maxY, maxZ);
            return this;
        }
        setFromPoints(points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
            }
            return this;
        }
        setFromCenterAndSize(center, size) {
            var halfSize = Box3.v1.copy(size).multiplyScalar(0.5);
            this.min.copy(center).sub(halfSize);
            this.max.copy(center).add(halfSize);
            return this;
        }
        setFromObject(object) {
            this.makeEmpty();
            return this.expandByObject(object);
        }
        clone() {
            return new Box3().copy(this);
        }
        copy(box) {
            this.min.copy(box.min);
            this.max.copy(box.max);
            return this;
        }
        makeEmpty() {
            this.min.x = this.min.y = this.min.z = +Infinity;
            this.max.x = this.max.y = this.max.z = -Infinity;
            return this;
        }
        isEmpty() {
            // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
            return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
        }
        getCenter(target) {
            if (target === undefined) {
                console.warn('THREE.Box3: .getCenter() target is now required');
                target = new THREE.Vector3();
            }
            return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(target) {
            if (target === undefined) {
                console.warn('THREE.Box3: .getSize() target is now required');
                target = new THREE.Vector3();
            }
            return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
        }
        expandByPoint(point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        }
        expandByVector(vector) {
            this.min.sub(vector);
            this.max.add(vector);
            return this;
        }
        expandByScalar(scalar) {
            this.min.addScalar(-scalar);
            this.max.addScalar(scalar);
            return this;
        }
        //public static v1: Vector3 = new Vector3();
        traverse(node) {
            var geometry = node.geometry;
            if (geometry !== undefined) {
                if (geometry.isGeometry) {
                    var vertices = geometry.vertices;
                    for (var i = 0, l = vertices.length; i < l; i++) {
                        Box3.v1.copy(vertices[i]);
                        Box3.v1.applyMatrix4(node.matrixWorld);
                        this.expandByPoint(Box3.v1);
                    }
                }
                else if (geometry.isBufferGeometry) {
                    var attribute = geometry.attributes.position;
                    if (attribute !== undefined) {
                        for (var i = 0, l = attribute.count; i < l; i++) {
                            Box3.v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
                            this.expandByPoint(Box3.v1);
                        }
                    }
                }
            }
        }
        expandByObject(object) {
            // Computes the world-axis-aligned bounding box of an object (including its children),
            // accounting for both the object's, and children's, world transforms
            object.updateMatrixWorld(true);
            object.traverse((node) => { this.traverse(node); });
            return this;
        }
        containsPoint(point) {
            return point.x < this.min.x || point.x > this.max.x ||
                point.y < this.min.y || point.y > this.max.y ||
                point.z < this.min.z || point.z > this.max.z ? false : true;
        }
        containsBox(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x &&
                this.min.y <= box.min.y && box.max.y <= this.max.y &&
                this.min.z <= box.min.z && box.max.z <= this.max.z;
        }
        getParameter(point, target) {
            // This can potentially have a divide by zero if the box
            // has a size dimension of 0.
            if (target === undefined) {
                console.warn('THREE.Box3: .getParameter() target is now required');
                target = new THREE.Vector3();
            }
            return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(box) {
            // using 6 splitting planes to rule out intersections.
            return box.max.x < this.min.x || box.min.x > this.max.x ||
                box.max.y < this.min.y || box.min.y > this.max.y ||
                box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
        }
        intersectsSphere(sphere) {
            // Find the point on the AABB closest to the sphere center.
            this.clampPoint(sphere.center, Box3.closestPoint);
            // If that point is inside the sphere, the AABB and sphere intersect.
            return Box3.closestPoint.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);
        }
        intersectsPlane(plane) {
            // We compute the minimum and maximum dot product values. If those values
            // are on the same side (back or front) of the plane, then there is no intersection.
            var min, max;
            if (plane.normal.x > 0) {
                min = plane.normal.x * this.min.x;
                max = plane.normal.x * this.max.x;
            }
            else {
                min = plane.normal.x * this.max.x;
                max = plane.normal.x * this.min.x;
            }
            if (plane.normal.y > 0) {
                min += plane.normal.y * this.min.y;
                max += plane.normal.y * this.max.y;
            }
            else {
                min += plane.normal.y * this.max.y;
                max += plane.normal.y * this.min.y;
            }
            if (plane.normal.z > 0) {
                min += plane.normal.z * this.min.z;
                max += plane.normal.z * this.max.z;
            }
            else {
                min += plane.normal.z * this.max.z;
                max += plane.normal.z * this.min.z;
            }
            return (min <= plane.constant && max >= plane.constant);
        }
        //   public intersectsTriangle: (function () {
        satForAxes(axes) {
            var i, j;
            for (i = 0, j = axes.length - 3; i <= j; i += 3) {
                Box3.testAxis.fromArray(axes, i);
                // project the aabb onto the seperating axis
                var r = Box3.extents.x * Math.abs(Box3.testAxis.x) + Box3.extents.y * Math.abs(Box3.testAxis.y) + Box3.extents.z * Math.abs(Box3.testAxis.z);
                // project all 3 vertices of the triangle onto the seperating axis
                var p0 = Box3.v0.dot(Box3.testAxis);
                var p1 = Box3.v1.dot(Box3.testAxis);
                var p2 = Box3.v2.dot(Box3.testAxis);
                // actual test, basically see if either of the most extreme of the triangle points intersects r
                if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
                    // points of the projected triangle are outside the projected half-length of the aabb
                    // the axis is seperating and we can exit
                    return false;
                }
            }
            return true;
        }
        intersectsTriangle(triangle) {
            if (this.isEmpty()) {
                return false;
            }
            // compute box center and extents
            this.getCenter(Box3.center);
            Box3.extents.subVectors(this.max, Box3.center);
            // translate triangle to aabb origin
            Box3.v0.subVectors(triangle.a, Box3.center);
            Box3.v1.subVectors(triangle.b, Box3.center);
            Box3.v2.subVectors(triangle.c, Box3.center);
            // compute edge vectors for triangle
            Box3.f0.subVectors(Box3.v1, Box3.v0);
            Box3.f1.subVectors(Box3.v2, Box3.v1);
            Box3.f2.subVectors(Box3.v0, Box3.v2);
            // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
            // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
            // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
            var axes = [
                0, -Box3.f0.z, Box3.f0.y, 0, -Box3.f1.z, Box3.f1.y, 0, -Box3.f2.z, Box3.f2.y,
                Box3.f0.z, 0, -Box3.f0.x, Box3.f1.z, 0, -Box3.f1.x, Box3.f2.z, 0, -Box3.f2.x,
                -Box3.f0.y, Box3.f0.x, 0, -Box3.f1.y, Box3.f1.x, 0, -Box3.f2.y, Box3.f2.x, 0
            ];
            if (!this.satForAxes(axes)) {
                return false;
            }
            // test 3 face normals from the aabb
            axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
            if (!this.satForAxes(axes)) {
                return false;
            }
            // finally testing the face normal of the triangle
            // use already existing triangle edge vectors here
            Box3.triangleNormal.crossVectors(Box3.f0, Box3.f1);
            axes = [Box3.triangleNormal.x, Box3.triangleNormal.y, Box3.triangleNormal.z];
            return this.satForAxes(axes);
        }
        clampPoint(point, target) {
            if (target === undefined) {
                console.warn('THREE.Box3: .clampPoint() target is now required');
                target = new THREE.Vector3();
            }
            return target.copy(point).clamp(this.min, this.max);
        }
        //public static v1 = new Vector3();
        distanceToPoint(point) {
            var clampedPoint = Box3.v1.copy(point).clamp(this.min, this.max);
            return clampedPoint.sub(point).length();
        }
        //public static v1 = new Vector3();
        getBoundingSphere(target) {
            if (target === undefined) {
                console.warn('THREE.Box3: .getBoundingSphere() target is now required');
                target = new THREE.Sphere();
            }
            this.getCenter(target.center);
            target.radius = this.getSize(Box3.v1).length() * 0.5;
            return target;
        }
        intersect(box) {
            this.min.max(box.min);
            this.max.min(box.max);
            // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
            if (this.isEmpty())
                this.makeEmpty();
            return this;
        }
        union(box) {
            this.min.min(box.min);
            this.max.max(box.max);
            return this;
        }
        /**
         * @param matrix
         */
        applyMatrix4(matrix) {
            // @TODO
            // transform of empty box is an empty box.
            if (this.isEmpty())
                return this;
            var m = matrix.elements;
            var xax = m[0] * this.min.x, xay = m[1] * this.min.x, xaz = m[2] * this.min.x;
            var xbx = m[0] * this.max.x, xby = m[1] * this.max.x, xbz = m[2] * this.max.x;
            var yax = m[4] * this.min.y, yay = m[5] * this.min.y, yaz = m[6] * this.min.y;
            var ybx = m[4] * this.max.y, yby = m[5] * this.max.y, ybz = m[6] * this.max.y;
            var zax = m[8] * this.min.z, zay = m[9] * this.min.z, zaz = m[10] * this.min.z;
            var zbx = m[8] * this.max.z, zby = m[9] * this.max.z, zbz = m[10] * this.max.z;
            this.min.x = Math.min(xax, xbx) + Math.min(yax, ybx) + Math.min(zax, zbx) + m[12];
            this.min.y = Math.min(xay, xby) + Math.min(yay, yby) + Math.min(zay, zby) + m[13];
            this.min.z = Math.min(xaz, xbz) + Math.min(yaz, ybz) + Math.min(zaz, zbz) + m[14];
            this.max.x = Math.max(xax, xbx) + Math.max(yax, ybx) + Math.max(zax, zbx) + m[12];
            this.max.y = Math.max(xay, xby) + Math.max(yay, yby) + Math.max(zay, zby) + m[13];
            this.max.z = Math.max(xaz, xbz) + Math.max(yaz, ybz) + Math.max(zaz, zbz) + m[14];
            return this;
        }
        translate(offset) {
            this.min.add(offset);
            this.max.add(offset);
            return this;
        }
        equals(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
    }
    Box3.v1 = new THREE.Vector3();
    // intersectsSphere: (function () {
    //    var closestPoint = new Vector3();
    //    return function intersectsSphere(sphere) {
    //       // Find the point on the AABB closest to the sphere center.
    //       this.clampPoint(sphere.center, closestPoint);
    //       // If that point is inside the sphere, the AABB and sphere intersect.
    //       return closestPoint.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);
    //    };
    // }) (),
    Box3.closestPoint = new THREE.Vector3();
    // triangle centered vertices
    Box3.v0 = new THREE.Vector3();
    //public static v1: Vector3 = new Vector3();
    Box3.v2 = new THREE.Vector3();
    // triangle edge vectors
    Box3.f0 = new THREE.Vector3();
    Box3.f1 = new THREE.Vector3();
    Box3.f2 = new THREE.Vector3();
    Box3.testAxis = new THREE.Vector3();
    Box3.center = new THREE.Vector3();
    Box3.extents = new THREE.Vector3();
    Box3.triangleNormal = new THREE.Vector3();
    THREE.Box3 = Box3;
})(THREE || (THREE = {}));
var ColorKeywords = {
    'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
    'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
    'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
    'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
    'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
    'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
    'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32
};
var isColor;
var r, g, b;
var THREE;
(function (THREE) {
    class Color {
        constructor(r, g, b) {
            this.r = null;
            this.g = null;
            this.b = null;
            if (g === undefined && b === undefined) {
                // r is THREE.Color, hex or string
                this.set(r);
            }
            else {
                this.setRGB(r, g, b);
            }
        }
        set(value) {
            if (value && value instanceof Color) {
                this.copy(value);
            }
            else if (typeof value === 'number') {
                this.setHex(value);
            }
            else if (typeof value === 'string') {
                this.setStyle(value);
            }
            return this;
        }
        setScalar(scalar) {
            this.r = scalar;
            this.g = scalar;
            this.b = scalar;
            return this;
        }
        /**
         *
         * @param hex
         */
        setHex(hex) {
            hex = Math.floor(hex);
            this.r = (hex >> 16 & 255) / 255;
            this.g = (hex >> 8 & 255) / 255;
            this.b = (hex & 255) / 255;
            return this;
        }
        setRGB(r, g, b) {
            this.r = r;
            this.g = g;
            this.b = b;
            return this;
        }
        hue2rgb(p, q, t) {
            if (t < 0)
                t += 1;
            if (t > 1)
                t -= 1;
            if (t < 1 / 6)
                return p + (q - p) * 6 * t;
            if (t < 1 / 2)
                return q;
            if (t < 2 / 3)
                return p + (q - p) * 6 * (2 / 3 - t);
            return p;
        }
        setHSL(h, s, l) {
            // h,s,l ranges are in 0.0 - 1.0
            h = THREE._Math.euclideanModulo(h, 1);
            s = THREE._Math.clamp(s, 0, 1);
            l = THREE._Math.clamp(l, 0, 1);
            if (s === 0) {
                this.r = this.g = this.b = l;
            }
            else {
                var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
                var q = (2 * l) - p;
                this.r = this.hue2rgb(q, p, h + 1 / 3);
                this.g = this.hue2rgb(q, p, h);
                this.b = this.hue2rgb(q, p, h - 1 / 3);
            }
            return this;
        }
        ;
        setStyle(style) {
            function handleAlpha(str) {
                if (str === undefined)
                    return;
                if (parseFloat(str) < 1) {
                    console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
                }
            }
            var m;
            if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
                // rgb / hsl
                var color;
                var name = m[1];
                var components = m[2];
                switch (name) {
                    case 'rgb':
                    case 'rgba':
                        if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                            // rgb(255,0,0) rgba(255,0,0,0.5)
                            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                            handleAlpha(color[5]);
                            return this;
                        }
                        if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                            handleAlpha(color[5]);
                            return this;
                        }
                        break;
                    case 'hsl':
                    case 'hsla':
                        if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                            var h = parseFloat(color[1]) / 360;
                            var s = parseInt(color[2], 10) / 100;
                            var l = parseInt(color[3], 10) / 100;
                            handleAlpha(color[5]);
                            return this.setHSL(h, s, l);
                        }
                        break;
                }
            }
            else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
                // hex color
                var hex = m[1];
                var size = hex.length;
                if (size === 3) {
                    // #ff0
                    this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                    this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                    this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                    return this;
                }
                else if (size === 6) {
                    // #ff0000
                    this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                    this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                    this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                    return this;
                }
            }
            if (style && style.length > 0) {
                // color keywords
                hex = ColorKeywords[style];
                if (hex !== undefined) {
                    // red
                    this.setHex(hex);
                }
                else {
                    // unknown color
                    console.warn('THREE.Color: Unknown color ' + style);
                }
            }
            return this;
        }
        clone() {
            var color = new Color(this.r, this.g, this.b);
            return color;
        }
        copy(color) {
            this.r = color.r;
            this.g = color.g;
            this.b = color.b;
            return this;
        }
        copyGammaToLinear(color, gammaFactor) {
            if (gammaFactor === undefined)
                gammaFactor = 2.0;
            this.r = Math.pow(color.r, gammaFactor);
            this.g = Math.pow(color.g, gammaFactor);
            this.b = Math.pow(color.b, gammaFactor);
            return this;
        }
        copyLinearToGamma(color, gammaFactor) {
            if (gammaFactor === undefined)
                gammaFactor = 2.0;
            var safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;
            this.r = Math.pow(color.r, safeInverse);
            this.g = Math.pow(color.g, safeInverse);
            this.b = Math.pow(color.b, safeInverse);
            return this;
        }
        convertGammaToLinear(gammaFactor) {
            this.copyGammaToLinear(this, gammaFactor);
            return this;
        }
        convertLinearToGamma(gammaFactor) {
            this.copyLinearToGamma(this, gammaFactor);
            return this;
        }
        getHex() {
            return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
        }
        getHexString() {
            return ('000000' + this.getHex().toString(16)).slice(-6);
        }
        getHSL(target) {
            // h,s,l ranges are in 0.0 - 1.0
            if (target === undefined) {
                console.warn('THREE.Color: .getHSL() target is now required');
                target = { h: 0, s: 0, l: 0 };
            }
            var r = this.r, g = this.g, b = this.b;
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var hue;
            var saturation;
            var lightness = (min + max) / 2.0;
            if (min === max) {
                hue = 0;
                saturation = 0;
            }
            else {
                var delta = max - min;
                saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
                switch (max) {
                    case r:
                        hue = (g - b) / delta + (g < b ? 6 : 0);
                        break;
                    case g:
                        hue = (b - r) / delta + 2;
                        break;
                    case b:
                        hue = (r - g) / delta + 4;
                        break;
                }
                hue /= 6;
            }
            target.h = hue;
            target.s = saturation;
            target.l = lightness;
            return target;
        }
        getStyle() {
            return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';
        }
        offsetHSL(h, s, l) {
            var hsl = {};
            this.getHSL(hsl);
            hsl.h += h;
            hsl.s += s;
            hsl.l += l;
            this.setHSL(hsl.h, hsl.s, hsl.l);
            return this;
        }
        ;
        add(color) {
            this.r += color.r;
            this.g += color.g;
            this.b += color.b;
            return this;
        }
        addColors(color1, color2) {
            this.r = color1.r + color2.r;
            this.g = color1.g + color2.g;
            this.b = color1.b + color2.b;
            return this;
        }
        addScalar(s) {
            this.r += s;
            this.g += s;
            this.b += s;
            return this;
        }
        sub(color) {
            this.r = Math.max(0, this.r - color.r);
            this.g = Math.max(0, this.g - color.g);
            this.b = Math.max(0, this.b - color.b);
            return this;
        }
        multiply(color) {
            this.r *= color.r;
            this.g *= color.g;
            this.b *= color.b;
            return this;
        }
        multiplyScalar(s) {
            this.r *= s;
            this.g *= s;
            this.b *= s;
            return this;
        }
        lerp(color, alpha) {
            this.r += (color.r - this.r) * alpha;
            this.g += (color.g - this.g) * alpha;
            this.b += (color.b - this.b) * alpha;
            return this;
        }
        equals(c) {
            return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
        }
        fromArray(array, offset) {
            if (offset === undefined)
                offset = 0;
            this.r = array[offset];
            this.g = array[offset + 1];
            this.b = array[offset + 2];
            return this;
        }
        toArray(array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            array[offset] = this.r;
            array[offset + 1] = this.g;
            array[offset + 2] = this.b;
            return array;
        }
        toJSON() {
            return this.getHex();
        }
    }
    THREE.Color = Color;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Cylindrical {
        constructor(radius, theta, y) {
            this.radius = (radius !== undefined) ? radius : 1.0; // distance from the origin to a point in the x-z plane
            this.theta = (theta !== undefined) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
            this.y = (y !== undefined) ? y : 0; // height above the x-z plane
        }
        set(radius, theta, y) {
            this.radius = radius;
            this.theta = theta;
            this.y = y;
            return this;
        }
        clone() {
            var cylindrical = new Cylindrical();
            cylindrical.copy(this);
            return cylindrical;
        }
        copy(other) {
            this.radius = other.radius;
            this.theta = other.theta;
            this.y = other.y;
            return this;
        }
        setFromVector3(vec3) {
            this.radius = Math.sqrt(vec3.x * vec3.x + vec3.z * vec3.z);
            this.theta = Math.atan2(vec3.x, vec3.z);
            this.y = vec3.y;
            return this;
        }
    }
    THREE.Cylindrical = Cylindrical;
})(THREE || (THREE = {}));
/// <reference path="./Quaternion.ts" />
var THREE;
/// <reference path="./Quaternion.ts" />
(function (THREE) {
    class Euler {
        constructor(x, y, z, order) {
            this.isEuler = true;
            this._x = x || 0;
            this._y = y || 0;
            this._z = z || 0;
            this._order = order || Euler.DefaultOrder;
        }
        set x(value) {
            this._x = value;
            this.onChangeCallback();
        }
        get x() {
            return this._x;
        }
        set y(value) {
            this._y = value;
            this.onChangeCallback();
        }
        get y() {
            return this._y;
        }
        set z(value) {
            this._z = value;
            this.onChangeCallback();
        }
        get z() {
            return this._z;
        }
        set order(value) {
            this._order = value;
            this.onChangeCallback();
        }
        get order() {
            return this._order;
        }
        set(x, y, z, order) {
            this._x = x;
            this._y = y;
            this._z = z;
            this._order = order || this._order;
            this.onChangeCallback();
            return this;
        }
        clone() {
            return new Euler(this._x, this._y, this._z, this._order);
        }
        copy(euler) {
            this._x = euler._x;
            this._y = euler._y;
            this._z = euler._z;
            this._order = euler._order;
            this.onChangeCallback();
            return this;
        }
        setFromRotationMatrix(m, order, update) {
            var clamp = THREE._Math.clamp;
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var te = m.elements;
            var m11 = te[0], m12 = te[4], m13 = te[8];
            var m21 = te[1], m22 = te[5], m23 = te[9];
            var m31 = te[2], m32 = te[6], m33 = te[10];
            order = order || this._order;
            if (order === 'XYZ') {
                this._y = Math.asin(clamp(m13, -1, 1));
                if (Math.abs(m13) < 0.99999) {
                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                }
                else {
                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                }
            }
            else if (order === 'YXZ') {
                this._x = Math.asin(-clamp(m23, -1, 1));
                if (Math.abs(m23) < 0.99999) {
                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                }
                else {
                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                }
            }
            else if (order === 'ZXY') {
                this._x = Math.asin(clamp(m32, -1, 1));
                if (Math.abs(m32) < 0.99999) {
                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                }
                else {
                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                }
            }
            else if (order === 'ZYX') {
                this._y = Math.asin(-clamp(m31, -1, 1));
                if (Math.abs(m31) < 0.99999) {
                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                }
                else {
                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                }
            }
            else if (order === 'YZX') {
                this._z = Math.asin(clamp(m21, -1, 1));
                if (Math.abs(m21) < 0.99999) {
                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                }
                else {
                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                }
            }
            else if (order === 'XZY') {
                this._z = Math.asin(-clamp(m12, -1, 1));
                if (Math.abs(m12) < 0.99999) {
                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                }
                else {
                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                }
            }
            else {
                console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
            }
            this._order = order;
            if (update !== false)
                this.onChangeCallback();
            return this;
        }
        //public static matrix: any;//= new Matrix4();
        // public setFromQuaternion() {
        setFromQuaternion(q, order, update) {
            var matrix = new THREE.Matrix4();
            matrix.makeRotationFromQuaternion(q);
            return this.setFromRotationMatrix(matrix, order, update);
        }
        setFromVector3(v, order) {
            return this.set(v.x, v.y, v.z, order || this._order);
        }
        // public reorder() {
        // WARNING: this discards revolution information -bhouston
        reorder(newOrder) {
            Euler.q.setFromEuler(this);
            return this.setFromQuaternion(Euler.q, newOrder);
        }
        equals(euler) {
            return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
        }
        fromArray(array) {
            this._x = array[0];
            this._y = array[1];
            this._z = array[2];
            if (array[3] !== undefined)
                this._order = array[3];
            this.onChangeCallback();
            return this;
        }
        toArray(array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._order;
            return array;
        }
        toVector3(optionalResult) {
            if (optionalResult) {
                return optionalResult.set(this._x, this._y, this._z);
            }
            else {
                return new THREE.Vector3(this._x, this._y, this._z);
            }
        }
        onChange(callback) {
            this._onChangeCallback = callback;
            return this;
        }
        onChangeCallback() {
            if (this._onChangeCallback) {
                this._onChangeCallback();
            }
        }
    }
    Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
    Euler.DefaultOrder = 'XYZ';
    Euler.q = new THREE.Quaternion();
    THREE.Euler = Euler;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Sphere {
        constructor(center, radius) {
            this.center = (center !== undefined) ? center : new THREE.Vector3();
            this.radius = (radius !== undefined) ? radius : 0;
        }
        set(center, radius) {
            this.center.copy(center);
            this.radius = radius;
            return this;
        }
        // public setFromPoints() {
        setFromPoints(points, optionalCenter) {
            var center = this.center;
            if (optionalCenter !== undefined) {
                center.copy(optionalCenter);
            }
            else {
                Sphere.box.setFromPoints(points).getCenter(center);
            }
            var maxRadiusSq = 0;
            for (var i = 0, il = points.length; i < il; i++) {
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
            }
            this.radius = Math.sqrt(maxRadiusSq);
            return this;
        }
        clone() {
            return new Sphere().copy(this);
        }
        copy(sphere) {
            this.center.copy(sphere.center);
            this.radius = sphere.radius;
            return this;
        }
        empty() {
            return (this.radius <= 0);
        }
        containsPoint(point) {
            return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
        }
        distanceToPoint(point) {
            return (point.distanceTo(this.center) - this.radius);
        }
        intersectsSphere(sphere) {
            var radiusSum = this.radius + sphere.radius;
            return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
        }
        intersectsBox(box) {
            return box.intersectsSphere(this);
        }
        intersectsPlane(plane) {
            return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(point, target) {
            var deltaLengthSq = this.center.distanceToSquared(point);
            if (target === undefined) {
                console.warn('THREE.Sphere: .clampPoint() target is now required');
                target = new THREE.Vector3();
            }
            target.copy(point);
            if (deltaLengthSq > (this.radius * this.radius)) {
                target.sub(this.center).normalize();
                target.multiplyScalar(this.radius).add(this.center);
            }
            return target;
        }
        getBoundingBox(target) {
            if (target === undefined) {
                console.warn('THREE.Sphere: .getBoundingBox() target is now required');
                target = new THREE.Box3();
            }
            target.set(this.center, this.center);
            target.expandByScalar(this.radius);
            return target;
        }
        applyMatrix4(matrix) {
            this.center.applyMatrix4(matrix);
            this.radius = this.radius * matrix.getMaxScaleOnAxis();
            return this;
        }
        translate(offset) {
            this.center.add(offset);
            return this;
        }
        equals(sphere) {
            return sphere.center.equals(this.center) && (sphere.radius === this.radius);
        }
    }
    Sphere.box = new THREE.Box3();
    THREE.Sphere = Sphere;
})(THREE || (THREE = {}));
/// <reference path="./Sphere.ts" />
var THREE;
/// <reference path="./Sphere.ts" />
(function (THREE) {
    class Frustum {
        /**
         *
         * @param p0
         * @param p1
         * @param p2
         * @param p3
         * @param p4
         * @param p5
         */
        constructor(p0, p1, p2, p3, p4, p5) {
            this.planes = new Array();
            this.planes.push((p0 !== undefined) ? p0 : new THREE.Plane());
            this.planes.push((p1 !== undefined) ? p1 : new THREE.Plane());
            this.planes.push((p2 !== undefined) ? p2 : new THREE.Plane());
            this.planes.push((p3 !== undefined) ? p3 : new THREE.Plane());
            this.planes.push((p4 !== undefined) ? p4 : new THREE.Plane());
            this.planes.push((p5 !== undefined) ? p5 : new THREE.Plane());
        }
        set(p0, p1, p2, p3, p4, p5) {
            var planes = this.planes;
            planes[0].copy(p0);
            planes[1].copy(p1);
            planes[2].copy(p2);
            planes[3].copy(p3);
            planes[4].copy(p4);
            planes[5].copy(p5);
            return this;
        }
        clone() {
            var frustum = new Frustum();
            frustum.copy(this);
            return frustum;
        }
        copy(frustum) {
            var planes = this.planes;
            for (var i = 0; i < 6; i++) {
                planes[i].copy(frustum.planes[i]);
            }
            return this;
        }
        setFromMatrix(m) {
            var planes = this.planes;
            var me = m.elements;
            var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
            var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
            var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
            var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
            planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
            planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
            planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
            planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
            planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
            planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
            return this;
        }
        intersectsObject(object) {
            var sphere = Frustum.sphere;
            var geometry = object.geometry;
            if (geometry.boundingSphere === null)
                geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere)
                .applyMatrix4(object.matrixWorld);
            return this.intersectsSphere(sphere);
        }
        ;
        intersectsSprite(sprite) {
            var sphere = Frustum.sphere;
            sphere.center.set(0, 0, 0);
            sphere.radius = 0.7071067811865476;
            sphere.applyMatrix4(sprite.matrixWorld);
            return this.intersectsSphere(sphere);
        }
        ;
        intersectsSphere(sphere) {
            var planes = this.planes;
            var center = sphere.center;
            var negRadius = -sphere.radius;
            for (var i = 0; i < 6; i++) {
                var distance = planes[i].distanceToPoint(center);
                if (distance < negRadius) {
                    return false;
                }
            }
            return true;
        }
        intersectsBox(box) {
            var p1 = Frustum.p1;
            var p2 = Frustum.p2;
            var planes = this.planes;
            for (var i = 0; i < 6; i++) {
                var plane = planes[i];
                p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                var d1 = plane.distanceToPoint(p1);
                var d2 = plane.distanceToPoint(p2);
                // if both outside plane, no intersection
                if (d1 < 0 && d2 < 0) {
                    return false;
                }
            }
            return true;
        }
        ;
        containsPoint(point) {
            var planes = this.planes;
            for (var i = 0; i < 6; i++) {
                if (planes[i].distanceToPoint(point) < 0) {
                    return false;
                }
            }
            return true;
        }
    }
    Frustum.sphere = new THREE.Sphere();
    Frustum.p1 = new THREE.Vector3();
    Frustum.p2 = new THREE.Vector3();
    THREE.Frustum = Frustum;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            this.settings = null; // optional, subclass-specific settings structure
            // Note: The indirection allows central control of many interpolants.
            // --- Protected interface
            this.DefaultSettings_ = {};
            //!\ DECLARE ALIAS AFTER assign prototype !
            //Object.assign(Interpolant.prototype, {
            //( 0, t, t0 ), returns this.resultBuffer
            //TODO:
            //public beforeStart_: any = Interpolant.prototype.copySampleValue_
            this.beforeStart_ = this.copySampleValue_;
            //( N-1, tN-1, t ), returns this.resultBuffer
            //TODO:
            //public afterEnd_: any = Interpolant.prototype.copySampleValue_
            this.afterEnd_ = this.copySampleValue_;
            //TODO: samplevalues should be a Type.
            this.parameterPositions = parameterPositions;
            this._cachedIndex = 0;
            this.resultBuffer = resultBuffer !== undefined ?
                resultBuffer : new sampleValues(sampleSize);
            this.sampleValues = sampleValues;
            this.valueSize = sampleSize;
        }
        evaluate(t) {
            var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
            validate_interval: {
                seek: {
                    var right;
                    linear_scan: {
                        //- See http://jsperf.com/comparison-to-undefined/3
                        //- slower code:
                        //-
                        //- 				if ( t >= t1 || t1 === undefined ) {
                        forward_scan: if (!(t < t1)) {
                            for (var giveUpAt = i1 + 2;;) {
                                if (t1 === undefined) {
                                    if (t < t0)
                                        break forward_scan;
                                    // after end
                                    i1 = pp.length;
                                    this._cachedIndex = i1;
                                    return this.afterEnd_(i1 - 1, t, t0);
                                }
                                if (i1 === giveUpAt)
                                    break; // this loop
                                t0 = t1;
                                t1 = pp[++i1];
                                if (t < t1) {
                                    // we have arrived at the sought interval
                                    break seek;
                                }
                            }
                            // prepare binary search on the right side of the index
                            right = pp.length;
                            break linear_scan;
                        }
                        //- slower code:
                        //-					if ( t < t0 || t0 === undefined ) {
                        if (!(t >= t0)) {
                            // looping?
                            var t1global = pp[1];
                            if (t < t1global) {
                                i1 = 2; // + 1, using the scan for the details
                                t0 = t1global;
                            }
                            // linear reverse scan
                            for (var giveUpAt = i1 - 2;;) {
                                if (t0 === undefined) {
                                    // before start
                                    this._cachedIndex = 0;
                                    return this.beforeStart_(0, t, t1);
                                }
                                if (i1 === giveUpAt)
                                    break; // this loop
                                t1 = t0;
                                t0 = pp[--i1 - 1];
                                if (t >= t0) {
                                    // we have arrived at the sought interval
                                    break seek;
                                }
                            }
                            // prepare binary search on the left side of the index
                            right = i1;
                            i1 = 0;
                            break linear_scan;
                        }
                        // the interval is valid
                        break validate_interval;
                    } // linear scan
                    // binary search
                    while (i1 < right) {
                        var mid = (i1 + right) >>> 1;
                        if (t < pp[mid]) {
                            right = mid;
                        }
                        else {
                            i1 = mid + 1;
                        }
                    }
                    t1 = pp[i1];
                    t0 = pp[i1 - 1];
                    // check boundary cases, again
                    if (t0 === undefined) {
                        this._cachedIndex = 0;
                        return this.beforeStart_(0, t, t1);
                    }
                    if (t1 === undefined) {
                        i1 = pp.length;
                        this._cachedIndex = i1;
                        return this.afterEnd_(i1 - 1, t0, t);
                    }
                } // seek
                this._cachedIndex = i1;
                this.intervalChanged_(i1, t0, t1);
            } // validate_interval
            return this.interpolate_(i1, t0, t, t1);
        }
        getSettings_() {
            return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(index) {
            // copies a sample value to the result buffer
            var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
            for (var i = 0; i !== stride; ++i) {
                result[i] = values[offset + i];
            }
            return result;
        }
        // Template methods for derived classes:
        interpolate_(...args /* i1, t0, t, t1 */) {
            throw new Error('call to abstract method');
            // implementations shall return this.resultBuffer
        }
        intervalChanged_(...args /* i1, t0, t1 */) {
            // empty
        }
    }
    THREE.Interpolant = Interpolant;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Line3 {
        constructor(start, end) {
            this.start = (start !== undefined) ? start : new THREE.Vector3();
            this.end = (end !== undefined) ? end : new THREE.Vector3();
        }
        set(start, end) {
            this.start.copy(start);
            this.end.copy(end);
            return this;
        }
        clone() {
            return new Line3().copy(this);
        }
        copy(line) {
            this.start.copy(line.start);
            this.end.copy(line.end);
            return this;
        }
        getCenter(target) {
            if (target === undefined) {
                console.warn('THREE.Line3: .getCenter() target is now required');
                target = new THREE.Vector3();
            }
            return target.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(target) {
            if (target === undefined) {
                console.warn('THREE.Line3: .delta() target is now required');
                target = new THREE.Vector3();
            }
            return target.subVectors(this.end, this.start);
        }
        distanceSq() {
            return this.start.distanceToSquared(this.end);
        }
        distance() {
            return this.start.distanceTo(this.end);
        }
        at(t, target) {
            if (target === undefined) {
                console.warn('THREE.Line3: .at() target is now required');
                target = new THREE.Vector3();
            }
            return this.delta(target).multiplyScalar(t).add(this.start);
        }
        closestPointToPointParameter(point, clampToLine) {
            //TODO:
            var startP = new THREE.Vector3();
            var startEnd = new THREE.Vector3();
            startP.subVectors(point, this.start);
            startEnd.subVectors(this.end, this.start);
            var startEnd2 = startEnd.dot(startEnd);
            var startEnd_startP = startEnd.dot(startP);
            var t = startEnd_startP / startEnd2;
            if (clampToLine) {
                t = THREE._Math.clamp(t, 0, 1);
            }
            return t;
        }
        closestPointToPoint(point, clampToLine, target) {
            var t = this.closestPointToPointParameter(point, clampToLine);
            if (target === undefined) {
                console.warn('THREE.Line3: .closestPointToPoint() target is now required');
                target = new THREE.Vector3();
            }
            return this.delta(target).multiplyScalar(t).add(this.start);
        }
        applyMatrix4(matrix) {
            this.start.applyMatrix4(matrix);
            this.end.applyMatrix4(matrix);
            return this;
        }
        equals(line) {
            return line.start.equals(this.start) && line.end.equals(this.end);
        }
    }
    THREE.Line3 = Line3;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class _Math {
        static generateUUID() {
            // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
            //TODO:
            var lut = [];
            for (var i = 0; i < 256; i++) {
                lut[i] = (i < 16 ? '0' : '') + (i).toString(16);
            }
            var d0 = Math.random() * 0xffffffff | 0;
            var d1 = Math.random() * 0xffffffff | 0;
            var d2 = Math.random() * 0xffffffff | 0;
            var d3 = Math.random() * 0xffffffff | 0;
            var uuid = lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' +
                lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' +
                lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] +
                lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
            // .toUpperCase() here flattens concatenated strings to save heap memory space.
            return uuid.toUpperCase();
        }
        static clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }
        // compute euclidian modulo of m % n
        // https://en.wikipedia.org/wiki/Modulo_operation
        static euclideanModulo(n, m) {
            return ((n % m) + m) % m;
        }
        // Linear mapping from range <a1, a2> to range <b1, b2>
        static mapLinear(x, a1, a2, b1, b2) {
            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        }
        // https://en.wikipedia.org/wiki/Linear_interpolation
        static lerp(x, y, t) {
            return (1 - t) * x + t * y;
        }
        // http://en.wikipedia.org/wiki/Smoothstep
        static smoothstep(x, min, max) {
            if (x <= min)
                return 0;
            if (x >= max)
                return 1;
            x = (x - min) / (max - min);
            return x * x * (3 - 2 * x);
        }
        static smootherstep(x, min, max) {
            if (x <= min)
                return 0;
            if (x >= max)
                return 1;
            x = (x - min) / (max - min);
            return x * x * x * (x * (x * 6 - 15) + 10);
        }
        // Random integer from <low, high> interval
        static randInt(low, high) {
            return low + Math.floor(Math.random() * (high - low + 1));
        }
        // Random float from <low, high> interval
        static randFloat(low, high) {
            return low + Math.random() * (high - low);
        }
        // Random float from <-range/2, range/2> interval
        static randFloatSpread(range) {
            return range * (0.5 - Math.random());
        }
        static degToRad(degrees) {
            return degrees * _Math.DEG2RAD;
        }
        static radToDeg(radians) {
            return radians * _Math.RAD2DEG;
        }
        static isPowerOfTwo(value) {
            return (value & (value - 1)) === 0 && value !== 0;
        }
        static ceilPowerOfTwo(value) {
            return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
        }
        static floorPowerOfTwo(value) {
            return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
        }
    }
    _Math.DEG2RAD = Math.PI / 180;
    _Math.RAD2DEG = 180 / Math.PI;
    THREE._Math = _Math;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Matrix3 {
        constructor() {
            this.isMatrix3 = true;
            this.elements = [
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            ];
            if (arguments.length > 0) {
                console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
            }
        }
        set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            var te = this.elements;
            te[0] = n11;
            te[1] = n21;
            te[2] = n31;
            te[3] = n12;
            te[4] = n22;
            te[5] = n32;
            te[6] = n13;
            te[7] = n23;
            te[8] = n33;
            return this;
        }
        identity() {
            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            return this;
        }
        clone() {
            return new Matrix3().fromArray(this.elements);
        }
        copy(m) {
            var te = this.elements;
            var me = m.elements;
            te[0] = me[0];
            te[1] = me[1];
            te[2] = me[2];
            te[3] = me[3];
            te[4] = me[4];
            te[5] = me[5];
            te[6] = me[6];
            te[7] = me[7];
            te[8] = me[8];
            return this;
        }
        setFromMatrix4(m) {
            var me = m.elements;
            this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
            return this;
        }
        // public applyToBufferAttribute() {
        applyToBufferAttribute(attribute) {
            //TODO:
            var v1 = new THREE.Vector3();
            for (var i = 0, l = attribute.count; i < l; i++) {
                v1.x = attribute.getX(i);
                v1.y = attribute.getY(i);
                v1.z = attribute.getZ(i);
                v1.applyMatrix3(this);
                attribute.setXYZ(i, v1.x, v1.y, v1.z);
            }
            return attribute;
        }
        multiply(m) {
            return this.multiplyMatrices(this, m);
        }
        premultiply(m) {
            return this.multiplyMatrices(m, this);
        }
        multiplyMatrices(a, b) {
            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;
            var a11 = ae[0], a12 = ae[3], a13 = ae[6];
            var a21 = ae[1], a22 = ae[4], a23 = ae[7];
            var a31 = ae[2], a32 = ae[5], a33 = ae[8];
            var b11 = be[0], b12 = be[3], b13 = be[6];
            var b21 = be[1], b22 = be[4], b23 = be[7];
            var b31 = be[2], b32 = be[5], b33 = be[8];
            te[0] = a11 * b11 + a12 * b21 + a13 * b31;
            te[3] = a11 * b12 + a12 * b22 + a13 * b32;
            te[6] = a11 * b13 + a12 * b23 + a13 * b33;
            te[1] = a21 * b11 + a22 * b21 + a23 * b31;
            te[4] = a21 * b12 + a22 * b22 + a23 * b32;
            te[7] = a21 * b13 + a22 * b23 + a23 * b33;
            te[2] = a31 * b11 + a32 * b21 + a33 * b31;
            te[5] = a31 * b12 + a32 * b22 + a33 * b32;
            te[8] = a31 * b13 + a32 * b23 + a33 * b33;
            return this;
        }
        multiplyScalar(s) {
            var te = this.elements;
            te[0] *= s;
            te[3] *= s;
            te[6] *= s;
            te[1] *= s;
            te[4] *= s;
            te[7] *= s;
            te[2] *= s;
            te[5] *= s;
            te[8] *= s;
            return this;
        }
        determinant() {
            var te = this.elements;
            var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
            return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        }
        getInverse(matrix, throwOnDegenerate) {
            if (matrix && matrix.isMatrix4) {
                console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            }
            var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
            if (det === 0) {
                var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                if (throwOnDegenerate === true) {
                    throw new Error(msg);
                }
                else {
                    console.warn(msg);
                }
                return this.identity();
            }
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n31 * n23 - n33 * n21) * detInv;
            te[2] = (n32 * n21 - n31 * n22) * detInv;
            te[3] = t12 * detInv;
            te[4] = (n33 * n11 - n31 * n13) * detInv;
            te[5] = (n31 * n12 - n32 * n11) * detInv;
            te[6] = t13 * detInv;
            te[7] = (n21 * n13 - n23 * n11) * detInv;
            te[8] = (n22 * n11 - n21 * n12) * detInv;
            return this;
        }
        transpose() {
            var tmp, m = this.elements;
            tmp = m[1];
            m[1] = m[3];
            m[3] = tmp;
            tmp = m[2];
            m[2] = m[6];
            m[6] = tmp;
            tmp = m[5];
            m[5] = m[7];
            m[7] = tmp;
            return this;
        }
        getNormalMatrix(matrix4) {
            return this.setFromMatrix4(matrix4).getInverse(this).transpose();
        }
        transposeIntoArray(r) {
            var m = this.elements;
            r[0] = m[0];
            r[1] = m[3];
            r[2] = m[6];
            r[3] = m[1];
            r[4] = m[4];
            r[5] = m[7];
            r[6] = m[2];
            r[7] = m[5];
            r[8] = m[8];
            return this;
        }
        setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
            var c = Math.cos(rotation);
            var s = Math.sin(rotation);
            this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
        }
        scale(sx, sy) {
            var te = this.elements;
            te[0] *= sx;
            te[3] *= sx;
            te[6] *= sx;
            te[1] *= sy;
            te[4] *= sy;
            te[7] *= sy;
            return this;
        }
        rotate(theta) {
            var c = Math.cos(theta);
            var s = Math.sin(theta);
            var te = this.elements;
            var a11 = te[0], a12 = te[3], a13 = te[6];
            var a21 = te[1], a22 = te[4], a23 = te[7];
            te[0] = c * a11 + s * a21;
            te[3] = c * a12 + s * a22;
            te[6] = c * a13 + s * a23;
            te[1] = -s * a11 + c * a21;
            te[4] = -s * a12 + c * a22;
            te[7] = -s * a13 + c * a23;
            return this;
        }
        translate(tx, ty) {
            var te = this.elements;
            te[0] += tx * te[2];
            te[3] += tx * te[5];
            te[6] += tx * te[8];
            te[1] += ty * te[2];
            te[4] += ty * te[5];
            te[7] += ty * te[8];
            return this;
        }
        equals(matrix) {
            var te = this.elements;
            var me = matrix.elements;
            for (var i = 0; i < 9; i++) {
                if (te[i] !== me[i])
                    return false;
            }
            return true;
        }
        fromArray(array, offset) {
            if (offset === undefined)
                offset = 0;
            for (var i = 0; i < 9; i++) {
                this.elements[i] = array[i + offset];
            }
            return this;
        }
        toArray(array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            var te = this.elements;
            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];
            array[offset + 3] = te[3];
            array[offset + 4] = te[4];
            array[offset + 5] = te[5];
            array[offset + 6] = te[6];
            array[offset + 7] = te[7];
            array[offset + 8] = te[8];
            return array;
        }
    }
    THREE.Matrix3 = Matrix3;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Matrix4 {
        constructor() {
            this.isMatrix4 = true;
            this.elements = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];
            if (arguments.length > 0) {
                console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
            }
        }
        set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var te = this.elements;
            te[0] = n11;
            te[4] = n12;
            te[8] = n13;
            te[12] = n14;
            te[1] = n21;
            te[5] = n22;
            te[9] = n23;
            te[13] = n24;
            te[2] = n31;
            te[6] = n32;
            te[10] = n33;
            te[14] = n34;
            te[3] = n41;
            te[7] = n42;
            te[11] = n43;
            te[15] = n44;
            return this;
        }
        identity() {
            this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        }
        clone() {
            return new Matrix4().fromArray(this.elements);
        }
        copy(m) {
            var te = this.elements;
            var me = m.elements;
            te[0] = me[0];
            te[1] = me[1];
            te[2] = me[2];
            te[3] = me[3];
            te[4] = me[4];
            te[5] = me[5];
            te[6] = me[6];
            te[7] = me[7];
            te[8] = me[8];
            te[9] = me[9];
            te[10] = me[10];
            te[11] = me[11];
            te[12] = me[12];
            te[13] = me[13];
            te[14] = me[14];
            te[15] = me[15];
            return this;
        }
        copyPosition(m) {
            var te = this.elements, me = m.elements;
            te[12] = me[12];
            te[13] = me[13];
            te[14] = me[14];
            return this;
        }
        extractBasis(xAxis, yAxis, zAxis) {
            xAxis.setFromMatrixColumn(this, 0);
            yAxis.setFromMatrixColumn(this, 1);
            zAxis.setFromMatrixColumn(this, 2);
            return this;
        }
        makeBasis(xAxis, yAxis, zAxis) {
            this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
            return this;
        }
        extractRotation(m) {
            //TODO:
            var v1 = new THREE.Vector3();
            var te = this.elements;
            var me = m.elements;
            var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
            var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
            var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
            te[0] = me[0] * scaleX;
            te[1] = me[1] * scaleX;
            te[2] = me[2] * scaleX;
            te[4] = me[4] * scaleY;
            te[5] = me[5] * scaleY;
            te[6] = me[6] * scaleY;
            te[8] = me[8] * scaleZ;
            te[9] = me[9] * scaleZ;
            te[10] = me[10] * scaleZ;
            return this;
        }
        makeRotationFromEuler(euler) {
            if (!(euler && euler.isEuler)) {
                console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
            }
            var te = this.elements;
            var x = euler.x, y = euler.y, z = euler.z;
            var a = Math.cos(x), b = Math.sin(x);
            var c = Math.cos(y), d = Math.sin(y);
            var e = Math.cos(z), f = Math.sin(z);
            if (euler.order === 'XYZ') {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e;
                te[4] = -c * f;
                te[8] = d;
                te[1] = af + be * d;
                te[5] = ae - bf * d;
                te[9] = -b * c;
                te[2] = bf - ae * d;
                te[6] = be + af * d;
                te[10] = a * c;
            }
            else if (euler.order === 'YXZ') {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce + df * b;
                te[4] = de * b - cf;
                te[8] = a * d;
                te[1] = a * f;
                te[5] = a * e;
                te[9] = -b;
                te[2] = cf * b - de;
                te[6] = df + ce * b;
                te[10] = a * c;
            }
            else if (euler.order === 'ZXY') {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce - df * b;
                te[4] = -a * f;
                te[8] = de + cf * b;
                te[1] = cf + de * b;
                te[5] = a * e;
                te[9] = df - ce * b;
                te[2] = -a * d;
                te[6] = b;
                te[10] = a * c;
            }
            else if (euler.order === 'ZYX') {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e;
                te[4] = be * d - af;
                te[8] = ae * d + bf;
                te[1] = c * f;
                te[5] = bf * d + ae;
                te[9] = af * d - be;
                te[2] = -d;
                te[6] = b * c;
                te[10] = a * c;
            }
            else if (euler.order === 'YZX') {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e;
                te[4] = bd - ac * f;
                te[8] = bc * f + ad;
                te[1] = f;
                te[5] = a * e;
                te[9] = -b * e;
                te[2] = -d * e;
                te[6] = ad * f + bc;
                te[10] = ac - bd * f;
            }
            else if (euler.order === 'XZY') {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e;
                te[4] = -f;
                te[8] = d * e;
                te[1] = ac * f + bd;
                te[5] = a * e;
                te[9] = ad * f - bc;
                te[2] = bc * f - ad;
                te[6] = b * e;
                te[10] = bd * f + ac;
            }
            // last column
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            // bottom row
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        }
        makeRotationFromQuaternion(q) {
            var te = this.elements;
            var x = q._x, y = q._y, z = q._z, w = q._w;
            var x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2;
            var yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2;
            te[0] = 1 - (yy + zz);
            te[4] = xy - wz;
            te[8] = xz + wy;
            te[1] = xy + wz;
            te[5] = 1 - (xx + zz);
            te[9] = yz - wx;
            te[2] = xz - wy;
            te[6] = yz + wx;
            te[10] = 1 - (xx + yy);
            // last column
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            // bottom row
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        }
        lookAt(eye, target, up) {
            //TODO:
            var x = new THREE.Vector3();
            var y = new THREE.Vector3();
            var z = new THREE.Vector3();
            var te = this.elements;
            z.subVectors(eye, target);
            if (z.lengthSq() === 0) {
                // eye and target are in the same position
                z.z = 1;
            }
            z.normalize();
            x.crossVectors(up, z);
            if (x.lengthSq() === 0) {
                // up and z are parallel
                if (Math.abs(up.z) === 1) {
                    z.x += 0.0001;
                }
                else {
                    z.z += 0.0001;
                }
                z.normalize();
                x.crossVectors(up, z);
            }
            x.normalize();
            y.crossVectors(z, x);
            te[0] = x.x;
            te[4] = y.x;
            te[8] = z.x;
            te[1] = x.y;
            te[5] = y.y;
            te[9] = z.y;
            te[2] = x.z;
            te[6] = y.z;
            te[10] = z.z;
            return this;
        }
        multiply(m, n) {
            if (n !== undefined) {
                console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
                return this.multiplyMatrices(m, n);
            }
            return this.multiplyMatrices(this, m);
        }
        premultiply(m) {
            return this.multiplyMatrices(m, this);
        }
        /**
         * 将矩阵a*b的结果赋值给this.elements
         * @param a 矩阵a
         * @param b 矩阵b
         * @returns 返回实例本身
         */
        multiplyMatrices(a, b) {
            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;
            var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
            var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
            var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
            var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
            var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
            var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
            var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
            var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
            te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            return this;
        }
        multiplyScalar(s) {
            var te = this.elements;
            te[0] *= s;
            te[4] *= s;
            te[8] *= s;
            te[12] *= s;
            te[1] *= s;
            te[5] *= s;
            te[9] *= s;
            te[13] *= s;
            te[2] *= s;
            te[6] *= s;
            te[10] *= s;
            te[14] *= s;
            te[3] *= s;
            te[7] *= s;
            te[11] *= s;
            te[15] *= s;
            return this;
        }
        applyToBufferAttribute(attribute) {
            //TODO:
            var v1 = new THREE.Vector3();
            for (var i = 0, l = attribute.count; i < l; i++) {
                v1.x = attribute.getX(i);
                v1.y = attribute.getY(i);
                v1.z = attribute.getZ(i);
                v1.applyMatrix4(this);
                attribute.setXYZ(i, v1.x, v1.y, v1.z);
            }
            return attribute;
        }
        determinant() {
            var te = this.elements;
            var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
            var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
            var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
            var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
            //TODO: make this more efficient
            //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
            return (n41 * (+n14 * n23 * n32
                - n13 * n24 * n32
                - n14 * n22 * n33
                + n12 * n24 * n33
                + n13 * n22 * n34
                - n12 * n23 * n34) +
                n42 * (+n11 * n23 * n34
                    - n11 * n24 * n33
                    + n14 * n21 * n33
                    - n13 * n21 * n34
                    + n13 * n24 * n31
                    - n14 * n23 * n31) +
                n43 * (+n11 * n24 * n32
                    - n11 * n22 * n34
                    - n14 * n21 * n32
                    + n12 * n21 * n34
                    + n14 * n22 * n31
                    - n12 * n24 * n31) +
                n44 * (-n13 * n22 * n31
                    - n11 * n23 * n32
                    + n11 * n22 * n33
                    + n13 * n21 * n32
                    - n12 * n21 * n33
                    + n12 * n23 * n31));
        }
        transpose() {
            var te = this.elements;
            var tmp;
            tmp = te[1];
            te[1] = te[4];
            te[4] = tmp;
            tmp = te[2];
            te[2] = te[8];
            te[8] = tmp;
            tmp = te[6];
            te[6] = te[9];
            te[9] = tmp;
            tmp = te[3];
            te[3] = te[12];
            te[12] = tmp;
            tmp = te[7];
            te[7] = te[13];
            te[13] = tmp;
            tmp = te[11];
            te[11] = te[14];
            te[14] = tmp;
            return this;
        }
        setPosition(v) {
            var te = this.elements;
            te[12] = v.x;
            te[13] = v.y;
            te[14] = v.z;
            return this;
        }
        getInverse(m, throwOnDegenerate) {
            // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
            var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
            var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
            if (det === 0) {
                var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                if (throwOnDegenerate === true) {
                    throw new Error(msg);
                }
                else {
                    console.warn(msg);
                }
                return this.identity();
            }
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
            te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
            te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
            te[4] = t12 * detInv;
            te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
            te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
            te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
            te[8] = t13 * detInv;
            te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
            te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
            te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
            te[12] = t14 * detInv;
            te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
            te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
            te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
            return this;
        }
        scale(v) {
            var te = this.elements;
            var x = v.x, y = v.y, z = v.z;
            te[0] *= x;
            te[4] *= y;
            te[8] *= z;
            te[1] *= x;
            te[5] *= y;
            te[9] *= z;
            te[2] *= x;
            te[6] *= y;
            te[10] *= z;
            te[3] *= x;
            te[7] *= y;
            te[11] *= z;
            return this;
        }
        getMaxScaleOnAxis() {
            var te = this.elements;
            var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
            var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
            var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        }
        makeTranslation(x, y, z) {
            this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
            return this;
        }
        makeRotationX(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
            return this;
        }
        makeRotationY(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
            return this;
        }
        makeRotationZ(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        }
        makeRotationAxis(axis, angle) {
            // Based on http://www.gamedev.net/reference/articles/article1199.asp
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var t = 1 - c;
            var x = axis.x, y = axis.y, z = axis.z;
            var tx = t * x, ty = t * y;
            this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
            return this;
        }
        makeScale(x, y, z) {
            this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
            return this;
        }
        makeShear(x, y, z) {
            this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
            return this;
        }
        compose(position, quaternion, scale) {
            this.makeRotationFromQuaternion(quaternion);
            this.scale(scale);
            this.setPosition(position);
            return this;
        }
        // public decompose() {
        decompose(position, quaternion, scale) {
            //TODO:
            var vector = new THREE.Vector3();
            var matrix = new Matrix4();
            var te = this.elements;
            var sx = vector.set(te[0], te[1], te[2]).length();
            var sy = vector.set(te[4], te[5], te[6]).length();
            var sz = vector.set(te[8], te[9], te[10]).length();
            // if determine is negative, we need to invert one scale
            var det = this.determinant();
            if (det < 0)
                sx = -sx;
            position.x = te[12];
            position.y = te[13];
            position.z = te[14];
            // scale the rotation part
            matrix.copy(this);
            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;
            matrix.elements[0] *= invSX;
            matrix.elements[1] *= invSX;
            matrix.elements[2] *= invSX;
            matrix.elements[4] *= invSY;
            matrix.elements[5] *= invSY;
            matrix.elements[6] *= invSY;
            matrix.elements[8] *= invSZ;
            matrix.elements[9] *= invSZ;
            matrix.elements[10] *= invSZ;
            quaternion.setFromRotationMatrix(matrix);
            scale.x = sx;
            scale.y = sy;
            scale.z = sz;
            return this;
        }
        makePerspective(left, right, top, bottom, near, far) {
            if (far === undefined) {
                console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
            }
            var te = this.elements;
            var x = 2 * near / (right - left);
            var y = 2 * near / (top - bottom);
            var a = (right + left) / (right - left);
            var b = (top + bottom) / (top - bottom);
            var c = -(far + near) / (far - near);
            var d = -2 * far * near / (far - near);
            te[0] = x;
            te[4] = 0;
            te[8] = a;
            te[12] = 0;
            te[1] = 0;
            te[5] = y;
            te[9] = b;
            te[13] = 0;
            te[2] = 0;
            te[6] = 0;
            te[10] = c;
            te[14] = d;
            te[3] = 0;
            te[7] = 0;
            te[11] = -1;
            te[15] = 0;
            return this;
        }
        makeOrthographic(left, right, top, bottom, near, far) {
            var te = this.elements;
            var w = 1.0 / (right - left);
            var h = 1.0 / (top - bottom);
            var p = 1.0 / (far - near);
            var x = (right + left) * w;
            var y = (top + bottom) * h;
            var z = (far + near) * p;
            te[0] = 2 * w;
            te[4] = 0;
            te[8] = 0;
            te[12] = -x;
            te[1] = 0;
            te[5] = 2 * h;
            te[9] = 0;
            te[13] = -y;
            te[2] = 0;
            te[6] = 0;
            te[10] = -2 * p;
            te[14] = -z;
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            te[15] = 1;
            return this;
        }
        equals(matrix) {
            var te = this.elements;
            var me = matrix.elements;
            for (var i = 0; i < 16; i++) {
                if (te[i] !== me[i])
                    return false;
            }
            return true;
        }
        fromArray(array, offset) {
            if (offset === undefined)
                offset = 0;
            for (var i = 0; i < 16; i++) {
                this.elements[i] = array[i + offset];
            }
            return this;
        }
        toArray(array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            var te = this.elements;
            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];
            array[offset + 3] = te[3];
            array[offset + 4] = te[4];
            array[offset + 5] = te[5];
            array[offset + 6] = te[6];
            array[offset + 7] = te[7];
            array[offset + 8] = te[8];
            array[offset + 9] = te[9];
            array[offset + 10] = te[10];
            array[offset + 11] = te[11];
            array[offset + 12] = te[12];
            array[offset + 13] = te[13];
            array[offset + 14] = te[14];
            array[offset + 15] = te[15];
            return array;
        }
    }
    THREE.Matrix4 = Matrix4;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Plane {
        constructor(normal, constant) {
            // normal is assumed to be normalized
            this.normal = (normal !== undefined) ? normal : new THREE.Vector3(1, 0, 0);
            this.constant = (constant !== undefined) ? constant : 0;
        }
        set(normal, constant) {
            this.normal.copy(normal);
            this.constant = constant;
            return this;
        }
        setComponents(x, y, z, w) {
            this.normal.set(x, y, z);
            this.constant = w;
            return this;
        }
        setFromNormalAndCoplanarPoint(normal, point) {
            this.normal.copy(normal);
            this.constant = -point.dot(this.normal);
            return this;
        }
        // public setFromCoplanarPoints() {
        setFromCoplanarPoints(a, b, c) {
            var normal = Plane.v1.subVectors(c, b).cross(Plane.v2.subVectors(a, b)).normalize();
            // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
            this.setFromNormalAndCoplanarPoint(normal, a);
            return this;
        }
        clone() {
            return new Plane().copy(this);
        }
        copy(plane) {
            this.normal.copy(plane.normal);
            this.constant = plane.constant;
            return this;
        }
        normalize() {
            // Note: will lead to a divide by zero if the plane is invalid.
            var inverseNormalLength = 1.0 / this.normal.length();
            this.normal.multiplyScalar(inverseNormalLength);
            this.constant *= inverseNormalLength;
            return this;
        }
        negate() {
            this.constant *= -1;
            this.normal.negate();
            return this;
        }
        distanceToPoint(point) {
            return this.normal.dot(point) + this.constant;
        }
        distanceToSphere(sphere) {
            return this.distanceToPoint(sphere.center) - sphere.radius;
        }
        projectPoint(point, target) {
            if (target === undefined) {
                console.warn('THREE.Plane: .projectPoint() target is now required');
                target = new THREE.Vector3();
            }
            return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
        }
        //var v1 = new Vector3();
        // public intersectLine() {
        intersectLine(line, target) {
            if (target === undefined) {
                console.warn('THREE.Plane: .intersectLine() target is now required');
                target = new THREE.Vector3();
            }
            var direction = line.delta(Plane.v1);
            var denominator = this.normal.dot(direction);
            if (denominator === 0) {
                // line is coplanar, return origin
                if (this.distanceToPoint(line.start) === 0) {
                    return target.copy(line.start);
                }
                // Unsure if this is the correct method to handle this case.
                return undefined;
            }
            var t = -(line.start.dot(this.normal) + this.constant) / denominator;
            if (t < 0 || t > 1) {
                return undefined;
            }
            return target.copy(direction).multiplyScalar(t).add(line.start);
        }
        intersectsLine(line) {
            // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
            var startSign = this.distanceToPoint(line.start);
            var endSign = this.distanceToPoint(line.end);
            return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
        }
        intersectsBox(box) {
            return box.intersectsPlane(this);
        }
        intersectsSphere(sphere) {
            return sphere.intersectsPlane(this);
        }
        coplanarPoint(target) {
            if (target === undefined) {
                console.warn('THREE.Plane: .coplanarPoint() target is now required');
                target = new THREE.Vector3();
            }
            return target.copy(this.normal).multiplyScalar(-this.constant);
        }
        // public applyMatrix4() {
        applyMatrix4(matrix, optionalNormalMatrix) {
            var normalMatrix = optionalNormalMatrix || Plane.m1.getNormalMatrix(matrix);
            var referencePoint = this.coplanarPoint(Plane.v1).applyMatrix4(matrix);
            var normal = this.normal.applyMatrix3(normalMatrix).normalize();
            this.constant = -referencePoint.dot(normal);
            return this;
        }
        translate(offset) {
            this.constant -= offset.dot(this.normal);
            return this;
        }
        equals(plane) {
            return plane.normal.equals(this.normal) && (plane.constant === this.constant);
        }
    }
    Plane.v1 = new THREE.Vector3();
    Plane.v2 = new THREE.Vector3();
    // public static v1 = new Vector3();
    Plane.m1 = new THREE.Matrix3();
    THREE.Plane = Plane;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Ray {
        constructor(origin, direction) {
            this.origin = (origin !== undefined) ? origin : new THREE.Vector3();
            this.direction = (direction !== undefined) ? direction : new THREE.Vector3();
        }
        set(origin, direction) {
            this.origin.copy(origin);
            this.direction.copy(direction);
            return this;
        }
        clone() {
            return new Ray().copy(this);
        }
        copy(ray) {
            this.origin.copy(ray.origin);
            this.direction.copy(ray.direction);
            return this;
        }
        at(t, target) {
            if (target === undefined) {
                console.warn('THREE.Ray: .at() target is now required');
                target = new THREE.Vector3();
            }
            return target.copy(this.direction).multiplyScalar(t).add(this.origin);
        }
        lookAt(v) {
            this.direction.copy(v).sub(this.origin).normalize();
            return this;
        }
        // public recast() {
        recast(t) {
            this.origin.copy(this.at(t, Ray.v1));
            return this;
        }
        closestPointToPoint(point, target) {
            if (target === undefined) {
                console.warn('THREE.Ray: .closestPointToPoint() target is now required');
                target = new THREE.Vector3();
            }
            target.subVectors(point, this.origin);
            var directionDistance = target.dot(this.direction);
            if (directionDistance < 0) {
                return target.copy(this.origin);
            }
            return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        }
        distanceToPoint(point) {
            return Math.sqrt(this.distanceSqToPoint(point));
        }
        //var v1 = new Vector3();
        // public distanceSqToPoint() {
        distanceSqToPoint(point) {
            var directionDistance = Ray.v1.subVectors(point, this.origin).dot(this.direction);
            // point behind the ray
            if (directionDistance < 0) {
                return this.origin.distanceToSquared(point);
            }
            Ray.v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
            return Ray.v1.distanceToSquared(point);
        }
        // public distanceSqToSegment() {
        distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
            // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
            // It returns the min distance between the ray and the segment
            // defined by v0 and v1
            // It can also set two optional targets :
            // - The closest point on the ray
            // - The closest point on the segment
            Ray.segCenter.copy(v0).add(v1).multiplyScalar(0.5);
            Ray.segDir.copy(v1).sub(v0).normalize();
            Ray.diff.copy(this.origin).sub(Ray.segCenter);
            var segExtent = v0.distanceTo(v1) * 0.5;
            var a01 = -this.direction.dot(Ray.segDir);
            var b0 = Ray.diff.dot(this.direction);
            var b1 = -Ray.diff.dot(Ray.segDir);
            var c = Ray.diff.lengthSq();
            var det = Math.abs(1 - a01 * a01);
            var s0, s1, sqrDist, extDet;
            if (det > 0) {
                // The ray and segment are not parallel.
                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;
                if (s0 >= 0) {
                    if (s1 >= -extDet) {
                        if (s1 <= extDet) {
                            // region 0
                            // Minimum at interior points of ray and segment.
                            var invDet = 1 / det;
                            s0 *= invDet;
                            s1 *= invDet;
                            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                        }
                        else {
                            // region 1
                            s1 = segExtent;
                            s0 = Math.max(0, -(a01 * s1 + b0));
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    }
                    else {
                        // region 5
                        s1 = -segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                }
                else {
                    if (s1 <= -extDet) {
                        // region 4
                        s0 = Math.max(0, -(-a01 * segExtent + b0));
                        s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                    else if (s1 <= extDet) {
                        // region 3
                        s0 = 0;
                        s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = s1 * (s1 + 2 * b1) + c;
                    }
                    else {
                        // region 2
                        s0 = Math.max(0, -(a01 * segExtent + b0));
                        s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                }
            }
            else {
                // Ray and segment are parallel.
                s1 = (a01 > 0) ? -segExtent : segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
            if (optionalPointOnRay) {
                optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
            }
            if (optionalPointOnSegment) {
                optionalPointOnSegment.copy(Ray.segDir).multiplyScalar(s1).add(Ray.segCenter);
            }
            return sqrDist;
        }
        //var v1 = new Vector3();
        // public intersectSphere() {
        intersectSphere(sphere, target) {
            Ray.v1.subVectors(sphere.center, this.origin);
            var tca = Ray.v1.dot(this.direction);
            var d2 = Ray.v1.dot(Ray.v1) - tca * tca;
            var radius2 = sphere.radius * sphere.radius;
            if (d2 > radius2)
                return null;
            var thc = Math.sqrt(radius2 - d2);
            // t0 = first intersect point - entrance on front of sphere
            var t0 = tca - thc;
            // t1 = second intersect point - exit point on back of sphere
            var t1 = tca + thc;
            // test to see if both t0 and t1 are behind the ray - if so, return null
            if (t0 < 0 && t1 < 0)
                return null;
            // test to see if t0 is behind the ray:
            // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
            // in order to always return an intersect point that is in front of the ray.
            if (t0 < 0)
                return this.at(t1, target);
            // else t0 is in front of the ray, so return the first collision point scaled by t0
            return this.at(t0, target);
        }
        intersectsSphere(sphere) {
            return this.distanceToPoint(sphere.center) <= sphere.radius;
        }
        distanceToPlane(plane) {
            var denominator = plane.normal.dot(this.direction);
            if (denominator === 0) {
                // line is coplanar, return origin
                if (plane.distanceToPoint(this.origin) === 0) {
                    return 0;
                }
                // Null is preferable to undefined since undefined means.... it is undefined
                return null;
            }
            var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
            // Return if the ray never intersects the plane
            return t >= 0 ? t : null;
        }
        intersectPlane(plane, target) {
            var t = this.distanceToPlane(plane);
            if (t === null) {
                return null;
            }
            return this.at(t, target);
        }
        intersectsPlane(plane) {
            // check if the ray lies on the plane first
            var distToPoint = plane.distanceToPoint(this.origin);
            if (distToPoint === 0) {
                return true;
            }
            var denominator = plane.normal.dot(this.direction);
            if (denominator * distToPoint < 0) {
                return true;
            }
            // ray origin is behind the plane (and is pointing behind it)
            return false;
        }
        intersectBox(box, target) {
            var tmin, tmax, tymin, tymax, tzmin, tzmax;
            var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
            var origin = this.origin;
            if (invdirx >= 0) {
                tmin = (box.min.x - origin.x) * invdirx;
                tmax = (box.max.x - origin.x) * invdirx;
            }
            else {
                tmin = (box.max.x - origin.x) * invdirx;
                tmax = (box.min.x - origin.x) * invdirx;
            }
            if (invdiry >= 0) {
                tymin = (box.min.y - origin.y) * invdiry;
                tymax = (box.max.y - origin.y) * invdiry;
            }
            else {
                tymin = (box.max.y - origin.y) * invdiry;
                tymax = (box.min.y - origin.y) * invdiry;
            }
            if ((tmin > tymax) || (tymin > tmax))
                return null;
            // These lines also handle the case where tmin or tmax is NaN
            // (result of 0 * Infinity). x !== x returns true if x is NaN
            if (tymin > tmin || tmin !== tmin)
                tmin = tymin;
            if (tymax < tmax || tmax !== tmax)
                tmax = tymax;
            if (invdirz >= 0) {
                tzmin = (box.min.z - origin.z) * invdirz;
                tzmax = (box.max.z - origin.z) * invdirz;
            }
            else {
                tzmin = (box.max.z - origin.z) * invdirz;
                tzmax = (box.min.z - origin.z) * invdirz;
            }
            if ((tmin > tzmax) || (tzmin > tmax))
                return null;
            if (tzmin > tmin || tmin !== tmin)
                tmin = tzmin;
            if (tzmax < tmax || tmax !== tmax)
                tmax = tzmax;
            //return point closest to the ray (positive side)
            if (tmax < 0)
                return null;
            return this.at(tmin >= 0 ? tmin : tmax, target);
        }
        intersectsBox(box) {
            return this.intersectBox(box, Ray.v) !== null;
        }
        intersectTriangle(a, b, c, backfaceCulling, target) {
            // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
            Ray.edge1.subVectors(b, a);
            Ray.edge2.subVectors(c, a);
            Ray.normal.crossVectors(Ray.edge1, Ray.edge2);
            // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = Ray.kEdge1, E2 = Ray.kEdge2, N = Cross(E1,E2)) by
            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            var DdN = this.direction.dot(Ray.normal);
            var sign;
            if (DdN > 0) {
                if (backfaceCulling)
                    return null;
                sign = 1;
            }
            else if (DdN < 0) {
                sign = -1;
                DdN = -DdN;
            }
            else {
                return null;
            }
            Ray.diff.subVectors(this.origin, a);
            var DdQxE2 = sign * this.direction.dot(Ray.edge2.crossVectors(Ray.diff, Ray.edge2));
            // b1 < 0, no intersection
            if (DdQxE2 < 0) {
                return null;
            }
            var DdE1xQ = sign * this.direction.dot(Ray.edge1.cross(Ray.diff));
            // b2 < 0, no intersection
            if (DdE1xQ < 0) {
                return null;
            }
            // b1+b2 > 1, no intersection
            if (DdQxE2 + DdE1xQ > DdN) {
                return null;
            }
            // Line intersects triangle, check if ray does.
            var QdN = -sign * Ray.diff.dot(Ray.normal);
            // t < 0, no intersection
            if (QdN < 0) {
                return null;
            }
            // Ray intersects triangle.
            return this.at(QdN / DdN, target);
        }
        applyMatrix4(matrix4) {
            this.origin.applyMatrix4(matrix4);
            this.direction.transformDirection(matrix4);
            return this;
        }
        equals(ray) {
            return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }
    }
    Ray.v1 = new THREE.Vector3();
    Ray.segCenter = new THREE.Vector3();
    Ray.segDir = new THREE.Vector3();
    Ray.diff = new THREE.Vector3();
    // intersectsBox: (function () {
    Ray.v = new THREE.Vector3();
    // public intersectTriangle() {
    // Compute the offset origin, edges, and normal.
    //public static diff = new Vector3();
    Ray.edge1 = new THREE.Vector3();
    Ray.edge2 = new THREE.Vector3();
    Ray.normal = new THREE.Vector3();
    THREE.Ray = Ray;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Spherical {
        constructor(radius, phi, theta) {
            this.radius = (radius !== undefined) ? radius : 1.0;
            this.phi = (phi !== undefined) ? phi : 0; // up / down towards top and bottom pole
            this.theta = (theta !== undefined) ? theta : 0; // around the equator of the sphere
            return this;
        }
        set(radius, phi, theta) {
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
            return this;
        }
        clone() {
            return new Spherical().copy(this);
        }
        copy(other) {
            this.radius = other.radius;
            this.phi = other.phi;
            this.theta = other.theta;
            return this;
        }
        // restrict phi to be betwee EPS and PI-EPS
        makeSafe() {
            var EPS = 0.000001;
            this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
            return this;
        }
        setFromVector3(vec3) {
            this.radius = vec3.length();
            if (this.radius === 0) {
                this.theta = 0;
                this.phi = 0;
            }
            else {
                this.theta = Math.atan2(vec3.x, vec3.z); // equator angle around y-up axis
                this.phi = Math.acos(_Math.clamp(vec3.y / this.radius, -1, 1)); // polar angle
            }
            return this;
        }
    }
    THREE.Spherical = Spherical;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Triangle {
        constructor(a, b, c) {
            this.a = (a !== undefined) ? a : new THREE.Vector3();
            this.b = (b !== undefined) ? b : new THREE.Vector3();
            this.c = (c !== undefined) ? c : new THREE.Vector3();
        }
        // public getNormal() {
        static getNormal(a, b, c, target) {
            if (target === undefined) {
                console.warn('THREE.Triangle: .getNormal() target is now required');
                target = new THREE.Vector3();
            }
            target.subVectors(c, b);
            Triangle.v0.subVectors(a, b);
            target.cross(Triangle.v0);
            var targetLengthSq = target.lengthSq();
            if (targetLengthSq > 0) {
                return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
            }
            return target.set(0, 0, 0);
        }
        // static/instance method to calculate barycentric coordinates
        // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
        // public getBarycoord() {
        static getBarycoord(point, a, b, c, target) {
            Triangle.v0.subVectors(c, a);
            Triangle.v1.subVectors(b, a);
            Triangle.v2.subVectors(point, a);
            var dot00 = Triangle.v0.dot(Triangle.v0);
            var dot01 = Triangle.v0.dot(Triangle.v1);
            var dot02 = Triangle.v0.dot(Triangle.v2);
            var dot11 = Triangle.v1.dot(Triangle.v1);
            var dot12 = Triangle.v1.dot(Triangle.v2);
            var denom = (dot00 * dot11 - dot01 * dot01);
            if (target === undefined) {
                console.warn('THREE.Triangle: .getBarycoord() target is now required');
                target = new THREE.Vector3();
            }
            // collinear or singular triangle
            if (denom === 0) {
                // arbitrary location outside of triangle?
                // not sure if this is the best idea, maybe should be returning undefined
                return target.set(-2, -1, -1);
            }
            var invDenom = 1 / denom;
            var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
            var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
            // barycentric coordinates must always sum to 1
            return target.set(1 - u - v, v, u);
        }
        //var v1 = new Vector3();
        // public containsPoint() {
        static containsPoint(point, a, b, c) {
            Triangle.getBarycoord(point, a, b, c, Triangle.v1);
            return (Triangle.v1.x >= 0) && (Triangle.v1.y >= 0) && ((Triangle.v1.x + Triangle.v1.y) <= 1);
        }
        set(a, b, c) {
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);
            return this;
        }
        setFromPointsAndIndices(points, i0, i1, i2) {
            this.a.copy(points[i0]);
            this.b.copy(points[i1]);
            this.c.copy(points[i2]);
            return this;
        }
        clone() {
            return new Triangle().copy(this);
        }
        copy(triangle) {
            this.a.copy(triangle.a);
            this.b.copy(triangle.b);
            this.c.copy(triangle.c);
            return this;
        }
        // var v0 = new Vector3();
        // var v1 = new Vector3();
        // public getArea() {
        getArea() {
            Triangle.v0.subVectors(this.c, this.b);
            Triangle.v1.subVectors(this.a, this.b);
            return Triangle.v0.cross(Triangle.v1).length() * 0.5;
        }
        getMidpoint(target) {
            if (target === undefined) {
                console.warn('THREE.Triangle: .getMidpoint() target is now required');
                target = new THREE.Vector3();
            }
            return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(target) {
            return Triangle.getNormal(this.a, this.b, this.c, target);
        }
        //@TODO setFromCoplanarPoints on defined in Vector3
        getPlane(target) {
            if (target === undefined) {
                console.warn('THREE.Triangle: .getPlane() target is now required');
                target = new THREE.Vector3();
            }
            return target.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(point, target) {
            return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
        }
        containsPoint(point) {
            return Triangle.containsPoint(point, this.a, this.b, this.c);
        }
        intersectsBox(box) {
            return box.intersectsTriangle(this);
        }
        // public closestPointToPoint() {
        closestPointToPoint(point, target) {
            if (target === undefined) {
                console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
                target = new THREE.Vector3();
            }
            var minDistance = Infinity;
            // project the point onto the plane of the triangle
            Triangle.plane.setFromCoplanarPoints(this.a, this.b, this.c);
            Triangle.plane.projectPoint(point, Triangle.projectedPoint);
            // check if the projection lies within the triangle
            if (this.containsPoint(Triangle.projectedPoint) === true) {
                // if so, this is the closest point
                target.copy(Triangle.projectedPoint);
            }
            else {
                // if not, the point falls outside the triangle. the target is the closest point to the triangle's edges or vertices
                Triangle.edgeList[0].set(this.a, this.b);
                Triangle.edgeList[1].set(this.b, this.c);
                Triangle.edgeList[2].set(this.c, this.a);
                for (var i = 0; i < Triangle.edgeList.length; i++) {
                    Triangle.edgeList[i].closestPointToPoint(Triangle.projectedPoint, true, Triangle.closestPoint);
                    var distance = Triangle.projectedPoint.distanceToSquared(Triangle.closestPoint);
                    if (distance < minDistance) {
                        minDistance = distance;
                        target.copy(Triangle.closestPoint);
                    }
                }
            }
            return target;
        }
        equals(triangle) {
            return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }
    }
    Triangle.v0 = new THREE.Vector3();
    // public static v0 = new Vector3();
    Triangle.v1 = new THREE.Vector3();
    Triangle.v2 = new THREE.Vector3();
    Triangle.plane = {}; //= new Plane();
    Triangle.edgeList = [{}, {}, {}]; //= [new Line3(), new Line3(), new Line3()];
    Triangle.projectedPoint = new THREE.Vector3();
    Triangle.closestPoint = new THREE.Vector3();
    THREE.Triangle = Triangle;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    /**
     * @author Yanbei.HUANG
     * @description 2018/5/15
     */
    class Vector2 {
        /**构造 */
        constructor(x, y) {
            this.x = x || 0;
            this.y = y || 0;
        }
        /**
         * 宽度
         */
        get width() {
            var self = this;
            return {
                get: function () {
                    return self.x;
                },
                set: function (value) {
                    self.x = value;
                }
            };
        }
        /**
         * 高度
         */
        get height() {
            var self = this;
            return {
                get: function () {
                    return self.y;
                },
                set: function (value) {
                    self.y = value;
                }
            };
        }
        /**
         * 复制
         * @param v
         */
        copy(v) {
            this.x = v.x;
            this.y = v.y;
            return this;
        }
        /**
         * 最小值
         * @param v
         */
        min(v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            return this;
        }
        /**
         * 最大值
         * @param v
         */
        max(v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            return this;
        }
        /**
         * 设置
         * @param x
         * @param y
         */
        set(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }
        /**
         * 设置缩放值
         * @param scalar
         */
        setScalar(scalar) {
            this.x = scalar;
            this.y = scalar;
            return this;
        }
        setX(x) {
            this.x = x;
            return this;
        }
        setY(y) {
            this.y = y;
            return this;
        }
        setComponent(index, value) {
            switch (index) {
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                default: throw new Error('index is out of range: ' + index);
            }
            return this;
        }
        getComponent(index) {
            switch (index) {
                case 0: return this.x;
                case 1: return this.y;
                default: throw new Error('index is out of range: ' + index);
            }
        }
        clone() {
            var vec = new Vector2(this.x, this.y);
            return vec;
        }
        add(v) {
            this.x += v.x;
            this.y += v.y;
            return this;
        }
        addScalar(s) {
            this.x += s;
            this.y += s;
            return this;
        }
        addVectors(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            return this;
        }
        addScaledVector(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            return this;
        }
        sub(v) {
            this.x -= v.x;
            this.y -= v.y;
            return this;
        }
        subScalar(s) {
            this.x -= s;
            this.y -= s;
            return this;
        }
        subVectors(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this;
        }
        multiply(v) {
            this.x *= v.x;
            this.y *= v.y;
            return this;
        }
        multiplyScalar(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            return this;
        }
        divide(v) {
            this.x /= v.x;
            this.y /= v.y;
            return this;
        }
        divideScalar(scalar) {
            return this.multiplyScalar(1 / scalar);
        }
        applyMatrix3(m) {
            var x = this.x, y = this.y;
            var e = m.elements;
            this.x = e[0] * x + e[3] * y + e[6];
            this.y = e[1] * x + e[4] * y + e[7];
            return this;
        }
        clamp(min, max) {
            // assumes min < max, componentwise
            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));
            return this;
        }
        clampScalar(minVal, maxVal) {
            var min = new Vector2();
            var max = new Vector2();
            min.set(minVal, minVal);
            max.set(maxVal, maxVal);
            return this.clamp(min, max);
        }
        ;
        clampLength(min, max) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
        }
        ceil() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
        }
        round() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        }
        roundToZero() {
            this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
            return this;
        }
        negate() {
            this.x = -this.x;
            this.y = -this.y;
            return this;
        }
        dot(v) {
            return this.x * v.x + this.y * v.y;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        angle() {
            // computes the angle in radians with respect to the positive x-axis
            var angle = Math.atan2(this.y, this.x);
            if (angle < 0)
                angle += 2 * Math.PI;
            return angle;
        }
        distanceTo(v) {
            return Math.sqrt(this.distanceToSquared(v));
        }
        distanceToSquared(v) {
            var dx = this.x - v.x, dy = this.y - v.y;
            return dx * dx + dy * dy;
        }
        manhattanDistanceTo(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        }
        setLength(length) {
            return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            return this;
        }
        lerpVectors(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        }
        equals(v) {
            return ((v.x === this.x) && (v.y === this.y));
        }
        fromArray(array, offset) {
            if (offset === undefined)
                offset = 0;
            this.x = array[offset];
            this.y = array[offset + 1];
            return this;
        }
        toArray(array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            array[offset] = this.x;
            array[offset + 1] = this.y;
            return array;
        }
        fromBufferAttribute(attribute, index) {
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            return this;
        }
        /**
         *
         * @param center
         * @param angle Radian
         */
        rotateAround(center, angle) {
            var c = Math.cos(angle), s = Math.sin(angle);
            var x = this.x - center.x;
            var y = this.y - center.y;
            this.x = x * c - y * s + center.x;
            this.y = x * s + y * c + center.y;
            return this;
        }
    }
    THREE.Vector2 = Vector2;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Vector4 {
        constructor(x, y, z, w) {
            this.isVector4 = true;
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = (w !== undefined) ? w : 1;
        }
        set(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        }
        setScalar(scalar) {
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            this.w = scalar;
            return this;
        }
        setX(x) {
            this.x = x;
            return this;
        }
        setY(y) {
            this.y = y;
            return this;
        }
        setZ(z) {
            this.z = z;
            return this;
        }
        setW(w) {
            this.w = w;
            return this;
        }
        setComponent(index, value) {
            switch (index) {
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                case 2:
                    this.z = value;
                    break;
                case 3:
                    this.w = value;
                    break;
                default: throw new Error('index is out of range: ' + index);
            }
            return this;
        }
        getComponent(index) {
            switch (index) {
                case 0: return this.x;
                case 1: return this.y;
                case 2: return this.z;
                case 3: return this.w;
                default: throw new Error('index is out of range: ' + index);
            }
        }
        clone() {
            return new Vector4(this.x, this.y, this.z, this.w);
        }
        copy(v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = (v.w !== undefined) ? v.w : 1;
            return this;
        }
        add(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            this.w += v.w;
            return this;
        }
        addScalar(s) {
            this.x += s;
            this.y += s;
            this.z += s;
            this.w += s;
            return this;
        }
        addVectors(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;
            return this;
        }
        addScaledVector(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            this.w += v.w * s;
            return this;
        }
        sub(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            this.w -= v.w;
            return this;
        }
        subScalar(s) {
            this.x -= s;
            this.y -= s;
            this.z -= s;
            this.w -= s;
            return this;
        }
        subVectors(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;
            return this;
        }
        multiplyScalar(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            this.w *= scalar;
            return this;
        }
        applyMatrix4(m) {
            var x = this.x, y = this.y, z = this.z, w = this.w;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
            this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
            return this;
        }
        divideScalar(scalar) {
            return this.multiplyScalar(1 / scalar);
        }
        setAxisAngleFromQuaternion(q) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
            // q is assumed to be normalized
            this.w = 2 * Math.acos(q.w);
            var s = Math.sqrt(1 - q.w * q.w);
            if (s < 0.0001) {
                this.x = 1;
                this.y = 0;
                this.z = 0;
            }
            else {
                this.x = q.x / s;
                this.y = q.y / s;
                this.z = q.z / s;
            }
            return this;
        }
        setAxisAngleFromRotationMatrix(m) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var angle, x, y, z, // variables for result
            epsilon = 0.01, // margin to allow for rounding errors
            epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees
            te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
            if ((Math.abs(m12 - m21) < epsilon) &&
                (Math.abs(m13 - m31) < epsilon) &&
                (Math.abs(m23 - m32) < epsilon)) {
                // singularity found
                // first check for identity matrix which must have +1 for all terms
                // in leading diagonal and zero in other terms
                if ((Math.abs(m12 + m21) < epsilon2) &&
                    (Math.abs(m13 + m31) < epsilon2) &&
                    (Math.abs(m23 + m32) < epsilon2) &&
                    (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
                    // this singularity is identity matrix so angle = 0
                    this.set(1, 0, 0, 0);
                    return this; // zero angle, arbitrary axis
                }
                // otherwise this singularity is angle = 180
                angle = Math.PI;
                var xx = (m11 + 1) / 2;
                var yy = (m22 + 1) / 2;
                var zz = (m33 + 1) / 2;
                var xy = (m12 + m21) / 4;
                var xz = (m13 + m31) / 4;
                var yz = (m23 + m32) / 4;
                if ((xx > yy) && (xx > zz)) {
                    // m11 is the largest diagonal term
                    if (xx < epsilon) {
                        x = 0;
                        y = 0.707106781;
                        z = 0.707106781;
                    }
                    else {
                        x = Math.sqrt(xx);
                        y = xy / x;
                        z = xz / x;
                    }
                }
                else if (yy > zz) {
                    // m22 is the largest diagonal term
                    if (yy < epsilon) {
                        x = 0.707106781;
                        y = 0;
                        z = 0.707106781;
                    }
                    else {
                        y = Math.sqrt(yy);
                        x = xy / y;
                        z = yz / y;
                    }
                }
                else {
                    // m33 is the largest diagonal term so base result on this
                    if (zz < epsilon) {
                        x = 0.707106781;
                        y = 0.707106781;
                        z = 0;
                    }
                    else {
                        z = Math.sqrt(zz);
                        x = xz / z;
                        y = yz / z;
                    }
                }
                this.set(x, y, z, angle);
                return this; // return 180 deg rotation
            }
            // as we have reached here there are no singularities so we can handle normally
            var s = Math.sqrt((m32 - m23) * (m32 - m23) +
                (m13 - m31) * (m13 - m31) +
                (m21 - m12) * (m21 - m12)); // used to normalize
            if (Math.abs(s) < 0.001)
                s = 1;
            // prevent divide by zero, should not happen if matrix is orthogonal and should be
            // caught by singularity test above, but I've left it in just in case
            this.x = (m32 - m23) / s;
            this.y = (m13 - m31) / s;
            this.z = (m21 - m12) / s;
            this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
            return this;
        }
        min(v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            this.w = Math.min(this.w, v.w);
            return this;
        }
        max(v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            this.w = Math.max(this.w, v.w);
            return this;
        }
        clamp(min, max) {
            // assumes min < max, componentwise
            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));
            this.z = Math.max(min.z, Math.min(max.z, this.z));
            this.w = Math.max(min.w, Math.min(max.w, this.w));
            return this;
        }
        // public clampScalar(): Vector4 {
        clampScalar(minVal, maxVal) {
            if (Vector4.min === undefined) {
                Vector4.min = new Vector4();
                Vector4.max = new Vector4();
            }
            Vector4.min.set(minVal, minVal, minVal, minVal);
            Vector4.max.set(maxVal, maxVal, maxVal, maxVal);
            return this.clamp(Vector4.min, Vector4.max);
        }
        clampLength(min, max) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        }
        floor() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            this.w = Math.floor(this.w);
            return this;
        }
        ceil() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            this.w = Math.ceil(this.w);
            return this;
        }
        round() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            this.w = Math.round(this.w);
            return this;
        }
        roundToZero() {
            this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
            this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);
            return this;
        }
        negate() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            return this;
        }
        dot(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
            return this.divideScalar(this.length() || 1);
        }
        setLength(length) {
            return this.normalize().multiplyScalar(length);
        }
        lerp(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            this.w += (v.w - this.w) * alpha;
            return this;
        }
        lerpVectors(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        }
        equals(v) {
            return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
        }
        fromArray(array, offset) {
            if (offset === undefined)
                offset = 0;
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            this.w = array[offset + 3];
            return this;
        }
        toArray(array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            array[offset + 3] = this.w;
            return array;
        }
        fromBufferAttribute(attribute, index, offset) {
            if (offset !== undefined) {
                console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
            }
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            this.z = attribute.getZ(index);
            this.w = attribute.getW(index);
            return this;
        }
    }
    Vector4.min = new Vector4();
    Vector4.max = new Vector4();
    THREE.Vector4 = Vector4;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class CubicInterpolant extends THREE.Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            super(parameterPositions, sampleValues, sampleSize, resultBuffer);
            this._weightPrev = -0;
            this._offsetPrev = -0;
            this._weightNext = -0;
            this._offsetNext = -0;
            this.DefaultSettings_ = {
                endingStart: THREE.ZeroCurvatureEnding,
                endingEnd: THREE.ZeroCurvatureEnding
            };
            this._weightPrev = -0;
            this._offsetPrev = -0;
            this._weightNext = -0;
            this._offsetNext = -0;
        }
        intervalChanged_(i1, t0, t1) {
            var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
            if (tPrev === undefined) {
                switch (this.getSettings_().endingStart) {
                    case THREE.ZeroSlopeEnding:
                        // f'(t0) = 0
                        iPrev = i1;
                        tPrev = 2 * t0 - t1;
                        break;
                    case THREE.WrapAroundEnding:
                        // use the other end of the curve
                        iPrev = pp.length - 2;
                        tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                        break;
                    default: // ZeroCurvatureEnding
                        // f''(t0) = 0 a.k.a. Natural Spline
                        iPrev = i1;
                        tPrev = t1;
                }
            }
            if (tNext === undefined) {
                switch (this.getSettings_().endingEnd) {
                    case THREE.ZeroSlopeEnding:
                        // f'(tN) = 0
                        iNext = i1;
                        tNext = 2 * t1 - t0;
                        break;
                    case THREE.WrapAroundEnding:
                        // use the other end of the curve
                        iNext = 1;
                        tNext = t1 + pp[1] - pp[0];
                        break;
                    default: // ZeroCurvatureEnding
                        // f''(tN) = 0, a.k.a. Natural Spline
                        iNext = i1 - 1;
                        tNext = t0;
                }
            }
            var halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
            this._weightPrev = halfDt / (t0 - tPrev);
            this._weightNext = halfDt / (tNext - t1);
            this._offsetPrev = iPrev * stride;
            this._offsetNext = iNext * stride;
        }
        interpolate_(i1, t0, t, t1) {
            var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
            // evaluate polynomials
            var sP = -wP * ppp + 2 * wP * pp - wP * p;
            var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
            var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
            var sN = wN * ppp - wN * pp;
            // combine data linearly
            for (var i = 0; i !== stride; ++i) {
                result[i] =
                    sP * values[oP + i] +
                        s0 * values[o0 + i] +
                        s1 * values[o1 + i] +
                        sN * values[oN + i];
            }
            return result;
        }
    }
    THREE.CubicInterpolant = CubicInterpolant;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class DiscreteInterpolant extends THREE.Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1 /*, t0, t, t1 */) {
            return this.copySampleValue_(i1 - 1);
        }
    }
    THREE.DiscreteInterpolant = DiscreteInterpolant;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class LinearInterpolant extends THREE.Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t, t1) {
            var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
            for (var i = 0; i !== stride; ++i) {
                result[i] =
                    values[offset0 + i] * weight0 +
                        values[offset1 + i] * weight1;
            }
            return result;
        }
    }
    THREE.LinearInterpolant = LinearInterpolant;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class QuaternionLinearInterpolant extends THREE.Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
            super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        interpolate_(i1, t0, t, t1) {
            var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0);
            for (var end = offset + stride; offset !== end; offset += 4) {
                THREE.Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
            }
            return result;
        }
    }
    THREE.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Bone extends THREE.Object3D {
        constructor() {
            super();
            this.isBone = true;
            this.type = 'Bone';
        }
    }
    THREE.Bone = Bone;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Group extends THREE.Object3D {
        constructor() {
            super();
            this.isGroup = true;
            this.type = 'Group';
        }
    }
    THREE.Group = Group;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class LOD extends THREE.Object3D {
        constructor() {
            super();
            this.type = 'LOD';
        }
        copy(source) {
            //Object3D.prototype.copy.call(this, source, false);
            super.copy(source, false);
            var levels = source.levels;
            for (var i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                this.addLevel(level.object.clone(), level.distance);
            }
            return this;
        }
        addLevel(object, distance) {
            if (distance === undefined)
                distance = 0;
            distance = Math.abs(distance);
            var levels = this.levels;
            for (var l = 0; l < levels.length; l++) {
                if (distance < levels[l].distance) {
                    break;
                }
            }
            levels.splice(l, 0, { distance: distance, object: object });
            this.add(object);
        }
        getObjectForDistance(distance) {
            var levels = this.levels;
            for (var i = 1, l = levels.length; i < l; i++) {
                if (distance < levels[i].distance) {
                    break;
                }
            }
            return levels[i - 1].object;
        }
        raycast(raycaster, intersects) {
            //TODO:
            var matrixPosition = new THREE.Vector3();
            matrixPosition.setFromMatrixPosition(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(matrixPosition);
            this.getObjectForDistance(distance).raycast(raycaster, intersects);
        }
        update(camera) {
            var v1 = new THREE.Vector3();
            var v2 = new THREE.Vector3();
            var levels = this.levels;
            if (levels.length > 1) {
                v1.setFromMatrixPosition(camera.matrixWorld);
                v2.setFromMatrixPosition(this.matrixWorld);
                var distance = v1.distanceTo(v2);
                levels[0].object.visible = true;
                for (var i = 1, l = levels.length; i < l; i++) {
                    if (distance >= levels[i].distance) {
                        levels[i - 1].object.visible = false;
                        levels[i].object.visible = true;
                    }
                    else {
                        break;
                    }
                }
                for (; i < l; i++) {
                    levels[i].object.visible = false;
                }
            }
        }
        toJSON(meta) {
            var data = THREE.Object3D.prototype.toJSON.call(this, meta);
            data.object.levels = [];
            var levels = this.levels;
            for (var i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                data.object.levels.push({
                    object: level.object.uuid,
                    distance: level.distance
                });
            }
            return data;
        }
    }
    THREE.LOD = LOD;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class LineLoop extends THREE.Line {
        constructor(geometry, material) {
            super(geometry, material);
            this.isLineLoop = true;
            this.type = 'LineLoop';
        }
    }
    THREE.LineLoop = LineLoop;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Points extends THREE.Object3D {
        constructor(geometry, material) {
            super();
            this.isPoints = true;
            this.type = 'Points';
            this.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();
            this.material = material !== undefined ? material : new PointsMaterial({ color: Math.random() * 0xffffff });
        }
        raycast(raycaster, intersects) {
            //TODO:
            var inverseMatrix = new THREE.Matrix4();
            var ray = new THREE.Ray();
            var sphere = new THREE.Sphere();
            var object = this;
            var geometry = this.geometry;
            var matrixWorld = this.matrixWorld;
            var threshold = raycaster.params.Points.threshold;
            // Checking boundingSphere distance to ray
            if (geometry.boundingSphere === null)
                geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere);
            sphere.applyMatrix4(matrixWorld);
            sphere.radius += threshold;
            if (raycaster.ray.intersectsSphere(sphere) === false)
                return;
            //
            inverseMatrix.getInverse(matrixWorld);
            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
            var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
            var localThresholdSq = localThreshold * localThreshold;
            var position = new THREE.Vector3();
            var intersectPoint = new THREE.Vector3();
            function testPoint(point, index) {
                var rayPointDistanceSq = ray.distanceSqToPoint(point);
                if (rayPointDistanceSq < localThresholdSq) {
                    ray.closestPointToPoint(point, intersectPoint);
                    intersectPoint.applyMatrix4(matrixWorld);
                    var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                    if (distance < raycaster.near || distance > raycaster.far)
                        return;
                    intersects.push({
                        distance: distance,
                        distanceToRay: Math.sqrt(rayPointDistanceSq),
                        point: intersectPoint.clone(),
                        index: index,
                        face: null,
                        object: object
                    });
                }
            }
            if (geometry.isBufferGeometry) {
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positions = attributes.position.array;
                if (index !== null) {
                    var indices = index.array;
                    for (var i = 0, il = indices.length; i < il; i++) {
                        var a = indices[i];
                        position.fromArray(positions, a * 3);
                        testPoint(position, a);
                    }
                }
                else {
                    for (var i = 0, l = positions.length / 3; i < l; i++) {
                        position.fromArray(positions, i * 3);
                        testPoint(position, i);
                    }
                }
            }
            else {
                var vertices = geometry.vertices;
                for (var i = 0, l = vertices.length; i < l; i++) {
                    testPoint(vertices[i], i);
                }
            }
        }
        clone() {
            return new Points(this.geometry, this.material).copy(this);
        }
    }
    THREE.Points = Points;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Skeleton {
        constructor(bones, boneInverses) {
            // copy the bone array
            bones = bones || [];
            this.bones = bones.slice(0);
            this.boneMatrices = new Float32Array(this.bones.length * 16);
            // use the supplied bone inverses or calculate the inverses
            if (boneInverses === undefined) {
                this.calculateInverses();
            }
            else {
                if (this.bones.length === boneInverses.length) {
                    this.boneInverses = boneInverses.slice(0);
                }
                else {
                    console.warn('THREE.Skeleton boneInverses is the wrong length.');
                    this.boneInverses = [];
                    for (var i = 0, il = this.bones.length; i < il; i++) {
                        this.boneInverses.push(new THREE.Matrix4());
                    }
                }
            }
        }
        calculateInverses() {
            this.boneInverses = [];
            for (var i = 0, il = this.bones.length; i < il; i++) {
                var inverse = new THREE.Matrix4();
                if (this.bones[i]) {
                    inverse.getInverse(this.bones[i].matrixWorld);
                }
                this.boneInverses.push(inverse);
            }
        }
        pose() {
            var bone, i, il;
            // recover the bind-time world matrices
            for (i = 0, il = this.bones.length; i < il; i++) {
                bone = this.bones[i];
                if (bone) {
                    bone.matrixWorld.getInverse(this.boneInverses[i]);
                }
            }
            // compute the local matrices, positions, rotations and scales
            for (i = 0, il = this.bones.length; i < il; i++) {
                bone = this.bones[i];
                if (bone) {
                    if (bone.parent && bone.parent.isBone) {
                        bone.matrix.getInverse(bone.parent.matrixWorld);
                        bone.matrix.multiply(bone.matrixWorld);
                    }
                    else {
                        bone.matrix.copy(bone.matrixWorld);
                    }
                    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
                }
            }
        }
        update() {
            //TODO:
            var offsetMatrix = new THREE.Matrix4();
            var identityMatrix = new THREE.Matrix4();
            var bones = this.bones;
            var boneInverses = this.boneInverses;
            var boneMatrices = this.boneMatrices;
            var boneTexture = this.boneTexture;
            // flatten bone matrices to array
            for (var i = 0, il = bones.length; i < il; i++) {
                // compute the offset between the current and the original transform
                var matrix = bones[i] ? bones[i].matrixWorld : identityMatrix;
                offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
                offsetMatrix.toArray(boneMatrices, i * 16);
            }
            if (boneTexture !== undefined) {
                boneTexture.needsUpdate = true;
            }
        }
        clone() {
            return new Skeleton(this.bones, this.boneInverses);
        }
        getBoneByName(name) {
            for (var i = 0, il = this.bones.length; i < il; i++) {
                var bone = this.bones[i];
                if (bone.name === name) {
                    return bone;
                }
            }
            return undefined;
        }
    }
    THREE.Skeleton = Skeleton;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class SkinnedMesh extends THREE.Mesh {
        constructor(geometry, material) {
            super(geometry, material);
            this.isSkinnedMesh = true;
            this.type = 'SkinnedMesh';
            this.bindMode = 'attached';
            this.bindMatrix = new THREE.Matrix4();
            this.bindMatrixInverse = new THREE.Matrix4();
            var bones = this.initBones();
            var skeleton = new THREE.Skeleton(bones);
            this.bind(skeleton, this.matrixWorld);
            this.normalizeSkinWeights();
        }
        initBones() {
            var bones = [], bone, gbone;
            var i, il;
            if (this.geometry && this.geometry.bones !== undefined) {
                // first, create array of 'Bone' objects from geometry data
                for (i = 0, il = this.geometry.bones.length; i < il; i++) {
                    gbone = this.geometry.bones[i];
                    // create new 'Bone' object
                    bone = new THREE.Bone();
                    bones.push(bone);
                    // apply values
                    bone.name = gbone.name;
                    bone.position.fromArray(gbone.pos);
                    bone.quaternion.fromArray(gbone.rotq);
                    if (gbone.scl !== undefined)
                        bone.scale.fromArray(gbone.scl);
                }
                // second, create bone hierarchy
                for (i = 0, il = this.geometry.bones.length; i < il; i++) {
                    gbone = this.geometry.bones[i];
                    if ((gbone.parent !== -1) && (gbone.parent !== null) && (bones[gbone.parent] !== undefined)) {
                        // subsequent bones in the hierarchy
                        bones[gbone.parent].add(bones[i]);
                    }
                    else {
                        // topmost bone, immediate child of the skinned mesh
                        this.add(bones[i]);
                    }
                }
            }
            // now the bones are part of the scene graph and children of the skinned mesh.
            // let's update the corresponding matrices
            this.updateMatrixWorld(true);
            return bones;
        }
        bind(skeleton, bindMatrix) {
            this.skeleton = skeleton;
            if (bindMatrix === undefined) {
                this.updateMatrixWorld(true);
                this.skeleton.calculateInverses();
                bindMatrix = this.matrixWorld;
            }
            this.bindMatrix.copy(bindMatrix);
            this.bindMatrixInverse.getInverse(bindMatrix);
        }
        pose() {
            this.skeleton.pose();
        }
        normalizeSkinWeights() {
            var scale, i;
            if (this.geometry && this.geometry.isGeometry) {
                for (i = 0; i < this.geometry.skinWeights.length; i++) {
                    var sw = this.geometry.skinWeights[i];
                    scale = 1.0 / sw.manhattanLength();
                    if (scale !== Infinity) {
                        sw.multiplyScalar(scale);
                    }
                    else {
                        sw.set(1, 0, 0, 0); // do something reasonable
                    }
                }
            }
            else if (this.geometry && this.geometry.isBufferGeometry) {
                var vec = new THREE.Vector4();
                var skinWeight = this.geometry.attributes.skinWeight;
                for (i = 0; i < skinWeight.count; i++) {
                    vec.x = skinWeight.getX(i);
                    vec.y = skinWeight.getY(i);
                    vec.z = skinWeight.getZ(i);
                    vec.w = skinWeight.getW(i);
                    scale = 1.0 / vec.manhattanLength();
                    if (scale !== Infinity) {
                        vec.multiplyScalar(scale);
                    }
                    else {
                        vec.set(1, 0, 0, 0); // do something reasonable
                    }
                    skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
                }
            }
        }
        updateMatrixWorld(force) {
            //Mesh.prototype.updateMatrixWorld.call(this, force);
            this.updateMatrixWorld = force;
            if (this.bindMode === 'attached') {
                this.bindMatrixInverse.getInverse(this.matrixWorld);
            }
            else if (this.bindMode === 'detached') {
                this.bindMatrixInverse.getInverse(this.bindMatrix);
            }
            else {
                console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
            }
        }
        clone() {
            return new SkinnedMesh(this.geometry, this.material).copy(this);
        }
    }
    THREE.SkinnedMesh = SkinnedMesh;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Sprite extends THREE.Object3D {
        constructor(material) {
            super();
            this.isSprite = true;
            this.type = 'Sprite';
            this.material = (material !== undefined) ? material : new SpriteMaterial();
            this.center = new THREE.Vector2(0.5, 0.5);
        }
        raycast(raycaster, intersects) {
            //TODO:
            var intersectPoint = new THREE.Vector3();
            var worldPosition = new THREE.Vector3();
            var worldScale = new THREE.Vector3();
            worldPosition.setFromMatrixPosition(this.matrixWorld);
            raycaster.ray.closestPointToPoint(worldPosition, intersectPoint);
            worldScale.setFromMatrixScale(this.matrixWorld);
            var guessSizeSq = worldScale.x * worldScale.y / 4;
            if (worldPosition.distanceToSquared(intersectPoint) > guessSizeSq)
                return;
            var distance = raycaster.ray.origin.distanceTo(intersectPoint);
            if (distance < raycaster.near || distance > raycaster.far)
                return;
            intersects.push({
                distance: distance,
                point: intersectPoint.clone(),
                face: null,
                object: this
            });
        }
        clone() {
            return new Sprite(this.material).copy(this);
        }
        copy(source) {
            //Object3D.prototype.copy.call(this, source);
            this.copy(source);
            if (source.center !== undefined)
                this.center.copy(source.center);
            return this;
        }
    }
    THREE.Sprite = Sprite;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGL2Renderer {
        constructor(parameters) {
            console.log('THREE.WebGL2Renderer', THREE.REVISION);
            parameters = parameters || {};
            this._canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            this._context = parameters.context !== undefined ? parameters.context : null;
            this._alpha = parameters.alpha !== undefined ? parameters.alpha : false;
            this._depth = parameters.depth !== undefined ? parameters.depth : true;
            this._stencil = parameters.stencil !== undefined ? parameters.stencil : true;
            this._antialias = parameters.antialias !== undefined ? parameters.antialias : false;
            this._premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true;
            this._preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
            this._powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';
            // initialize
            this.gl;
            try {
                this.attributes = {
                    alpha: this._alpha,
                    depth: this._depth,
                    stencil: this._stencil,
                    antialias: this._antialias,
                    premultipliedAlpha: this._premultipliedAlpha,
                    preserveDrawingBuffer: this._preserveDrawingBuffer,
                    powerPreference: this._powerPreference
                };
                // event listeners must be registered before WebGL context is created, see #12753
                this._canvas.addEventListener('webglcontextlost', this.onContextLost, false);
                this._canvas.addEventListener('webglcontextrestored', function () { });
                this.gl = this._context || this._canvas.getContext('webgl2', this.attributes);
                if (this.gl === null) {
                    if (this._canvas.getContext('webgl2') !== null) {
                        throw new Error('Error creating WebGL2 context with your selected attributes.');
                    }
                    else {
                        throw new Error('Error creating WebGL2 context.');
                    }
                }
            }
            catch (error) {
                console.error('THREE.WebGL2Renderer: ' + error.message);
            }
            //
            this._autoClear = true;
            this._autoClearColor = true;
            this._autoClearDepth = true;
            this._autoClearStencil = true;
            this._clearColor = new THREE.Color(0x000000);
            this._clearAlpha = 0;
            this._width = this._canvas.width;
            this._height = this._canvas.height;
            this._pixelRatio = 1;
            this._viewport = new THREE.Vector4(0, 0, this._width, this._height);
            this.extensions = new THREE.WebGLExtensionsNode(this.gl);
            this.state = new THREE.WebGLStateNode(this.gl, this.extensions, function () { });
        }
        //
        clear(color, depth, stencil) {
            var bits = 0;
            if (color === undefined || color)
                bits |= this.gl.COLOR_BUFFER_BIT;
            if (depth === undefined || depth)
                bits |= this.gl.DEPTH_BUFFER_BIT;
            if (stencil === undefined || stencil)
                bits |= this.gl.STENCIL_BUFFER_BIT;
            this.gl.clear(bits);
        }
        setPixelRatio(value) {
            if (value === undefined)
                return;
            this._pixelRatio = value;
            this.setSize(this._viewport.z, this._viewport.w, false);
        }
        setSize(width, height, updateStyle) {
            this._width = width;
            this._height = height;
            this._canvas.width = width * this._pixelRatio;
            this._canvas.height = height * this._pixelRatio;
            if (updateStyle !== false) {
                this._canvas.style.width = width + 'px';
                this._canvas.style.height = height + 'px';
            }
            this.setViewport(0, 0, width, height);
        }
        setViewport(x, y, width, height) {
            this.state.viewport(this._viewport.set(x, y, width, height));
        }
        render(scene, camera) {
            if (camera !== undefined && camera.isCamera !== true) {
                console.error('THREE.WebGL2Renderer.render: camera is not an instance of THREE.Camera.');
                return;
            }
            var background = scene.background;
            var forceClear = false;
            if (background === null) {
                this.state.buffers.color.setClear(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha, this._premultipliedAlpha);
            }
            else if (background && background.isColor) {
                this.state.buffers.color.setClear(background.r, background.g, background.b, 1, this._premultipliedAlpha);
                forceClear = true;
            }
            if (this._autoClear || forceClear) {
                this.clear(this._autoClearColor, this._autoClearDepth, this._autoClearStencil);
            }
        }
        onContextLost(event) {
            event.preventDefault();
        }
        get domElement() {
            return this._canvas;
        }
    }
    THREE.WebGL2Renderer = WebGL2Renderer;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLRenderTarget extends THREE.EventDispatcher {
        constructor(width, height, options) {
            super();
            this.width = width;
            this.height = height;
            this.scissor = new THREE.Vector4(0, 0, width, height);
            this.scissorTest = false;
            this.viewport = new THREE.Vector4(0, 0, width, height);
            options = options || {};
            if (options.minFilter === undefined)
                options.minFilter = THREE.LinearFilter;
            this.texture = new THREE.Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
            this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : true;
            this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
            this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
            this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
            this.isWebGLRenderTarget = true;
        }
        setSize(width, height) {
            if (this.width !== width || this.height !== height) {
                this.width = width;
                this.height = height;
                this.dispose();
            }
            this.viewport.set(0, 0, width, height);
            this.scissor.set(0, 0, width, height);
        }
        clone() {
            var target = new WebGLRenderTarget(null, null, null);
            target.copy(this);
            return target;
        }
        copy(source) {
            this.width = source.width;
            this.height = source.height;
            this.viewport.copy(source.viewport);
            this.texture = source.texture.clone();
            this.depthBuffer = source.depthBuffer;
            this.stencilBuffer = source.stencilBuffer;
            this.depthTexture = source.depthTexture;
            return this;
        }
        dispose() {
            this.dispatchEvent({ type: 'dispose' });
        }
    }
    THREE.WebGLRenderTarget = WebGLRenderTarget;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLRenderTargetCube extends THREE.WebGLRenderTarget {
        constructor(width, height, options) {
            super(width, height, options);
            this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
            this.activeMipMapLevel = 0;
            this.isWebGLRenderTargetCube = true;
        }
    }
    THREE.WebGLRenderTargetCube = WebGLRenderTargetCube;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLRenderer {
        constructor(parameters) {
            // tone mapping
            this.toneMapping = THREE.LinearToneMapping;
            this.isAnimating = false;
            this.onAnimationFrame = null;
            /**
             * 立即渲染buffer
             */
            this.renderBufferImmediate = function (object, program, material) {
                this.state.initAttributes();
                var buffers = this.properties.get(object);
                if (object.hasPositions && !buffers.position)
                    buffers.position = this._gl.createBuffer();
                if (object.hasNormals && !buffers.normal)
                    buffers.normal = this._gl.createBuffer();
                if (object.hasUvs && !buffers.uv)
                    buffers.uv = this._gl.createBuffer();
                if (object.hasColors && !buffers.color)
                    buffers.color = this._gl.createBuffer();
                var programAttributes = program.getAttributes();
                if (object.hasPositions) {
                    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffers.position);
                    this._gl.bufferData(this._gl.ARRAY_BUFFER, object.positionArray, this._gl.DYNAMIC_DRAW);
                    this.state.enableAttribute(programAttributes.position);
                    this._gl.vertexAttribPointer(programAttributes.position, 3, this._gl.FLOAT, false, 0, 0);
                }
                if (object.hasNormals) {
                    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffers.normal);
                    if (!material.isMeshPhongMaterial &&
                        !material.isMeshStandardMaterial &&
                        !material.isMeshNormalMaterial &&
                        material.flatShading === true) {
                        for (var i = 0, l = object.count * 3; i < l; i += 9) {
                            var array = object.normalArray;
                            var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
                            var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
                            var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
                            array[i + 0] = nx;
                            array[i + 1] = ny;
                            array[i + 2] = nz;
                            array[i + 3] = nx;
                            array[i + 4] = ny;
                            array[i + 5] = nz;
                            array[i + 6] = nx;
                            array[i + 7] = ny;
                            array[i + 8] = nz;
                        }
                    }
                    this._gl.bufferData(this._gl.ARRAY_BUFFER, object.normalArray, this._gl.DYNAMIC_DRAW);
                    this.state.enableAttribute(programAttributes.normal);
                    this._gl.vertexAttribPointer(programAttributes.normal, 3, this._gl.FLOAT, false, 0, 0);
                }
                if (object.hasUvs && material.map) {
                    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffers.uv);
                    this._gl.bufferData(this._gl.ARRAY_BUFFER, object.uvArray, this._gl.DYNAMIC_DRAW);
                    this.state.enableAttribute(programAttributes.uv);
                    this._gl.vertexAttribPointer(programAttributes.uv, 2, this._gl.FLOAT, false, 0, 0);
                }
                if (object.hasColors && material.vertexColors !== THREE.NoColors) {
                    this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffers.color);
                    this._gl.bufferData(this._gl.ARRAY_BUFFER, object.colorArray, this._gl.DYNAMIC_DRAW);
                    this.state.enableAttribute(programAttributes.color);
                    this._gl.vertexAttribPointer(programAttributes.color, 3, this._gl.FLOAT, false, 0, 0);
                }
                this.state.disableUnusedAttributes();
                this._gl.drawArrays(this._gl.TRIANGLES, 0, object.count);
                object.count = 0;
            };
            /**
             * 直接渲染buffer
            */
            this.renderBufferDirect = function (camera, fog, geometry, material, object, group) {
                var frontFaceCW = (object.isMesh && object.matrixWorld.determinant() < 0);
                this.state.setMaterial(material, frontFaceCW);
                // 创建program，初始化uniform的值
                var program = this.setProgram(camera, fog, material, object);
                var geometryProgram = geometry.id + '_' + program.id + '_' + (material.wireframe === true);
                var updateBuffers = false;
                if (geometryProgram !== this._currentGeometryProgram) {
                    this._currentGeometryProgram = geometryProgram;
                    updateBuffers = true;
                }
                if (object.morphTargetInfluences) {
                    this.morphtargets.update(object, geometry, material, program);
                    updateBuffers = true;
                }
                //
                var index = geometry.index;
                var position = geometry.attributes.position;
                var rangeFactor = 1;
                if (material.wireframe === true) {
                    index = this.geometries.getWireframeAttribute(geometry);
                    rangeFactor = 2;
                }
                var attribute;
                var renderer = this.bufferRenderer;
                if (index !== null) {
                    attribute = this.attributes.get(index);
                    renderer = this.indexedBufferRenderer;
                    renderer.setIndex(attribute);
                }
                if (updateBuffers) {
                    // 更新顶点属性值
                    this.setupVertexAttributes(material, program, geometry);
                    if (index !== null) {
                        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, attribute.buffer);
                    }
                }
                //
                var dataCount = Infinity;
                if (index !== null) {
                    dataCount = index.count;
                }
                else if (position !== undefined) {
                    dataCount = position.count;
                }
                // 计算顶点个数
                var rangeStart = geometry.drawRange.start * rangeFactor;
                var rangeCount = geometry.drawRange.count * rangeFactor;
                var groupStart = group !== null ? group.start * rangeFactor : 0;
                var groupCount = group !== null ? group.count * rangeFactor : Infinity;
                var drawStart = Math.max(rangeStart, groupStart);
                var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
                var drawCount = Math.max(0, drawEnd - drawStart + 1);
                if (drawCount === 0)
                    return;
                // 设置绘制模式
                if (object.isMesh) {
                    if (material.wireframe === true) {
                        this.state.setLineWidth(material.wireframeLinewidth * this.getTargetPixelRatio());
                        renderer.setMode(this._gl.LINES);
                    }
                    else {
                        switch (object.drawMode) {
                            case THREE.TrianglesDrawMode:
                                renderer.setMode(this._gl.TRIANGLES);
                                break;
                            case THREE.TriangleStripDrawMode:
                                renderer.setMode(this._gl.TRIANGLE_STRIP);
                                break;
                            case THREE.TriangleFanDrawMode:
                                renderer.setMode(this._gl.TRIANGLE_FAN);
                                break;
                        }
                    }
                }
                else if (object.isLine) {
                    var lineWidth = material.linewidth;
                    if (lineWidth === undefined)
                        lineWidth = 1; // Not using Line*Material
                    this.state.setLineWidth(lineWidth * this.getTargetPixelRatio());
                    if (object.isLineSegments) {
                        renderer.setMode(this._gl.LINES);
                    }
                    else if (object.isLineLoop) {
                        renderer.setMode(this._gl.LINE_LOOP);
                    }
                    else {
                        renderer.setMode(this._gl.LINE_STRIP);
                    }
                }
                else if (object.isPoints) {
                    renderer.setMode(this._gl.POINTS);
                }
                if (geometry && geometry.isInstancedBufferGeometry) {
                    if (geometry.maxInstancedCount > 0) {
                        renderer.renderInstances(geometry, drawStart, drawCount);
                    }
                }
                else {
                    // 渲染
                    renderer.render(drawStart, drawCount);
                }
            };
            // Compile
            /**
             * 编译
             */
            this.compile = function (scene, camera) {
                this.currentRenderState = this.renderStates.get(scene, camera);
                this.currentRenderState.init();
                scene.traverse(function (object) {
                    if (object.isLight) {
                        this.currentRenderState.pushLight(object);
                        if (object.castShadow) {
                            this.currentRenderState.pushShadow(object);
                        }
                    }
                });
                this.currentRenderState.setupLights(camera);
                scene.traverse(function (object) {
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            for (var i = 0; i < object.material.length; i++) {
                                this.initMaterial(object.material[i], scene.fog, object);
                            }
                        }
                        else {
                            this.initMaterial(object.material, scene.fog, object);
                        }
                    }
                });
            };
            // this.setTexture2D = setTexture2D;
            //this.setTexture2D = (function () {
            this.warned_setTexture2D = false;
            this.warned_setTexture = false;
            this.warned_setTextureCube = false;
            this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {
                var width = srcTexture.image.width;
                var height = srcTexture.image.height;
                var glFormat = this.utils.convert(dstTexture.format);
                var glType = this.utils.convert(dstTexture.type);
                this.setTexture2D(dstTexture, 0);
                if (srcTexture.isDataTexture) {
                    this._gl.texSubImage2D(this._gl.TEXTURE_2D, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
                }
                else {
                    this._gl.texSubImage2D(this._gl.TEXTURE_2D, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
                }
            };
            console.log('THREE.WebGLRenderer', THREE.REVISION);
            this.parameters = parameters || {};
            parameters = this.parameters;
            this._canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            this._context = parameters.context !== undefined ? parameters.context : null;
            this._alpha = parameters.alpha !== undefined ? parameters.alpha : false;
            this._depth = parameters.depth !== undefined ? parameters.depth : true;
            this._stencil = parameters.stencil !== undefined ? parameters.stencil : true;
            this._antialias = parameters.antialias !== undefined ? parameters.antialias : false;
            this._premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true;
            this._preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
            this._powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';
            this.currentRenderList = null;
            this.currentRenderState = null;
            // public properties
            this.domElement = this._canvas;
            this.context = null;
            // clearing
            this.autoClear = true;
            this.autoClearColor = true;
            this.autoClearDepth = true;
            this.autoClearStencil = true;
            // scene graph
            this.sortObjects = true;
            // user-defined clipping
            this.clippingPlanes = [];
            this.localClippingEnabled = false;
            // physically based shading
            this.gammaFactor = 2.0; // for backwards compatibility
            this.gammaInput = false;
            this.gammaOutput = false;
            // physical lights
            this.physicallyCorrectLights = false;
            // tone mapping
            this.toneMapping = THREE.LinearToneMapping;
            this.toneMappingExposure = 1.0;
            this.toneMappingWhitePoint = 1.0;
            // morphs
            this.maxMorphTargets = 8;
            this.maxMorphNormals = 4;
            // internal properties
            this._this = this;
            this._isContextLost = false;
            // internal state cache
            this._currentRenderTarget = null;
            this._currentFramebuffer = null;
            this._currentMaterialId = -1;
            this._currentGeometryProgram = '';
            this._currentCamera = null;
            this._currentArrayCamera = null;
            this._currentViewport = new THREE.Vector4();
            this._currentScissor = new THREE.Vector4();
            this._currentScissorTest = null;
            //
            this._usedTextureUnits = 0;
            //
            this._width = this._canvas.width;
            this._height = this._canvas.height;
            this._pixelRatio = 1;
            this._viewport = new THREE.Vector4(0, 0, this._width, this._height);
            this._scissor = new THREE.Vector4(0, 0, this._width, this._height);
            this._scissorTest = false;
            // frustum
            this._frustum = new THREE.Frustum();
            // clipping
            this._clipping = new THREE.WebGLClippingNode();
            this._clippingEnabled = false;
            this._localClippingEnabled = false;
            // camera matrices cache
            this._projScreenMatrix = new THREE.Matrix4();
            this._vector3 = new THREE.Vector3();
            try {
                this.contextAttributes = {
                    alpha: this._alpha,
                    depth: this._depth,
                    stencil: this._stencil,
                    antialias: this._antialias,
                    premultipliedAlpha: this._premultipliedAlpha,
                    preserveDrawingBuffer: this._preserveDrawingBuffer,
                    powerPreference: this._powerPreference
                };
                // event listeners must be registered before WebGL context is created, see #12753
                this._canvas.addEventListener('webglcontextlost', this.onContextLost, false);
                this._canvas.addEventListener('webglcontextrestored', this.onContextRestore, false);
                this._gl = this._context || new THREE.WebGLContext(this._canvas, this.contextAttributes);
                if (this._gl === null) {
                    if (this._canvas.getContext('webgl') !== null) {
                        throw new Error('Error creating WebGL context with your selected attributes.');
                    }
                    else {
                        throw new Error('Error creating WebGL context.');
                    }
                }
                // Some experimental-webgl implementations do not have getShaderPrecisionFormat
                if (this._gl.getShaderPrecisionFormat === undefined) {
                    this._gl.getShaderPrecisionFormat = function () {
                        return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
                    };
                }
            }
            catch (error) {
                console.error('THREE.WebGLRenderer: ' + error.message);
            }
            // initialize
            this.initGLContext();
            // vr
            this.vr = ('xr' in navigator) ? new THREE.WebXRManager(this._gl) : new THREE.WebVRManager(this);
            // shadow map
            this.shadowMap = new THREE.WebGLShadowMapNode(this, this.objects, this.capabilities.maxTextureSize);
            // Animation Loop
            this.isAnimating = false;
            this.onAnimationFrame = null;
        }
        getTargetPixelRatio() {
            return this._currentRenderTarget === null ? this._pixelRatio : 1;
        }
        initGLContext() {
            this.extensions = new THREE.WebGLExtensionsNode(this._gl);
            this.extensions.get('WEBGL_depth_texture');
            this.extensions.get('OES_texture_float');
            this.extensions.get('OES_texture_float_linear');
            this.extensions.get('OES_texture_half_float');
            this.extensions.get('OES_texture_half_float_linear');
            this.extensions.get('OES_standard_derivatives');
            this.extensions.get('OES_element_index_uint');
            this.extensions.get('ANGLE_instanced_arrays');
            this.utils = new THREE.WebGLUtils(this._gl, this.extensions);
            this.capabilities = new THREE.WebGLCapabilitiesNode(this._gl, this.extensions, this.parameters);
            this.state = new THREE.WebGLStateNode(this._gl, this.extensions, this.utils);
            this.state.scissor(this._currentScissor.copy(this._scissor).multiplyScalar(this._pixelRatio));
            this.state.viewport(this._currentViewport.copy(this._viewport).multiplyScalar(this._pixelRatio));
            this.info = new THREE.WebGLInfoNode(this._gl);
            this.properties = new THREE.WebGLPropertiesNode();
            this.textures = new THREE.WebGLTexturesNode(this._gl, this.extensions, this.state, this.properties, this.capabilities, this.utils, this.info);
            this.attributes = new THREE.WebGLAttributesNode(this._gl);
            this.geometries = new THREE.WebGLGeometriesNode(this._gl, this.attributes, this.info);
            this.objects = new THREE.WebGLObjectsNode(this.geometries, this.info);
            this.morphtargets = new THREE.WebGLMorphtargetsNode(this._gl);
            this.programCache = new THREE.WebGLProgramsNode(this, this.extensions, this.capabilities);
            this.renderLists = new THREE.WebGLRenderListsNode();
            this.renderStates = new THREE.WebGLRenderStates();
            this.background = new THREE.WebGLBackgroundNode(this, this.state, this.objects, this._premultipliedAlpha);
            this.bufferRenderer = new THREE.WebGLBufferRendererNode(this._gl, this.extensions, this.info);
            this.indexedBufferRenderer = new THREE.WebGLIndexedBufferRendererNode(this._gl, this.extensions, this.info);
            this.spriteRenderer = new THREE.WebGLSpriteRendererNode(this, this._gl, this.state, this.textures, this.capabilities);
            this.info.programs = this.programCache.programs;
            this.context = this._gl;
            // _this.capabilities = capabilities;
            // _this.extensions = this.extensions;
            // _this.properties = properties;
            // _this.renderLists = renderLists;
            // _this.state = state;
            // _this.info = info;
        }
        // API
        getContext() {
            return this._gl;
        }
        getContextAttributes() {
            return this._gl.getContextAttributes();
        }
        forceContextLoss() {
            var extension = this.extensions.get('WEBGL_lose_context');
            if (extension)
                extension.loseContext();
        }
        forceContextRestore() {
            var extension = this.extensions.get('WEBGL_lose_context');
            if (extension)
                extension.restoreContext();
        }
        getPixelRatio() {
            return this._pixelRatio;
        }
        setPixelRatio(value) {
            if (value === undefined)
                return;
            this._pixelRatio = value;
            this.setSize(this._width, this._height, false);
        }
        getSize() {
            return {
                width: this._width,
                height: this._height
            };
        }
        setSize(width, height, updateStyle) {
            if (this.vr.isPresenting()) {
                console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
                return;
            }
            this._width = width;
            this._height = height;
            this._canvas.width = width * this._pixelRatio;
            this._canvas.height = height * this._pixelRatio;
            if (updateStyle !== false) {
                this._canvas.style.width = width + 'px';
                this._canvas.style.height = height + 'px';
            }
            this.setViewport(0, 0, width, height);
        }
        getDrawingBufferSize() {
            return {
                width: this._width * this._pixelRatio,
                height: this._height * this._pixelRatio
            };
        }
        setDrawingBufferSize(width, height, pixelRatio) {
            this._width = width;
            this._height = height;
            this._pixelRatio = pixelRatio;
            this._canvas.width = width * pixelRatio;
            this._canvas.height = height * pixelRatio;
            this.setViewport(0, 0, width, height);
        }
        getCurrentViewport() {
            return this._currentViewport;
        }
        setViewport(x, y, width, height) {
            this._viewport.set(x, this._height - y - height, width, height);
            this.state.viewport(this._currentViewport.copy(this._viewport).multiplyScalar(this._pixelRatio));
        }
        setScissor(x, y, width, height) {
            this._scissor.set(x, this._height - y - height, width, height);
            this.state.scissor(this._currentScissor.copy(this._scissor).multiplyScalar(this._pixelRatio));
        }
        setScissorTest(boolean) {
            this.state.setScissorTest(this._scissorTest = boolean);
        }
        // Clearing
        getClearColor() {
            return this.background.getClearColor();
        }
        setClearColor(color, alpha) {
            // this.background.setClearColor.apply(this.background, arguments);
            this.background.setClearColor(color, alpha);
        }
        getClearAlpha() {
            return this.background.getClearAlpha();
        }
        setClearAlpha() {
            this.background.setClearAlpha(arguments);
        }
        clear(color, depth, stencil) {
            var bits = 0;
            if (color === undefined || color)
                bits |= this._gl.COLOR_BUFFER_BIT;
            if (depth === undefined || depth)
                bits |= this._gl.DEPTH_BUFFER_BIT;
            if (stencil === undefined || stencil)
                bits |= this._gl.STENCIL_BUFFER_BIT;
            this._gl.clear(bits);
        }
        clearColor() {
            this.clear(true, false, false);
        }
        clearDepth() {
            this.clear(false, true, false);
        }
        clearStencil() {
            this.clear(false, false, true);
        }
        clearTarget(renderTarget, color, depth, stencil) {
            this.setRenderTarget(renderTarget);
            this.clear(color, depth, stencil);
        }
        //
        dispose() {
            this._canvas.removeEventListener('webglcontextlost', this.onContextLost, false);
            this._canvas.removeEventListener('webglcontextrestored', this.onContextRestore, false);
            this.renderLists.dispose();
            this.renderStates.dispose();
            this.properties.dispose();
            this.objects.dispose();
            this.vr.dispose();
            this.stopAnimation();
        }
        ;
        // Events
        onContextLost(event) {
            event.preventDefault();
            console.log('THREE.WebGLRenderer: Context Lost.');
            this._isContextLost = true;
        }
        onContextRestore( /* event */) {
            console.log('THREE.WebGLRenderer: Context Restored.');
            this._isContextLost = false;
            this.initGLContext();
        }
        onMaterialDispose(event) {
            var material = event.target;
            material.removeEventListener('dispose', this.onMaterialDispose);
            this.deallocateMaterial(material);
        }
        // Buffer deallocation
        deallocateMaterial(material) {
            this.releaseMaterialProgramReference(material);
            this.properties.remove(material);
        }
        releaseMaterialProgramReference(material) {
            var programInfo = this.properties.get(material).program;
            material.program = undefined;
            if (programInfo !== undefined) {
                this.programCache.releaseProgram(programInfo);
            }
        }
        // Buffer rendering
        renderObjectImmediate(object, program, material) {
            object.render(function (object) {
                this.renderBufferImmediate(object, program, material);
            });
        }
        /**
         * 设置顶点属性值
         * @param material
         * @param program
         * @param geometry
         */
        setupVertexAttributes(material, program, geometry) {
            if (geometry && geometry.isInstancedBufferGeometry) {
                if (this.extensions.get('ANGLE_instanced_arrays') === null) {
                    console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                    return;
                }
            }
            this.state.initAttributes();
            var geometryAttributes = geometry.attributes;
            var programAttributes = program.getAttributes();
            var materialDefaultAttributeValues = material.defaultAttributeValues;
            for (var name in programAttributes) {
                // program 根据名字得到 attribute 的地址
                var programAttribute = programAttributes[name];
                if (programAttribute >= 0) {
                    // buffergeometry的attributes 根据名字得到 geometryAttributes，几何数据信息
                    var geometryAttribute = geometryAttributes[name];
                    if (geometryAttribute !== undefined) {
                        var normalized = geometryAttribute.normalized;
                        var size = geometryAttribute.itemSize;
                        //attribute 存放geometryattribute的 gl buffer信息
                        var attribute = this.attributes.get(geometryAttribute);
                        // TODO Attribute may not be available on context restore
                        if (attribute === undefined)
                            continue;
                        var buffer = attribute.buffer; // buffer 信息
                        var type = attribute.type; // buffer data 数据类型信息
                        var bytesPerElement = attribute.bytesPerElement;
                        if (geometryAttribute.isInterleavedBufferAttribute) {
                            var data = geometryAttribute.data;
                            var stride = data.stride;
                            var offset = geometryAttribute.offset;
                            if (data && data.isInstancedInterleavedBuffer) {
                                this.state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                                if (geometry.maxInstancedCount === undefined) {
                                    geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                                }
                            }
                            else {
                                this.state.enableAttribute(programAttribute);
                            }
                            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffer);
                            this._gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
                        }
                        else {
                            if (geometryAttribute.isInstancedBufferAttribute) {
                                this.state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                                if (geometry.maxInstancedCount === undefined) {
                                    geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                                }
                            }
                            else {
                                this.state.enableAttribute(programAttribute);
                            }
                            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffer);
                            this._gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
                        }
                    }
                    else if (materialDefaultAttributeValues !== undefined) {
                        var value = materialDefaultAttributeValues[name];
                        if (value !== undefined) {
                            switch (value.length) {
                                case 2:
                                    this._gl.vertexAttrib2fv(programAttribute, value);
                                    break;
                                case 3:
                                    this._gl.vertexAttrib3fv(programAttribute, value);
                                    break;
                                case 4:
                                    this._gl.vertexAttrib4fv(programAttribute, value);
                                    break;
                                default:
                                    this._gl.vertexAttrib1fv(programAttribute, value);
                            }
                        }
                    }
                }
            }
            this.state.disableUnusedAttributes();
        }
        /**
         * 开始动画
         */
        startAnimation() {
            if (this.isAnimating)
                return;
            this.requestAnimationLoopFrame();
            this.isAnimating = true;
        }
        /**
         * 结束动画
         */
        stopAnimation() {
            this.isAnimating = false;
        }
        /**
         * 针渲染
         */
        requestAnimationLoopFrame() {
            if (this.vr.isPresenting()) {
                this.vr.requestAnimationFrame(this.animationLoop);
            }
            else {
                window.requestAnimationFrame(this.animationLoop);
            }
        }
        /**
         * 动画循环
         * @param time
         */
        animationLoop(time) {
            if (this.isAnimating === false)
                return;
            this.onAnimationFrame(time);
            this.requestAnimationLoopFrame();
        }
        /**
         * 动画
         * @param callback
         */
        animate(callback) {
            this.onAnimationFrame = callback;
            this.onAnimationFrame !== null ? this.startAnimation() : this.stopAnimation();
        }
        // Rendering
        render(scene, camera, renderTarget, forceClear) {
            if (!(camera && camera.isCamera)) {
                console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
                return;
            }
            if (this._isContextLost)
                return;
            // reset caching for this frame
            this._currentGeometryProgram = '';
            this._currentMaterialId = -1;
            this._currentCamera = null;
            // update scene graph
            if (scene.autoUpdate === true)
                scene.updateMatrixWorld();
            // update camera matrices and frustum
            if (camera.parent === null)
                camera.updateMatrixWorld();
            if (this.vr.enabled) {
                camera = this.vr.getCamera(camera);
            }
            //
            this.currentRenderState = this.renderStates.get(scene, camera);
            this.currentRenderState.init();
            scene.onBeforeRender(this, scene, camera, renderTarget);
            this._projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            this._frustum.setFromMatrix(this._projScreenMatrix);
            this._localClippingEnabled = this.localClippingEnabled;
            this._clippingEnabled = this._clipping.init(this.clippingPlanes, this._localClippingEnabled, camera);
            this.currentRenderList = this.renderLists.get(scene, camera);
            this.currentRenderList.init();
            // 初始化场景
            this.projectObject(scene, camera, this.sortObjects);
            if (this.sortObjects === true) {
                this.currentRenderList.sort();
            }
            //
            if (this._clippingEnabled)
                this._clipping.beginShadows();
            var shadowsArray = this.currentRenderState.state.shadowsArray;
            this.shadowMap.render(shadowsArray, scene, camera);
            this.currentRenderState.setupLights(camera);
            if (this._clippingEnabled)
                this._clipping.endShadows();
            //
            if (this.info.autoReset)
                this.info.reset();
            if (renderTarget === undefined) {
                renderTarget = null;
            }
            this.setRenderTarget(renderTarget);
            //
            this.background.render(this.currentRenderList, scene, camera, forceClear);
            // render scene
            var opaqueObjects = this.currentRenderList.opaque;
            var transparentObjects = this.currentRenderList.transparent;
            if (scene.overrideMaterial) {
                var overrideMaterial = scene.overrideMaterial;
                // 渲染不透明物品
                if (opaqueObjects.length)
                    this.renderObjects(opaqueObjects, scene, camera, overrideMaterial);
                // 渲染透明物品
                if (transparentObjects.length)
                    this.renderObjects(transparentObjects, scene, camera, overrideMaterial);
            }
            else {
                // opaque pass (front-to-back order)
                if (opaqueObjects.length)
                    this.renderObjects(opaqueObjects, scene, camera);
                // transparent pass (back-to-front order)
                if (transparentObjects.length)
                    this.renderObjects(transparentObjects, scene, camera);
            }
            // custom renderers
            var spritesArray = this.currentRenderState.state.spritesArray;
            this.spriteRenderer.render(spritesArray, scene, camera);
            // Generate mipmap if we're using any kind of mipmap filtering
            if (renderTarget) {
                this.textures.updateRenderTargetMipmap(renderTarget);
            }
            // Ensure depth buffer writing is enabled so it can be cleared on next render
            this.state.buffers.depth.setTest(true);
            this.state.buffers.depth.setMask(true);
            this.state.buffers.color.setMask(true);
            this.state.setPolygonOffset(false);
            scene.onAfterRender(this, scene, camera);
            if (this.vr.enabled) {
                this.vr.submitFrame();
            }
            // _gl.finish();
            this.currentRenderList = null;
            this.currentRenderState = null;
        }
        /*
        // TODO Duplicated code (Frustum)
      
        var _sphere = new Sphere();
      
        function isObjectViewable( object ) {
      
           var geometry = object.geometry;
      
           if ( geometry.boundingSphere === null )
              geometry.computeBoundingSphere();
      
           _sphere.copy( geometry.boundingSphere ).
           applyMatrix4( object.matrixWorld );
      
           return isSphereViewable( _sphere );
      
        }
      
        function isSpriteViewable( sprite ) {
      
           _sphere.center.set( 0, 0, 0 );
           _sphere.radius = 0.7071067811865476;
           _sphere.applyMatrix4( sprite.matrixWorld );
      
           return isSphereViewable( _sphere );
      
        }
      
        function isSphereViewable( sphere ) {
      
           if ( ! _frustum.intersectsSphere( sphere ) ) return false;
      
           var numPlanes = _clipping.numPlanes;
      
           if ( numPlanes === 0 ) return true;
      
           var planes = _this.clippingPlanes,
      
              center = sphere.center,
              negRad = - sphere.radius,
              i = 0;
      
           do {
      
              // out when deeper than radius in the negative halfspace
              if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;
      
           } while ( ++ i !== numPlanes );
      
           return true;
      
        }
        */
        /**
         * 向renderlist中存入设置好的program和buffergeometry信息。
         * @param object
         * @param camera
         * @param sortObjects
         */
        projectObject(object, camera, sortObjects) {
            if (object.visible === false)
                return;
            var visible = object.layers.test(camera.layers);
            if (visible) {
                if (object.isLight) {
                    this.currentRenderState.pushLight(object);
                    if (object.castShadow) {
                        this.currentRenderState.pushShadow(object);
                    }
                }
                else if (object.isSprite) {
                    if (!object.frustumCulled || this._frustum.intersectsSprite(object)) {
                        this.currentRenderState.pushSprite(object);
                    }
                }
                else if (object.isImmediateRenderObject) {
                    if (sortObjects) {
                        this._vector3.setFromMatrixPosition(object.matrixWorld)
                            .applyMatrix4(this._projScreenMatrix);
                    }
                    this.currentRenderList.push(object, null, object.material, this._vector3.z, null);
                }
                else if (object.isMesh || object.isLine || object.isPoints) {
                    if (object.isSkinnedMesh) {
                        object.skeleton.update();
                    }
                    if (!object.frustumCulled || this._frustum.intersectsObject(object)) {
                        if (sortObjects) {
                            this._vector3.setFromMatrixPosition(object.matrixWorld)
                                .applyMatrix4(this._projScreenMatrix);
                        }
                        var geometry = this.objects.update(object);
                        var material = object.material;
                        if (Array.isArray(material)) {
                            var groups = geometry.groups;
                            for (var i = 0, l = groups.length; i < l; i++) {
                                var group = groups[i];
                                var groupMaterial = material[group.materialIndex];
                                if (groupMaterial && groupMaterial.visible) {
                                    this.currentRenderList.push(object, geometry, groupMaterial, this._vector3.z, group);
                                }
                            }
                        }
                        else if (material.visible) {
                            this.currentRenderList.push(object, geometry, material, this._vector3.z, null);
                        }
                    }
                }
            }
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                this.projectObject(children[i], camera, sortObjects);
            }
        }
        /**
         * 渲染objects
         * @param renderList
         * @param scene
         * @param camera
         * @param overrideMaterial
         */
        renderObjects(renderList, scene, camera, overrideMaterial) {
            for (var i = 0, l = renderList.length; i < l; i++) {
                var renderItem = renderList[i];
                var object = renderItem.object;
                var geometry = renderItem.geometry;
                var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
                var group = renderItem.group;
                if (camera.isArrayCamera) {
                    this._currentArrayCamera = camera;
                    var cameras = camera.cameras;
                    for (var j = 0, jl = cameras.length; j < jl; j++) {
                        var camera2 = cameras[j];
                        if (object.layers.test(camera2.layers)) {
                            if ('viewport' in camera2) { // XR
                                this.state.viewport(this._currentViewport.copy(camera2.viewport));
                            }
                            else {
                                var bounds = camera2.bounds;
                                var x = bounds.x * this._width;
                                var y = bounds.y * this._height;
                                var width = bounds.z * this._width;
                                var height = bounds.w * this._height;
                                this.state.viewport(this._currentViewport.set(x, y, width, height).multiplyScalar(this._pixelRatio));
                            }
                            this.renderObject(object, scene, camera2, geometry, material, group);
                        }
                    }
                }
                else {
                    this._currentArrayCamera = null;
                    this.renderObject(object, scene, camera, geometry, material, group);
                }
            }
        }
        /**
         * 渲染单个物品
         * @param object
         * @param scene
         * @param camera
         * @param geometry
         * @param material
         * @param group
         */
        renderObject(object, scene, camera, geometry, material, group) {
            object.onBeforeRender(this, scene, camera, geometry, material, group);
            this.currentRenderState = this.renderStates.get(scene, this._currentArrayCamera || camera);
            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
            if (object.isImmediateRenderObject) {
                var frontFaceCW = (object.isMesh && object.matrixWorld.determinant() < 0);
                this.state.setMaterial(material, frontFaceCW);
                // 创建program
                var program = this.setProgram(camera, scene.fog, material, object);
                this._currentGeometryProgram = '';
                this.renderObjectImmediate(object, program, material);
            }
            else {
                this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
            }
            object.onAfterRender(this, scene, camera, geometry, material, group);
            this.currentRenderState = this.renderStates.get(scene, this._currentArrayCamera || camera);
        }
        /**
         * 初始化材料
         * @param material
         * @param fog
         * @param object
         */
        initMaterial(material, fog, object) {
            var glPropertyNode = this.properties.get(material);
            var lights = this.currentRenderState.state.lights;
            var shadowsArray = this.currentRenderState.state.shadowsArray;
            var parameters = this.programCache.getParameters(material, lights.state, shadowsArray, fog, this._clipping.numPlanes, this._clipping.numIntersection, object);
            var code = this.programCache.getProgramCode(material, parameters);
            var program = glPropertyNode.program;
            var programChange = true;
            if (program === undefined) {
                // new material
                material.addEventListener('dispose', this.onMaterialDispose);
            }
            else if (program.code !== code) {
                // changed glsl or parameters
                this.releaseMaterialProgramReference(material);
            }
            else if (glPropertyNode.lightsHash !== lights.state.hash) {
                this.properties.update(material, 'lightsHash', lights.state.hash);
                programChange = false;
            }
            else if (parameters.shaderID !== undefined) {
                // same glsl and uniform list
                return;
            }
            else {
                // only rebuild uniform list
                programChange = false;
            }
            if (programChange) {
                var shaderItem = new THREE.WebGLShaderItem();
                if (parameters.shaderID) {
                    var shader = THREE.ShaderLib[parameters.shaderID];
                    shaderItem.name = material.type;
                    shaderItem.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
                    shaderItem.vertexShader = shader.vertexShader;
                    shaderItem.fragmentShader = shader.fragmentShader;
                    glPropertyNode.shader = shaderItem;
                }
                else {
                    shaderItem.name = material.type;
                    shaderItem.uniforms = material.uniforms;
                    shaderItem.vertexShader = material.vertexShader;
                    shaderItem.fragmentShader = material.fragmentShader;
                    glPropertyNode.shader = shaderItem;
                }
                material.onBeforeCompile(glPropertyNode.shader, this);
                /////////////////////////创建program-shader编译通过/////////////////////////////////////////////////////////////////
                program = this.programCache.acquireProgram(material, glPropertyNode.shader, parameters, code);
                glPropertyNode.program = program;
                material.program = program;
            }
            var programAttributes = program.getAttributes();
            if (material.morphTargets) {
                material.numSupportedMorphTargets = 0;
                for (var i = 0; i < this.maxMorphTargets; i++) {
                    if (programAttributes['morphTarget' + i] >= 0) {
                        material.numSupportedMorphTargets++;
                    }
                }
            }
            if (material.morphNormals) {
                material.numSupportedMorphNormals = 0;
                for (var i = 0; i < this.maxMorphNormals; i++) {
                    if (programAttributes['morphNormal' + i] >= 0) {
                        material.numSupportedMorphNormals++;
                    }
                }
            }
            var uniforms = glPropertyNode.shader.uniforms;
            if (!material.isShaderMaterial &&
                !material.isRawShaderMaterial ||
                material.clipping === true) {
                glPropertyNode.numClippingPlanes = this._clipping.numPlanes;
                glPropertyNode.numIntersection = this._clipping.numIntersection;
                uniforms.clippingPlanes = this._clipping.uniform;
            }
            glPropertyNode.fog = fog;
            // store the light setup it was created for
            glPropertyNode.lightsHash = lights.state.hash;
            if (material.lights) {
                // wire up the material to this renderer's lighting state
                uniforms.ambientLightColor.value = lights.state.ambient;
                uniforms.directionalLights.value = lights.state.directional;
                uniforms.spotLights.value = lights.state.spot;
                uniforms.rectAreaLights.value = lights.state.rectArea;
                uniforms.pointLights.value = lights.state.point;
                uniforms.hemisphereLights.value = lights.state.hemi;
                uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
                uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
                uniforms.spotShadowMap.value = lights.state.spotShadowMap;
                uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
                uniforms.pointShadowMap.value = lights.state.pointShadowMap;
                uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
                // TODO (abelnation): add area lights shadow info to uniforms
            }
            // 获取当前激活的uniform列表
            var progUniforms = glPropertyNode.program.getUniforms();
            // 找出激活uniform和material和light  uniform相同另存一下
            var uniformsList = THREE.WebGLUniformsNode.seqWithValue(progUniforms.seq, uniforms);
            glPropertyNode.uniformsList = uniformsList;
        }
        /**
         * 设置program
         * @param camera
         * @param fog
         * @param material
         * @param object
         */
        setProgram(camera, fog, material, object) {
            this._usedTextureUnits = 0;
            var glPropertyNode = this.properties.get(material);
            var lights = this.currentRenderState.state.lights;
            if (this._clippingEnabled) {
                if (this._localClippingEnabled || camera !== this._currentCamera) {
                    var useCache = camera === this._currentCamera &&
                        material.id === this._currentMaterialId;
                    // we might want to call this function with some ClippingGroup
                    // object instead of the material, once it becomes feasible
                    // (#8465, #8379)
                    this._clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, glPropertyNode, useCache);
                }
            }
            if (material.needsUpdate === false) {
                if (glPropertyNode.program === undefined) {
                    material.needsUpdate = true;
                }
                else if (material.fog && glPropertyNode.fog !== fog) {
                    material.needsUpdate = true;
                }
                else if (material.lights && glPropertyNode.lightsHash !== lights.state.hash) {
                    material.needsUpdate = true;
                }
                else if (glPropertyNode.numClippingPlanes !== undefined &&
                    (glPropertyNode.numClippingPlanes !== this._clipping.numPlanes ||
                        glPropertyNode.numIntersection !== this._clipping.numIntersection)) {
                    material.needsUpdate = true;
                }
            }
            if (material.needsUpdate) {
                // 材料更新uniform值
                this.initMaterial(material, fog, object);
                material.needsUpdate = false;
            }
            var refreshProgram = false;
            var refreshMaterial = false;
            var refreshLights = false;
            var program = glPropertyNode.program, p_uniforms = program.getUniforms(), m_uniforms = glPropertyNode.shader.uniforms;
            if (this.state.useProgram(program.program)) {
                refreshProgram = true;
                refreshMaterial = true;
                refreshLights = true;
            }
            if (material.id !== this._currentMaterialId) {
                this._currentMaterialId = material.id;
                refreshMaterial = true;
            }
            if (refreshProgram || camera !== this._currentCamera) {
                p_uniforms.setValue(this._gl, 'projectionMatrix', camera.projectionMatrix);
                if (this.capabilities.logarithmicDepthBuffer) {
                    p_uniforms.setValue(this._gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
                }
                // Avoid unneeded uniform updates per ArrayCamera's sub-camera
                if (this._currentCamera !== (this._currentArrayCamera || camera)) {
                    this._currentCamera = (this._currentArrayCamera || camera);
                    // lighting uniforms depend on the camera so enforce an update
                    // now, in case this material supports lights - or later, when
                    // the next material that does gets activated:
                    refreshMaterial = true; // set to true on material change
                    refreshLights = true; // remains set until update done
                }
                // load material specific uniforms
                // (shader material also gets them for the sake of genericity)
                if (material.isShaderMaterial ||
                    material.isMeshPhongMaterial ||
                    material.isMeshStandardMaterial ||
                    material.envMap) {
                    var uCamPos = p_uniforms.map.cameraPosition;
                    if (uCamPos !== undefined) {
                        uCamPos.setValue(this._gl, this._vector3.setFromMatrixPosition(camera.matrixWorld));
                    }
                }
                if (material.isMeshPhongMaterial ||
                    material.isMeshLambertMaterial ||
                    material.isMeshBasicMaterial ||
                    material.isMeshStandardMaterial ||
                    material.isShaderMaterial ||
                    material.skinning) {
                    p_uniforms.setValue(this._gl, 'viewMatrix', camera.matrixWorldInverse);
                }
            }
            // skinning uniforms must be set even if material didn't change
            // auto-setting of texture unit for bone texture must go before other textures
            // not sure why, but otherwise weird things happen
            if (material.skinning) {
                p_uniforms.setOptional(this._gl, object, 'bindMatrix');
                p_uniforms.setOptional(this._gl, object, 'bindMatrixInverse');
                var skeleton = object.skeleton;
                if (skeleton) {
                    var bones = skeleton.bones;
                    if (this.capabilities.floatVertexTextures) {
                        if (skeleton.boneTexture === undefined) {
                            // layout (1 matrix = 4 pixels)
                            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
                            var size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix
                            size = THREE._Math.ceilPowerOfTwo(size);
                            size = Math.max(size, 4);
                            var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
                            boneMatrices.set(skeleton.boneMatrices); // copy current values
                            var boneTexture = new THREE.DataTexture(boneMatrices, size, size, THREE.RGBAFormat, THREE.FloatType);
                            boneTexture.needsUpdate = true;
                            skeleton.boneMatrices = boneMatrices;
                            skeleton.boneTexture = boneTexture;
                            skeleton.boneTextureSize = size;
                        }
                        p_uniforms.setValue(this._gl, 'boneTexture', skeleton.boneTexture);
                        p_uniforms.setValue(this._gl, 'boneTextureSize', skeleton.boneTextureSize);
                    }
                    else {
                        p_uniforms.setOptional(this._gl, skeleton, 'boneMatrices');
                    }
                }
            }
            if (refreshMaterial) {
                p_uniforms.setValue(this._gl, 'toneMappingExposure', this.toneMappingExposure);
                p_uniforms.setValue(this._gl, 'toneMappingWhitePoint', this.toneMappingWhitePoint);
                if (material.lights) {
                    // the current material requires lighting info
                    // note: all lighting uniforms are always set correctly
                    // they simply reference the renderer's state for their
                    // values
                    //
                    // use the current material's .needsUpdate flags to set
                    // the GL state when required
                    this.markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
                }
                // refresh uniforms common to several materials
                if (fog && material.fog) {
                    this.refreshUniformsFog(m_uniforms, fog);
                }
                if (material.isMeshBasicMaterial) {
                    this.refreshUniformsCommon(m_uniforms, material);
                }
                else if (material.isMeshLambertMaterial) {
                    this.refreshUniformsCommon(m_uniforms, material);
                    this.refreshUniformsLambert(m_uniforms, material);
                }
                else if (material.isMeshPhongMaterial) {
                    this.refreshUniformsCommon(m_uniforms, material);
                    if (material.isMeshToonMaterial) {
                        this.refreshUniformsToon(m_uniforms, material);
                    }
                    else {
                        this.refreshUniformsPhong(m_uniforms, material);
                    }
                }
                else if (material.isMeshStandardMaterial) {
                    this.refreshUniformsCommon(m_uniforms, material);
                    if (material.isMeshPhysicalMaterial) {
                        this.refreshUniformsPhysical(m_uniforms, material);
                    }
                    else {
                        this.refreshUniformsStandard(m_uniforms, material);
                    }
                }
                else if (material.isMeshDepthMaterial) {
                    this.refreshUniformsCommon(m_uniforms, material);
                    this.refreshUniformsDepth(m_uniforms, material);
                }
                else if (material.isMeshDistanceMaterial) {
                    this.refreshUniformsCommon(m_uniforms, material);
                    this.refreshUniformsDistance(m_uniforms, material);
                }
                else if (material.isMeshNormalMaterial) {
                    this.refreshUniformsCommon(m_uniforms, material);
                    this.refreshUniformsNormal(m_uniforms, material);
                }
                else if (material.isLineBasicMaterial) {
                    this.refreshUniformsLine(m_uniforms, material);
                    if (material.isLineDashedMaterial) {
                        this.refreshUniformsDash(m_uniforms, material);
                    }
                }
                else if (material.isPointsMaterial) {
                    this.refreshUniformsPoints(m_uniforms, material);
                }
                else if (material.isShadowMaterial) {
                    m_uniforms.color.value = material.color;
                    m_uniforms.opacity.value = material.opacity;
                }
                // RectAreaLight Texture
                // TODO (mrdoob): Find a nicer implementation
                if (m_uniforms.ltc_1 !== undefined)
                    m_uniforms.ltc_1.value = THREE.UniformsLib.LTC_1;
                if (m_uniforms.ltc_2 !== undefined)
                    m_uniforms.ltc_2.value = THREE.UniformsLib.LTC_2;
                // 将材料和灯光的uniform的值，赋值给激活的uniform；
                THREE.WebGLUniformsNode.upload(this._gl, glPropertyNode.uniformsList, m_uniforms, this);
            }
            if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
                // 将材料和灯光的uniform的值，赋值给激活的uniform；
                THREE.WebGLUniformsNode.upload(this._gl, glPropertyNode.uniformsList, m_uniforms, this);
                material.uniformsNeedUpdate = false;
            }
            // common matrices
            p_uniforms.setValue(this._gl, 'modelViewMatrix', object.modelViewMatrix);
            p_uniforms.setValue(this._gl, 'normalMatrix', object.normalMatrix);
            p_uniforms.setValue(this._gl, 'modelMatrix', object.matrixWorld);
            return program;
        }
        // Uniforms (refresh uniforms objects)
        /**
         * 更新uniforms参数
         * @param uniforms
         * @param material
         */
        refreshUniformsCommon(uniforms, material) {
            uniforms.opacity.value = material.opacity;
            if (material.color) {
                uniforms.diffuse.value = material.color;
            }
            if (material.emissive) {
                uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
            }
            if (material.map) {
                uniforms.map.value = material.map;
            }
            if (material.alphaMap) {
                uniforms.alphaMap.value = material.alphaMap;
            }
            if (material.specularMap) {
                uniforms.specularMap.value = material.specularMap;
            }
            if (material.envMap) {
                uniforms.envMap.value = material.envMap;
                // don't flip CubeTexture envMaps, flip everything else:
                //  WebGLRenderTargetCube will be flipped for backwards compatibility
                //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
                // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
                uniforms.flipEnvMap.value = (!(material.envMap && material.envMap.isCubeTexture)) ? 1 : -1;
                uniforms.reflectivity.value = material.reflectivity;
                uniforms.refractionRatio.value = material.refractionRatio;
                uniforms.maxMipLevel.value = this.properties.get(material.envMap).__maxMipLevel;
            }
            if (material.lightMap) {
                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
            }
            if (material.aoMap) {
                uniforms.aoMap.value = material.aoMap;
                uniforms.aoMapIntensity.value = material.aoMapIntensity;
            }
            // uv repeat and offset setting priorities
            // 1. color map
            // 2. specular map
            // 3. normal map
            // 4. bump map
            // 5. alpha map
            // 6. emissive map
            var uvScaleMap;
            if (material.map) {
                uvScaleMap = material.map;
            }
            else if (material.specularMap) {
                uvScaleMap = material.specularMap;
            }
            else if (material.displacementMap) {
                uvScaleMap = material.displacementMap;
            }
            else if (material.normalMap) {
                uvScaleMap = material.normalMap;
            }
            else if (material.bumpMap) {
                uvScaleMap = material.bumpMap;
            }
            else if (material.roughnessMap) {
                uvScaleMap = material.roughnessMap;
            }
            else if (material.metalnessMap) {
                uvScaleMap = material.metalnessMap;
            }
            else if (material.alphaMap) {
                uvScaleMap = material.alphaMap;
            }
            else if (material.emissiveMap) {
                uvScaleMap = material.emissiveMap;
            }
            if (uvScaleMap !== undefined) {
                // backwards compatibility
                if (uvScaleMap.isWebGLRenderTarget) {
                    uvScaleMap = uvScaleMap.texture;
                }
                if (uvScaleMap.matrixAutoUpdate === true) {
                    uvScaleMap.updateMatrix();
                }
                uniforms.uvTransform.value.copy(uvScaleMap.matrix);
            }
        }
        /**
         * 更新线的uniform参数
         * @param uniforms
         * @param material
         */
        refreshUniformsLine(uniforms, material) {
            uniforms.diffuse.value = material.color;
            uniforms.opacity.value = material.opacity;
        }
        /**
         * 更新虚线的uniform参数
         * @param uniforms
         * @param material
         */
        refreshUniformsDash(uniforms, material) {
            uniforms.dashSize.value = material.dashSize;
            uniforms.totalSize.value = material.dashSize + material.gapSize;
            uniforms.scale.value = material.scale;
        }
        /**
         * 更新虚线的点云uniform参数
        * @param uniforms
        * @param material
        */
        refreshUniformsPoints(uniforms, material) {
            uniforms.diffuse.value = material.color;
            uniforms.opacity.value = material.opacity;
            uniforms.size.value = material.size * this._pixelRatio;
            uniforms.scale.value = this._height * 0.5;
            uniforms.map.value = material.map;
            if (material.map !== null) {
                if (material.map.matrixAutoUpdate === true) {
                    material.map.updateMatrix();
                }
                uniforms.uvTransform.value.copy(material.map.matrix);
            }
        }
        /**
         * 更新雾uniform参数
        * @param uniforms
        * @param material
        */
        refreshUniformsFog(uniforms, fog) {
            uniforms.fogColor.value = fog.color;
            if (fog.isFog) {
                uniforms.fogNear.value = fog.near;
                uniforms.fogFar.value = fog.far;
            }
            else if (fog.isFogExp2) {
                uniforms.fogDensity.value = fog.density;
            }
        }
        /**
         * 更新Lambert材料uniform参数
        * @param uniforms
        * @param material
        */
        refreshUniformsLambert(uniforms, material) {
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
        }
        /**
         * 更新Phong材料uniform参数
           * @param uniforms
           * @param material
           */
        refreshUniformsPhong(uniforms, material) {
            uniforms.specular.value = material.specular;
            uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === THREE.BackSide)
                    uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === THREE.BackSide)
                    uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        /**
         * 更新Toon材料uniform参数
         * @param uniforms
         * @param material
         */
        refreshUniformsToon(uniforms, material) {
            this.refreshUniformsPhong(uniforms, material);
            if (material.gradientMap) {
                uniforms.gradientMap.value = material.gradientMap;
            }
        }
        /**
         * 更新Standard材料uniform参数
        * @param uniforms
        * @param material
        */
        refreshUniformsStandard(uniforms, material) {
            uniforms.roughness.value = material.roughness;
            uniforms.metalness.value = material.metalness;
            if (material.roughnessMap) {
                uniforms.roughnessMap.value = material.roughnessMap;
            }
            if (material.metalnessMap) {
                uniforms.metalnessMap.value = material.metalnessMap;
            }
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === THREE.BackSide)
                    uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === THREE.BackSide)
                    uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
            if (material.envMap) {
                //uniforms.envMap.value = material.envMap; // part of uniforms common
                uniforms.envMapIntensity.value = material.envMapIntensity;
            }
        }
        /**
         * 更新Physical材料uniform参数
        * @param uniforms
        * @param material
        */
        refreshUniformsPhysical(uniforms, material) {
            uniforms.clearCoat.value = material.clearCoat;
            uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
            this.refreshUniformsStandard(uniforms, material);
        }
        /**
         * 更新Depth材料uniform参数
        * @param uniforms
        * @param material
        */
        refreshUniformsDepth(uniforms, material) {
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        /**
         * 更新Distance材料uniform参数
           * @param uniforms
           * @param material
           */
        refreshUniformsDistance(uniforms, material) {
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
            uniforms.referencePosition.value.copy(material.referencePosition);
            uniforms.nearDistance.value = material.nearDistance;
            uniforms.farDistance.value = material.farDistance;
        }
        /**
         * 更新Normal材料uniform参数
        * @param uniforms
        * @param material
        */
        refreshUniformsNormal(uniforms, material) {
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === THREE.BackSide)
                    uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === THREE.BackSide)
                    uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        // If uniforms are marked as clean, they don't need to be loaded to the GPU.
        /**
         * 灯光更新
         * @param uniforms
         * @param value
         */
        markUniformsLightsNeedsUpdate(uniforms, value) {
            uniforms.ambientLightColor.needsUpdate = value;
            uniforms.directionalLights.needsUpdate = value;
            uniforms.pointLights.needsUpdate = value;
            uniforms.spotLights.needsUpdate = value;
            uniforms.rectAreaLights.needsUpdate = value;
            uniforms.hemisphereLights.needsUpdate = value;
        }
        // Textures
        /**
         * 分配材质单元
         */
        allocTextureUnit() {
            var textureUnit = this._usedTextureUnits;
            if (textureUnit >= this.capabilities.maxTextures) {
                console.warn('THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + this.capabilities.maxTextures);
            }
            this._usedTextureUnits += 1;
            return textureUnit;
        }
        // backwards compatibility: peel texture.texture
        /**
         * 设置材质
         * @param texture
         * @param slot
         */
        setTexture2D(texture, slot) {
            if (texture && texture.isWebGLRenderTarget) {
                if (!this.warned_setTexture2D) {
                    console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
                    this.warned_setTexture2D = true;
                }
                texture = texture.texture;
            }
            this.textures.setTexture2D(texture, slot);
        }
        /**
      * 设置材质
      * @param texture
      * @param slot
      */
        setTexture(texture, slot) {
            if (!this.warned_setTexture) {
                console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
                this.warned_setTexture = true;
            }
            this.textures.setTexture2D(texture, slot);
        }
        /**
         * 设置cube材质
        * @param texture
        * @param slot
        */
        setTextureCube(texture, slot) {
            // backwards compatibility: peel texture.texture
            if (texture && texture.isWebGLRenderTargetCube) {
                if (!this.warned_setTextureCube) {
                    console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                    this.warned_setTextureCube = true;
                }
                texture = texture.texture;
            }
            // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
            // TODO: unify these code paths
            if ((texture && texture.isCubeTexture) ||
                (Array.isArray(texture.image) && texture.image.length === 6)) {
                // CompressedTexture can have Array in image :/
                // this function alone should take care of cube textures
                this.textures.setTextureCube(texture, slot);
            }
            else {
                // assumed: texture property of THREE.WebGLRenderTargetCube
                this.textures.setTextureCubeDynamic(texture, slot);
            }
        }
        getRenderTarget() {
            return this._currentRenderTarget;
        }
        ;
        /**
         *
         * @param renderTarget
         */
        setRenderTarget(renderTarget) {
            this._currentRenderTarget = renderTarget;
            if (renderTarget && this.properties.get(renderTarget).__webglFramebuffer === undefined) {
                this.textures.setupRenderTarget(renderTarget);
            }
            var framebuffer = null;
            var isCube = false;
            if (renderTarget) {
                var __webglFramebuffer = this.properties.get(renderTarget).__webglFramebuffer;
                if (renderTarget.isWebGLRenderTargetCube) {
                    framebuffer = __webglFramebuffer[renderTarget.activeCubeFace];
                    isCube = true;
                }
                else {
                    framebuffer = __webglFramebuffer;
                }
                this._currentViewport.copy(renderTarget.viewport);
                this._currentScissor.copy(renderTarget.scissor);
                this._currentScissorTest = renderTarget.scissorTest;
            }
            else {
                this._currentViewport.copy(this._viewport).multiplyScalar(this._pixelRatio);
                this._currentScissor.copy(this._scissor).multiplyScalar(this._pixelRatio);
                this._currentScissorTest = this._scissorTest;
            }
            if (this._currentFramebuffer !== framebuffer) {
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);
                this._currentFramebuffer = framebuffer;
            }
            this.state.viewport(this._currentViewport);
            this.state.scissor(this._currentScissor);
            this.state.setScissorTest(this._currentScissorTest);
            if (isCube) {
                var textureProperties = this.properties.get(renderTarget.texture);
                this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
            }
        }
        readRenderTargetPixels(renderTarget, x, y, width, height, buffer) {
            if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
                console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
                return;
            }
            var framebuffer = this.properties.get(renderTarget).__webglFramebuffer;
            if (framebuffer) {
                var restore = false;
                if (framebuffer !== this._currentFramebuffer) {
                    this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);
                    restore = true;
                }
                try {
                    var texture = renderTarget.texture;
                    var textureFormat = texture.format;
                    var textureType = texture.type;
                    if (textureFormat !== THREE.RGBAFormat && this.utils.convert(textureFormat) !== this._gl.getParameter(this._gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                        return;
                    }
                    if (textureType !== THREE.UnsignedByteType && this.utils.convert(textureType) !== this._gl.getParameter(this._gl.IMPLEMENTATION_COLOR_READ_TYPE) && // IE11, Edge and Chrome Mac < 52 (#9513)
                        !(textureType === THREE.FloatType && (this.extensions.get('OES_texture_float') || this.extensions.get('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
                        !(textureType === THREE.HalfFloatType && this.extensions.get('EXT_color_buffer_half_float'))) {
                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                        return;
                    }
                    if (this._gl.checkFramebufferStatus(this._gl.FRAMEBUFFER) === this._gl.FRAMEBUFFER_COMPLETE) {
                        // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
                        if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {
                            this._gl.readPixels(x, y, width, height, this.utils.convert(textureFormat), this.utils.convert(textureType), buffer);
                        }
                    }
                    else {
                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
                    }
                }
                finally {
                    if (restore) {
                        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._currentFramebuffer);
                    }
                }
            }
        }
        copyFramebufferToTexture(position, texture, level) {
            var width = texture.image.width;
            var height = texture.image.height;
            var glFormat = this.utils.convert(texture.format);
            this.setTexture2D(texture, 0);
            this._gl.copyTexImage2D(this._gl.TEXTURE_2D, level || 0, glFormat, position.x, position.y, width, height, 0);
        }
        ;
    }
    THREE.WebGLRenderer = WebGLRenderer;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
    var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";
    var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
    var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";
    var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
    var begin_vertex = "\nvec3 transformed = vec3( position );\n";
    var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
    var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
    var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";
    var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n";
    var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
    var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";
    var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";
    var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
    var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";
    var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
    var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
    var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n";
    var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";
    var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";
    var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";
    var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
    var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
    var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";
    var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
    var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";
    var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";
    var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";
    var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";
    var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";
    var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";
    var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";
    var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
    var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";
    var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";
    var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
    var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
    var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";
    var lights_pars_begin = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n";
    var lights_pars_maps = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";
    var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
    var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";
    var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
    var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
    var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n";
    var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n";
    var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";
    var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
    var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";
    var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";
    var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n";
    var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";
    var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";
    var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
    var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n";
    var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";
    var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
    var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
    var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
    var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";
    var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n";
    var normal_fragment_maps = "#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
    var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy *= normalScale;\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";
    var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
    var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
    var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";
    var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";
    var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";
    var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";
    var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
    var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";
    var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";
    var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";
    var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";
    var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
    var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";
    var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";
    var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
    var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
    var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
    var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
    var tonemapping_pars_fragment = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
    var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
    var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n";
    var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
    var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
    var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";
    var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";
    var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";
    var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";
    var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n";
    var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";
    var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
    var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n";
    var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n";
    var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";
    var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";
    var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
    var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
    var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
    var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
    var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
    var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";
    var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";
    var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
    var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n";
    var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    THREE.ShaderChunk = {
        alphamap_fragment: alphamap_fragment,
        alphamap_pars_fragment: alphamap_pars_fragment,
        alphatest_fragment: alphatest_fragment,
        aomap_fragment: aomap_fragment,
        aomap_pars_fragment: aomap_pars_fragment,
        begin_vertex: begin_vertex,
        beginnormal_vertex: beginnormal_vertex,
        bsdfs: bsdfs,
        bumpmap_pars_fragment: bumpmap_pars_fragment,
        clipping_planes_fragment: clipping_planes_fragment,
        clipping_planes_pars_fragment: clipping_planes_pars_fragment,
        clipping_planes_pars_vertex: clipping_planes_pars_vertex,
        clipping_planes_vertex: clipping_planes_vertex,
        color_fragment: color_fragment,
        color_pars_fragment: color_pars_fragment,
        color_pars_vertex: color_pars_vertex,
        color_vertex: color_vertex,
        common: common,
        cube_uv_reflection_fragment: cube_uv_reflection_fragment,
        defaultnormal_vertex: defaultnormal_vertex,
        displacementmap_pars_vertex: displacementmap_pars_vertex,
        displacementmap_vertex: displacementmap_vertex,
        emissivemap_fragment: emissivemap_fragment,
        emissivemap_pars_fragment: emissivemap_pars_fragment,
        encodings_fragment: encodings_fragment,
        encodings_pars_fragment: encodings_pars_fragment,
        envmap_fragment: envmap_fragment,
        envmap_pars_fragment: envmap_pars_fragment,
        envmap_pars_vertex: envmap_pars_vertex,
        envmap_vertex: envmap_vertex,
        fog_vertex: fog_vertex,
        fog_pars_vertex: fog_pars_vertex,
        fog_fragment: fog_fragment,
        fog_pars_fragment: fog_pars_fragment,
        gradientmap_pars_fragment: gradientmap_pars_fragment,
        lightmap_fragment: lightmap_fragment,
        lightmap_pars_fragment: lightmap_pars_fragment,
        lights_lambert_vertex: lights_lambert_vertex,
        lights_pars_begin: lights_pars_begin,
        lights_pars_maps: lights_pars_maps,
        lights_phong_fragment: lights_phong_fragment,
        lights_phong_pars_fragment: lights_phong_pars_fragment,
        lights_physical_fragment: lights_physical_fragment,
        lights_physical_pars_fragment: lights_physical_pars_fragment,
        lights_fragment_begin: lights_fragment_begin,
        lights_fragment_maps: lights_fragment_maps,
        lights_fragment_end: lights_fragment_end,
        logdepthbuf_fragment: logdepthbuf_fragment,
        logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
        logdepthbuf_vertex: logdepthbuf_vertex,
        map_fragment: map_fragment,
        map_pars_fragment: map_pars_fragment,
        map_particle_fragment: map_particle_fragment,
        map_particle_pars_fragment: map_particle_pars_fragment,
        metalnessmap_fragment: metalnessmap_fragment,
        metalnessmap_pars_fragment: metalnessmap_pars_fragment,
        morphnormal_vertex: morphnormal_vertex,
        morphtarget_pars_vertex: morphtarget_pars_vertex,
        morphtarget_vertex: morphtarget_vertex,
        normal_fragment_begin: normal_fragment_begin,
        normal_fragment_maps: normal_fragment_maps,
        normalmap_pars_fragment: normalmap_pars_fragment,
        packing: packing,
        premultiplied_alpha_fragment: premultiplied_alpha_fragment,
        project_vertex: project_vertex,
        dithering_fragment: dithering_fragment,
        dithering_pars_fragment: dithering_pars_fragment,
        roughnessmap_fragment: roughnessmap_fragment,
        roughnessmap_pars_fragment: roughnessmap_pars_fragment,
        shadowmap_pars_fragment: shadowmap_pars_fragment,
        shadowmap_pars_vertex: shadowmap_pars_vertex,
        shadowmap_vertex: shadowmap_vertex,
        shadowmask_pars_fragment: shadowmask_pars_fragment,
        skinbase_vertex: skinbase_vertex,
        skinning_pars_vertex: skinning_pars_vertex,
        skinning_vertex: skinning_vertex,
        skinnormal_vertex: skinnormal_vertex,
        specularmap_fragment: specularmap_fragment,
        specularmap_pars_fragment: specularmap_pars_fragment,
        tonemapping_fragment: tonemapping_fragment,
        tonemapping_pars_fragment: tonemapping_pars_fragment,
        uv_pars_fragment: uv_pars_fragment,
        uv_pars_vertex: uv_pars_vertex,
        uv_vertex: uv_vertex,
        uv2_pars_fragment: uv2_pars_fragment,
        uv2_pars_vertex: uv2_pars_vertex,
        uv2_vertex: uv2_vertex,
        worldpos_vertex: worldpos_vertex,
        cube_frag: cube_frag,
        cube_vert: cube_vert,
        depth_frag: depth_frag,
        depth_vert: depth_vert,
        distanceRGBA_frag: distanceRGBA_frag,
        distanceRGBA_vert: distanceRGBA_vert,
        equirect_frag: equirect_frag,
        equirect_vert: equirect_vert,
        linedashed_frag: linedashed_frag,
        linedashed_vert: linedashed_vert,
        meshbasic_frag: meshbasic_frag,
        meshbasic_vert: meshbasic_vert,
        meshlambert_frag: meshlambert_frag,
        meshlambert_vert: meshlambert_vert,
        meshphong_frag: meshphong_frag,
        meshphong_vert: meshphong_vert,
        meshphysical_frag: meshphysical_frag,
        meshphysical_vert: meshphysical_vert,
        normal_frag: normal_frag,
        normal_vert: normal_vert,
        points_frag: points_frag,
        points_vert: points_vert,
        shadow_frag: shadow_frag,
        shadow_vert: shadow_vert
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    THREE.UniformsUtils = {
        merge: function (uniforms) {
            var merged = {};
            for (var u = 0; u < uniforms.length; u++) {
                var tmp = this.clone(uniforms[u]);
                for (var p in tmp) {
                    merged[p] = tmp[p];
                }
            }
            return merged;
        },
        clone: function (uniforms_src) {
            var uniforms_dst = {};
            for (var u in uniforms_src) {
                uniforms_dst[u] = {};
                for (var p in uniforms_src[u]) {
                    var parameter_src = uniforms_src[u][p];
                    if (parameter_src && (parameter_src.isColor ||
                        parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
                        parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
                        parameter_src.isTexture)) {
                        uniforms_dst[u][p] = parameter_src.clone();
                    }
                    else if (Array.isArray(parameter_src)) {
                        uniforms_dst[u][p] = parameter_src.slice();
                    }
                    else {
                        uniforms_dst[u][p] = parameter_src;
                    }
                }
            }
            return uniforms_dst;
        }
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    THREE.UniformsLib = {
        common: {
            diffuse: { value: new THREE.Color(0xeeeeee) },
            opacity: { value: 1.0 },
            map: { value: null },
            uvTransform: { value: new THREE.Matrix3() },
            alphaMap: { value: null },
        },
        specularmap: {
            specularMap: { value: null },
        },
        envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1.0 },
            refractionRatio: { value: 0.98 },
            maxMipLevel: { value: 0 }
        },
        aomap: {
            aoMap: { value: null },
            aoMapIntensity: { value: 1 }
        },
        lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 }
        },
        emissivemap: {
            emissiveMap: { value: null }
        },
        bumpmap: {
            bumpMap: { value: null },
            bumpScale: { value: 1 }
        },
        normalmap: {
            normalMap: { value: null },
            normalScale: { value: new THREE.Vector2(1, 1) }
        },
        displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 }
        },
        roughnessmap: {
            roughnessMap: { value: null }
        },
        metalnessmap: {
            metalnessMap: { value: null }
        },
        gradientmap: {
            gradientMap: { value: null }
        },
        fog: {
            fogDensity: { value: 0.00025 },
            fogNear: { value: 1 },
            fogFar: { value: 2000 },
            fogColor: { value: new THREE.Color(0xffffff) }
        },
        lights: {
            ambientLightColor: { value: [] },
            directionalLights: {
                value: [], properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
                value: [], properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
                value: [], properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
                value: [], properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
            rectAreaLights: {
                value: [], properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: { value: new THREE.Color(0xeeeeee) },
            opacity: { value: 1.0 },
            size: { value: 1.0 },
            scale: { value: 1.0 },
            map: { value: null },
            uvTransform: { value: new THREE.Matrix3() }
        }
    };
})(THREE || (THREE = {}));
///<reference path="./UniformsUtils"/>
///<reference path="./UniformsLib"/>
///<reference path="./ShaderChunk"/>
var THREE;
///<reference path="./UniformsUtils"/>
///<reference path="./UniformsLib"/>
///<reference path="./ShaderChunk"/>
(function (THREE) {
    THREE.ShaderLib = {
        basic: {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib.common,
                THREE.UniformsLib.specularmap,
                THREE.UniformsLib.envmap,
                THREE.UniformsLib.aomap,
                THREE.UniformsLib.lightmap,
                THREE.UniformsLib.fog
            ]),
            vertexShader: THREE.ShaderChunk.meshbasic_vert,
            fragmentShader: THREE.ShaderChunk.meshbasic_frag
        },
        lambert: {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib.common,
                THREE.UniformsLib.specularmap,
                THREE.UniformsLib.envmap,
                THREE.UniformsLib.aomap,
                THREE.UniformsLib.lightmap,
                THREE.UniformsLib.emissivemap,
                THREE.UniformsLib.fog,
                THREE.UniformsLib.lights,
                {
                    emissive: { value: new THREE.Color(0x000000) }
                }
            ]),
            vertexShader: THREE.ShaderChunk.meshlambert_vert,
            fragmentShader: THREE.ShaderChunk.meshlambert_frag
        },
        phong: {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib.common,
                THREE.UniformsLib.specularmap,
                THREE.UniformsLib.envmap,
                THREE.UniformsLib.aomap,
                THREE.UniformsLib.lightmap,
                THREE.UniformsLib.emissivemap,
                THREE.UniformsLib.bumpmap,
                THREE.UniformsLib.normalmap,
                THREE.UniformsLib.displacementmap,
                THREE.UniformsLib.gradientmap,
                THREE.UniformsLib.fog,
                THREE.UniformsLib.lights,
                {
                    emissive: { value: new THREE.Color(0x000000) },
                    specular: { value: new THREE.Color(0x111111) },
                    shininess: { value: 30 }
                }
            ]),
            vertexShader: THREE.ShaderChunk.meshphong_vert,
            fragmentShader: THREE.ShaderChunk.meshphong_frag
        },
        standard: {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib.common,
                THREE.UniformsLib.envmap,
                THREE.UniformsLib.aomap,
                THREE.UniformsLib.lightmap,
                THREE.UniformsLib.emissivemap,
                THREE.UniformsLib.bumpmap,
                THREE.UniformsLib.normalmap,
                THREE.UniformsLib.displacementmap,
                THREE.UniformsLib.roughnessmap,
                THREE.UniformsLib.metalnessmap,
                THREE.UniformsLib.fog,
                THREE.UniformsLib.lights,
                {
                    emissive: { value: new THREE.Color(0x000000) },
                    roughness: { value: 0.5 },
                    metalness: { value: 0.5 },
                    envMapIntensity: { value: 1 } // temporary
                }
            ]),
            vertexShader: THREE.ShaderChunk.meshphysical_vert,
            fragmentShader: THREE.ShaderChunk.meshphysical_frag
        },
        points: {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib.points,
                THREE.UniformsLib.fog
            ]),
            vertexShader: THREE.ShaderChunk.points_vert,
            fragmentShader: THREE.ShaderChunk.points_frag
        },
        dashed: {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib.common,
                THREE.UniformsLib.fog,
                {
                    scale: { value: 1 },
                    dashSize: { value: 1 },
                    totalSize: { value: 2 }
                }
            ]),
            vertexShader: THREE.ShaderChunk.linedashed_vert,
            fragmentShader: THREE.ShaderChunk.linedashed_frag
        },
        depth: {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib.common,
                THREE.UniformsLib.displacementmap
            ]),
            vertexShader: THREE.ShaderChunk.depth_vert,
            fragmentShader: THREE.ShaderChunk.depth_frag
        },
        normal: {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib.common,
                THREE.UniformsLib.bumpmap,
                THREE.UniformsLib.normalmap,
                THREE.UniformsLib.displacementmap,
                {
                    opacity: { value: 1.0 }
                }
            ]),
            vertexShader: THREE.ShaderChunk.normal_vert,
            fragmentShader: THREE.ShaderChunk.normal_frag
        },
        /* -------------------------------------------------------------------------
        //	Cube map shader
         ------------------------------------------------------------------------- */
        cube: {
            uniforms: {
                tCube: { value: null },
                tFlip: { value: -1 },
                opacity: { value: 1.0 }
            },
            vertexShader: THREE.ShaderChunk.cube_vert,
            fragmentShader: THREE.ShaderChunk.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: { value: null },
            },
            vertexShader: THREE.ShaderChunk.equirect_vert,
            fragmentShader: THREE.ShaderChunk.equirect_frag
        },
        distanceRGBA: {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib.common,
                THREE.UniformsLib.displacementmap,
                {
                    referencePosition: { value: new THREE.Vector3() },
                    nearDistance: { value: 1 },
                    farDistance: { value: 1000 }
                }
            ]),
            vertexShader: THREE.ShaderChunk.distanceRGBA_vert,
            fragmentShader: THREE.ShaderChunk.distanceRGBA_frag
        },
        shadow: {
            uniforms: THREE.UniformsUtils.merge([
                THREE.UniformsLib.lights,
                THREE.UniformsLib.fog,
                {
                    color: { value: new THREE.Color(0x00000) },
                    opacity: { value: 1.0 }
                },
            ]),
            vertexShader: THREE.ShaderChunk.shadow_vert,
            fragmentShader: THREE.ShaderChunk.shadow_frag
        }
    };
    THREE.ShaderLib.physical = {
        uniforms: THREE.UniformsUtils.merge([
            THREE.ShaderLib.standard.uniforms,
            {
                clearCoat: { value: 0 },
                clearCoatRoughness: { value: 0 }
            }
        ]),
        vertexShader: THREE.ShaderChunk.meshphysical_vert,
        fragmentShader: THREE.ShaderChunk.meshphysical_frag
    };
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class GLBufferNode {
        constructor() {
        }
    }
    THREE.GLBufferNode = GLBufferNode;
    class WebGLAttributesNode {
        constructor(gl) {
            var buffers = new WeakMap();
            this.gl = gl;
            this.buffers = buffers;
        }
        /**
         *
         * @param attribute
         * @param bufferType  gl.ARRAY_BUFFER
         */
        createBuffer(attribute, bufferType) {
            var gl = this.gl;
            var array = attribute.array;
            var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
            var buffer = gl.createBuffer();
            gl.bindBuffer(bufferType, buffer);
            gl.bufferData(bufferType, array, usage);
            attribute.onUploadCallback();
            var type = gl.FLOAT;
            if (array instanceof Float32Array) {
                type = gl.FLOAT;
            }
            else if (array instanceof Float64Array) {
                console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
            }
            else if (array instanceof Uint16Array) {
                type = gl.UNSIGNED_SHORT;
            }
            else if (array instanceof Int16Array) {
                type = gl.SHORT;
            }
            else if (array instanceof Uint32Array) {
                type = gl.UNSIGNED_INT;
            }
            else if (array instanceof Int32Array) {
                type = gl.INT;
            }
            else if (array instanceof Int8Array) {
                type = gl.BYTE;
            }
            else if (array instanceof Uint8Array) {
                type = gl.UNSIGNED_BYTE;
            }
            var buffernode = new GLBufferNode();
            buffernode = {
                buffer: buffer,
                type: type,
                bytesPerElement: array.BYTES_PER_ELEMENT,
                version: attribute.version
            };
            return buffernode;
        }
        /**
         * 更新buffer
         * @param buffer
         * @param attribute
         * @param bufferType
         */
        updateBuffer(buffer, attribute, bufferType) {
            var gl = this.gl;
            var array = attribute.array;
            var updateRange = attribute.updateRange;
            gl.bindBuffer(bufferType, buffer);
            if (attribute.dynamic === false) {
                gl.bufferData(bufferType, array, gl.STATIC_DRAW);
            }
            else if (updateRange.count === -1) {
                // Not using update ranges
                gl.bufferSubData(bufferType, 0, array);
            }
            else if (updateRange.count === 0) {
                console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
            }
            else {
                gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
                updateRange.count = -1; // reset range
            }
        }
        //
        /**
         * 获取glbufferNode
         * @param attribute
         */
        get(attribute) {
            var buffers = this.buffers;
            if (attribute.isInterleavedBufferAttribute)
                attribute = attribute.data;
            return buffers.get(attribute);
        }
        /**
         * 删除bufferNode
         * @param attribute
         */
        remove(attribute) {
            var buffers = this.buffers;
            var gl = this.gl;
            if (attribute.isInterleavedBufferAttribute)
                attribute = attribute.data;
            var data = buffers.get(attribute);
            if (data) {
                gl.deleteBuffer(data.buffer);
                buffers.delete(attribute);
            }
        }
        /**
         * 更新glbuffer 的 内存 ，根据版本更新buffer
         * @param attribute
         * @param bufferType
         */
        update(attribute, bufferType) {
            var buffers = this.buffers;
            var gl = this.gl;
            if (attribute.isInterleavedBufferAttribute)
                attribute = attribute.data;
            var data = buffers.get(attribute);
            if (data === undefined) {
                var newbuffer = this.createBuffer(attribute, bufferType);
                buffers.set(attribute, newbuffer);
            }
            else if (data.version < attribute.version) {
                this.updateBuffer(data.buffer, attribute, bufferType);
                data.version = attribute.version;
            }
        }
    }
    THREE.WebGLAttributesNode = WebGLAttributesNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLBackgroundNode {
        constructor(renderer, state, objects, premultipliedAlpha) {
            this.clearColor = new THREE.Color(0x000000);
            this.clearAlpha = 0;
            this.planeCamera = null;
            this.planeMesh = null;
            this.boxMesh = null;
            this.renderer = renderer;
            this.state = state;
            this.objects = objects;
            this.premultipliedAlpha = premultipliedAlpha;
        }
        getClearColor() {
            return this.clearColor;
        }
        setClearColor(color, alpha) {
            this.clearColor.set(color);
            this.clearAlpha = alpha !== undefined ? alpha : 1;
            this.setClear(this.clearColor, this.clearAlpha);
        }
        getClearAlpha() {
            return this.clearAlpha;
        }
        setClearAlpha(alpha) {
            this.clearAlpha = alpha;
            this.setClear(this.clearColor, this.clearAlpha);
        }
        render(renderList, scene, camera, forceClear) {
            var background = scene.background;
            if (background === null) {
                this.setClear(this.clearColor, this.clearAlpha);
            }
            else if (background && background.isColor) {
                this.setClear(background, 1);
                forceClear = true;
            }
            if (this.renderer.autoClear || forceClear) {
                this.renderer.clear(this.renderer.autoClearColor, this.renderer.autoClearDepth, this.renderer.autoClearStencil);
            }
            if (background && background.isCubeTexture) {
                if (this.boxMesh === undefined) {
                    this.boxMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 1, 1, null, null, null), new THREE.ShaderMaterial({
                        uniforms: THREE.ShaderLib.cube.uniforms,
                        vertexShader: THREE.ShaderLib.cube.vertexShader,
                        fragmentShader: THREE.ShaderLib.cube.fragmentShader,
                        side: THREE.BackSide,
                        depthTest: true,
                        depthWrite: false,
                        fog: false
                    }));
                    this.boxMesh.geometry.removeAttribute('normal');
                    this.boxMesh.geometry.removeAttribute('uv');
                    this.boxMesh.onBeforeRender = function (renderer, scene, camera) {
                        this.matrixWorld.copyPosition(camera.matrixWorld);
                    };
                    this.objects.update(this.boxMesh);
                }
                this.boxMesh.material.uniforms.tCube.value = background;
                renderList.push(this.boxMesh, this.boxMesh.geometry, this.boxMesh.material, 0, null);
            }
            else if (background && background.isTexture) {
                if (this.planeCamera === undefined) {
                    this.planeCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                    this.planeMesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2, null, null), new THREE.MeshBasicMaterial({ depthTest: false, depthWrite: false, fog: false }));
                    this.objects.update(this.planeMesh);
                }
                this.planeMesh.material.map = background;
                // TODO Push this to renderList
                this.renderer.renderBufferDirect(this.planeCamera, null, this.planeMesh.geometry, this.planeMesh.material, this.planeMesh, null);
            }
        }
        setClear(color, alpha) {
            this.state.buffers.color.setClear(color.r, color.g, color.b, alpha, this.premultipliedAlpha);
        }
    }
    THREE.WebGLBackgroundNode = WebGLBackgroundNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLBufferRendererNode {
        constructor(gl, extensions, info) {
            this.gl = gl;
            this.extensions = extensions;
            this.info = info;
            this.mode = null;
        }
        /**
         * 设置渲染模式
         * @param value
         */
        setMode(value) {
            this.mode = value;
        }
        /**
         * 渲染，并记录渲染过程信息
         */
        render(start, count) {
            this.gl.drawArrays(this.mode, start, count);
            this.info.update(count, this.mode, null);
        }
        /**
         * 即使渲染
         */
        renderInstances(geometry, start, count) {
            var extension = this.extensions.get('ANGLE_instanced_arrays');
            if (extension === null) {
                console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
            extension.drawArraysInstancedANGLE(this.mode, start, count, geometry.maxInstancedCount);
            this.info.update(count, this.mode, geometry.maxInstancedCount);
        }
    }
    THREE.WebGLBufferRendererNode = WebGLBufferRendererNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLCapabilitiesNode {
        constructor(gl, extensions, parameters) {
            this.maxAnisotropy = null;
            this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
            this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            this.maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
            this.maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            this.maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            this.maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
            this.maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
            this.vertexTextures = this.maxVertexTextures > 0;
            this.floatFragmentTextures = !!extensions.get('OES_texture_float');
            this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
            this.precision = 'highp';
            this.gl = gl;
        }
        getMaxAnisotropy() {
            if (this.maxAnisotropy !== undefined)
                return this.maxAnisotropy;
            var extension = this.extensions.get('EXT_texture_filter_anisotropic');
            if (extension !== null) {
                this.maxAnisotropy = this.gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            }
            else {
                this.maxAnisotropy = 0;
            }
            return this.maxAnisotropy;
        }
        getMaxPrecision(precision) {
            this.precision = precision;
            if (precision === 'highp') {
                if (this.gl.getShaderPrecisionFormat(this.gl.VERTEX_SHADER, this.gl.HIGH_FLOAT).precision > 0 &&
                    this.gl.getShaderPrecisionFormat(this.gl.FRAGMENT_SHADER, this.gl.HIGH_FLOAT).precision > 0) {
                    return 'highp';
                }
                precision = 'mediump';
            }
            if (precision === 'mediump') {
                if (this.gl.getShaderPrecisionFormat(this.gl.VERTEX_SHADER, this.gl.MEDIUM_FLOAT).precision > 0 &&
                    this.gl.getShaderPrecisionFormat(this.gl.FRAGMENT_SHADER, this.gl.MEDIUM_FLOAT).precision > 0) {
                    return 'mediump';
                }
            }
            return 'lowp';
        }
    }
    THREE.WebGLCapabilitiesNode = WebGLCapabilitiesNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLClippingNode {
        constructor() {
            this.globalState = null,
                this.numGlobalPlanes = 0,
                this.localClippingEnabled = false,
                this.renderingShadows = false,
                this.plane = new THREE.Plane(),
                this.viewNormalMatrix = new THREE.Matrix3(),
                this.uniform = { value: null, needsUpdate: false };
            this.uniform = null;
            this.numPlanes = 0;
        }
        init(planes, enableLocalClipping, camera) {
            var enabled = planes.length !== 0 ||
                enableLocalClipping ||
                // enable state of previous frame - the clipping code has to
                // run another frame in order to reset the state:
                this.numGlobalPlanes !== 0 ||
                this.localClippingEnabled;
            this.localClippingEnabled = enableLocalClipping;
            this.globalState = this.projectPlanes(planes, camera, 0);
            this.numGlobalPlanes = planes.length;
            return enabled;
        }
        ;
        beginShadows() {
            this.renderingShadows = true;
            this.projectPlanes(null);
        }
        ;
        endShadows() {
            this.renderingShadows = false;
            this.resetGlobalState();
        }
        ;
        setState(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
            if (!this.localClippingEnabled || planes === null || planes.length === 0 || this.renderingShadows && !clipShadows) {
                // there's no local clipping
                if (this.renderingShadows) {
                    // there's no global clipping
                    this.projectPlanes(null);
                }
                else {
                    this.resetGlobalState();
                }
            }
            else {
                var nGlobal = this.renderingShadows ? 0 : this.numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = cache.clippingState || null;
                this.uniform.value = dstArray; // ensure unique state
                dstArray = this.projectPlanes(planes, camera, lGlobal, fromCache);
                for (var i = 0; i !== lGlobal; ++i) {
                    dstArray[i] = this.globalState[i];
                }
                cache.clippingState = dstArray;
                this.numIntersection = clipIntersection ? this.numPlanes : 0;
                this.numPlanes += nGlobal;
            }
        }
        ;
        resetGlobalState() {
            if (this.uniform.value !== this.globalState) {
                this.uniform.value = this.globalState;
                this.uniform.needsUpdate = this.numGlobalPlanes > 0;
            }
            this.numPlanes = this.numGlobalPlanes;
            this.numIntersection = 0;
        }
        projectPlanes(planes, camera, dstOffset, skipTransform) {
            var nPlanes = planes !== null ? planes.length : 0, dstArray = null;
            if (nPlanes !== 0) {
                dstArray = this.uniform.value;
                if (skipTransform !== true || dstArray === null) {
                    var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                    this.viewNormalMatrix.getNormalMatrix(viewMatrix);
                    if (dstArray === null || dstArray.length < flatSize) {
                        dstArray = new Float32Array(flatSize);
                    }
                    for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
                        this.plane.copy(planes[i]).applyMatrix4(viewMatrix, this.viewNormalMatrix);
                        this.plane.normal.toArray(dstArray, i4);
                        dstArray[i4 + 3] = this.plane.constant;
                    }
                }
                this.uniform.value = dstArray;
                this.uniform.needsUpdate = true;
            }
            this.numPlanes = nPlanes;
            return dstArray;
        }
    }
    THREE.WebGLClippingNode = WebGLClippingNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLContext {
        constructor(canvas, contextAttributes) {
            this.ACTIVE_ATTRIBUTES = 35721;
            this.ACTIVE_TEXTURE = 34016;
            this.ACTIVE_UNIFORMS = 35718;
            this.ALIASED_LINE_WIDTH_RANGE = 33902;
            this.ALIASED_POINT_SIZE_RANGE = 33901;
            this.ALPHA = 6406;
            this.ALPHA_BITS = 3413;
            this.ALWAYS = 519;
            this.ARRAY_BUFFER = 34962;
            this.ARRAY_BUFFER_BINDING = 34964;
            this.ATTACHED_SHADERS = 35717;
            this.BACK = 1029;
            this.BLEND = 3042;
            this.BLEND_COLOR = 32773;
            this.BLEND_DST_ALPHA = 32970;
            this.BLEND_DST_RGB = 32968;
            this.BLEND_EQUATION = 32777;
            this.BLEND_EQUATION_ALPHA = 34877;
            this.BLEND_EQUATION_RGB = 32777;
            this.BLEND_SRC_ALPHA = 32971;
            this.BLEND_SRC_RGB = 32969;
            this.BLUE_BITS = 3412;
            this.BOOL = 35670;
            this.BOOL_VEC2 = 35671;
            this.BOOL_VEC3 = 35672;
            this.BOOL_VEC4 = 35673;
            this.BROWSER_DEFAULT_WEBGL = 37444;
            this.BUFFER_SIZE = 34660;
            this.BUFFER_USAGE = 34661;
            this.BYTE = 5120;
            this.CCW = 2305;
            this.CLAMP_TO_EDGE = 33071;
            this.COLOR_ATTACHMENT0 = 36064;
            this.COLOR_BUFFER_BIT = 16384;
            this.COLOR_CLEAR_VALUE = 3106;
            this.COLOR_WRITEMASK = 3107;
            this.COMPILE_STATUS = 35713;
            this.COMPRESSED_TEXTURE_FORMATS = 34467;
            this.CONSTANT_ALPHA = 32771;
            this.CONSTANT_COLOR = 32769;
            this.CONTEXT_LOST_WEBGL = 37442;
            this.CULL_FACE = 2884;
            this.CULL_FACE_MODE = 2885;
            this.CURRENT_PROGRAM = 35725;
            this.CURRENT_VERTEX_ATTRIB = 34342;
            this.CW = 2304;
            this.DECR = 7683;
            this.DECR_WRAP = 34056;
            this.DELETE_STATUS = 35712;
            this.DEPTH_ATTACHMENT = 36096;
            this.DEPTH_BITS = 3414;
            this.DEPTH_BUFFER_BIT = 256;
            this.DEPTH_CLEAR_VALUE = 2931;
            this.DEPTH_COMPONENT = 6402;
            this.DEPTH_COMPONENT16 = 33189;
            this.DEPTH_FUNC = 2932;
            this.DEPTH_RANGE = 2928;
            this.DEPTH_STENCIL = 34041;
            this.DEPTH_STENCIL_ATTACHMENT = 33306;
            this.DEPTH_TEST = 2929;
            this.DEPTH_WRITEMASK = 2930;
            this.DITHER = 3024;
            this.DONT_CARE = 4352;
            this.DST_ALPHA = 772;
            this.DST_COLOR = 774;
            this.DYNAMIC_DRAW = 35048;
            this.ELEMENT_ARRAY_BUFFER = 34963;
            this.ELEMENT_ARRAY_BUFFER_BINDING = 34965;
            this.EQUAL = 514;
            this.FASTEST = 4353;
            this.FLOAT = 5126;
            this.FLOAT_MAT2 = 35674;
            this.FLOAT_MAT3 = 35675;
            this.FLOAT_MAT4 = 35676;
            this.FLOAT_VEC2 = 35664;
            this.FLOAT_VEC3 = 35665;
            this.FLOAT_VEC4 = 35666;
            this.FRAGMENT_SHADER = 35632;
            this.FRAMEBUFFER = 36160;
            this.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049;
            this.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048;
            this.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051;
            this.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050;
            this.FRAMEBUFFER_BINDING = 36006;
            this.FRAMEBUFFER_COMPLETE = 36053;
            this.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054;
            this.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057;
            this.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055;
            this.FRAMEBUFFER_UNSUPPORTED = 36061;
            this.FRONT = 1028;
            this.FRONT_AND_BACK = 1032;
            this.FRONT_FACE = 2886;
            this.FUNC_ADD = 32774;
            this.FUNC_REVERSE_SUBTRACT = 32779;
            this.FUNC_SUBTRACT = 32778;
            this.GENERATE_MIPMAP_HINT = 33170;
            this.GEQUAL = 518;
            this.GREATER = 516;
            this.GREEN_BITS = 3411;
            this.HIGH_FLOAT = 36338;
            this.HIGH_INT = 36341;
            this.IMPLEMENTATION_COLOR_READ_FORMAT = 35739;
            this.IMPLEMENTATION_COLOR_READ_TYPE = 35738;
            this.INCR = 7682;
            this.INCR_WRAP = 34055;
            this.INT = 5124;
            this.INT_VEC2 = 35667;
            this.INT_VEC3 = 35668;
            this.INT_VEC4 = 35669;
            this.INVALID_ENUM = 1280;
            this.INVALID_FRAMEBUFFER_OPERATION = 1286;
            this.INVALID_OPERATION = 1282;
            this.INVALID_VALUE = 1281;
            this.INVERT = 5386;
            this.KEEP = 7680;
            this.LEQUAL = 515;
            this.LESS = 513;
            this.LINEAR = 9729;
            this.LINEAR_MIPMAP_LINEAR = 9987;
            this.LINEAR_MIPMAP_NEAREST = 9985;
            this.LINES = 1;
            this.LINE_LOOP = 2;
            this.LINE_STRIP = 3;
            this.LINE_WIDTH = 2849;
            this.LINK_STATUS = 35714;
            this.LOW_FLOAT = 36336;
            this.LOW_INT = 36339;
            this.LUMINANCE = 6409;
            this.LUMINANCE_ALPHA = 6410;
            this.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661;
            this.MAX_CUBE_MAP_TEXTURE_SIZE = 34076;
            this.MAX_FRAGMENT_UNIFORM_VECTORS = 36349;
            this.MAX_RENDERBUFFER_SIZE = 34024;
            this.MAX_TEXTURE_IMAGE_UNITS = 34930;
            this.MAX_TEXTURE_SIZE = 3379;
            this.MAX_VARYING_VECTORS = 36348;
            this.MAX_VERTEX_ATTRIBS = 34921;
            this.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660;
            this.MAX_VERTEX_UNIFORM_VECTORS = 36347;
            this.MAX_VIEWPORT_DIMS = 3386;
            this.MEDIUM_FLOAT = 36337;
            this.MEDIUM_INT = 36340;
            this.MIRRORED_REPEAT = 33648;
            this.NEAREST = 9728;
            this.NEAREST_MIPMAP_LINEAR = 9986;
            this.NEAREST_MIPMAP_NEAREST = 9984;
            this.NEVER = 512;
            this.NICEST = 4354;
            this.NONE = 0;
            this.NOTEQUAL = 517;
            this.NO_ERROR = 0;
            this.ONE = 1;
            this.ONE_MINUS_CONSTANT_ALPHA = 32772;
            this.ONE_MINUS_CONSTANT_COLOR = 32770;
            this.ONE_MINUS_DST_ALPHA = 773;
            this.ONE_MINUS_DST_COLOR = 775;
            this.ONE_MINUS_SRC_ALPHA = 771;
            this.ONE_MINUS_SRC_COLOR = 769;
            this.OUT_OF_MEMORY = 1285;
            this.PACK_ALIGNMENT = 3333;
            this.POINTS = 0;
            this.POLYGON_OFFSET_FACTOR = 32824;
            this.POLYGON_OFFSET_FILL = 32823;
            this.POLYGON_OFFSET_UNITS = 10752;
            this.RED_BITS = 3410;
            this.RENDERBUFFER = 36161;
            this.RENDERBUFFER_ALPHA_SIZE = 36179;
            this.RENDERBUFFER_BINDING = 36007;
            this.RENDERBUFFER_BLUE_SIZE = 36178;
            this.RENDERBUFFER_DEPTH_SIZE = 36180;
            this.RENDERBUFFER_GREEN_SIZE = 36177;
            this.RENDERBUFFER_HEIGHT = 36163;
            this.RENDERBUFFER_INTERNAL_FORMAT = 36164;
            this.RENDERBUFFER_RED_SIZE = 36176;
            this.RENDERBUFFER_STENCIL_SIZE = 36181;
            this.RENDERBUFFER_WIDTH = 36162;
            this.RENDERER = 7937;
            this.REPEAT = 10497;
            this.REPLACE = 7681;
            this.RGB = 6407;
            this.RGB5_A1 = 32855;
            this.RGB565 = 36194;
            this.RGBA = 6408;
            this.RGBA4 = 32854;
            this.SAMPLER_2D = 35678;
            this.SAMPLER_CUBE = 35680;
            this.SAMPLES = 32937;
            this.SAMPLE_ALPHA_TO_COVERAGE = 32926;
            this.SAMPLE_BUFFERS = 32936;
            this.SAMPLE_COVERAGE = 32928;
            this.SAMPLE_COVERAGE_INVERT = 32939;
            this.SAMPLE_COVERAGE_VALUE = 32938;
            this.SCISSOR_BOX = 3088;
            this.SCISSOR_TEST = 3089;
            this.SHADER_TYPE = 35663;
            this.SHADING_LANGUAGE_VERSION = 35724;
            this.SHORT = 5122;
            this.SRC_ALPHA = 770;
            this.SRC_ALPHA_SATURATE = 776;
            this.SRC_COLOR = 768;
            this.STATIC_DRAW = 35044;
            this.STENCIL_ATTACHMENT = 36128;
            this.STENCIL_BACK_FAIL = 34817;
            this.STENCIL_BACK_FUNC = 34816;
            this.STENCIL_BACK_PASS_DEPTH_FAIL = 34818;
            this.STENCIL_BACK_PASS_DEPTH_PASS = 34819;
            this.STENCIL_BACK_REF = 36003;
            this.STENCIL_BACK_VALUE_MASK = 36004;
            this.STENCIL_BACK_WRITEMASK = 36005;
            this.STENCIL_BITS = 3415;
            this.STENCIL_BUFFER_BIT = 1024;
            this.STENCIL_CLEAR_VALUE = 2961;
            this.STENCIL_FAIL = 2964;
            this.STENCIL_FUNC = 2962;
            this.STENCIL_INDEX8 = 36168;
            this.STENCIL_PASS_DEPTH_FAIL = 2965;
            this.STENCIL_PASS_DEPTH_PASS = 2966;
            this.STENCIL_REF = 2967;
            this.STENCIL_TEST = 2960;
            this.STENCIL_VALUE_MASK = 2963;
            this.STENCIL_WRITEMASK = 2968;
            this.STREAM_DRAW = 35040;
            this.SUBPIXEL_BITS = 3408;
            this.TEXTURE = 5890;
            this.TEXTURE0 = 33984;
            this.TEXTURE1 = 33985;
            this.TEXTURE2 = 33986;
            this.TEXTURE3 = 33987;
            this.TEXTURE4 = 33988;
            this.TEXTURE5 = 33989;
            this.TEXTURE6 = 33990;
            this.TEXTURE7 = 33991;
            this.TEXTURE8 = 33992;
            this.TEXTURE9 = 33993;
            this.TEXTURE10 = 33994;
            this.TEXTURE11 = 33995;
            this.TEXTURE12 = 33996;
            this.TEXTURE13 = 33997;
            this.TEXTURE14 = 33998;
            this.TEXTURE15 = 33999;
            this.TEXTURE16 = 34000;
            this.TEXTURE17 = 34001;
            this.TEXTURE18 = 34002;
            this.TEXTURE19 = 34003;
            this.TEXTURE20 = 34004;
            this.TEXTURE21 = 34005;
            this.TEXTURE22 = 34006;
            this.TEXTURE23 = 34007;
            this.TEXTURE24 = 34008;
            this.TEXTURE25 = 34009;
            this.TEXTURE26 = 34010;
            this.TEXTURE27 = 34011;
            this.TEXTURE28 = 34012;
            this.TEXTURE29 = 34013;
            this.TEXTURE30 = 34014;
            this.TEXTURE31 = 34015;
            this.TEXTURE_2D = 3553;
            this.TEXTURE_BINDING_2D = 32873;
            this.TEXTURE_BINDING_CUBE_MAP = 34068;
            this.TEXTURE_CUBE_MAP = 34067;
            this.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070;
            this.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072;
            this.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074;
            this.TEXTURE_CUBE_MAP_POSITIVE_X = 34069;
            this.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071;
            this.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073;
            this.TEXTURE_MAG_FILTER = 10240;
            this.TEXTURE_MIN_FILTER = 10241;
            this.TEXTURE_WRAP_S = 10242;
            this.TEXTURE_WRAP_T = 10243;
            this.TRIANGLES = 4;
            this.TRIANGLE_FAN = 6;
            this.TRIANGLE_STRIP = 5;
            this.UNPACK_ALIGNMENT = 3317;
            this.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443;
            this.UNPACK_FLIP_Y_WEBGL = 37440;
            this.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441;
            this.UNSIGNED_BYTE = 5121;
            this.UNSIGNED_INT = 5125;
            this.UNSIGNED_SHORT = 5123;
            this.UNSIGNED_SHORT_4_4_4_4 = 32819;
            this.UNSIGNED_SHORT_5_5_5_1 = 32820;
            this.UNSIGNED_SHORT_5_6_5 = 33635;
            this.VALIDATE_STATUS = 35715;
            this.VENDOR = 7936;
            this.VERSION = 7938;
            this.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975;
            this.VERTEX_ATTRIB_ARRAY_ENABLED = 34338;
            this.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922;
            this.VERTEX_ATTRIB_ARRAY_POINTER = 34373;
            this.VERTEX_ATTRIB_ARRAY_SIZE = 34339;
            this.VERTEX_ATTRIB_ARRAY_STRIDE = 34340;
            this.VERTEX_ATTRIB_ARRAY_TYPE = 34341;
            this.VERTEX_SHADER = 35633;
            this.VIEWPORT = 2978;
            this.ZERO = 0;
            this.canvas = canvas;
            this.gl = this.canvas.getContext('webgl', contextAttributes) || this.canvas.getContext('experimental-webgl', contextAttributes);
        }
        activeTexture(texture) {
            this.gl.activeTexture(texture);
        }
        attachShader(program, shader) {
            this.gl.attachShader(program, shader);
        }
        bindAttribLocation(program, index, name) {
            this.gl.bindAttribLocation(program, index, name);
        }
        bindBuffer(target, buffer) {
            this.gl.bindBuffer(target, buffer);
        }
        bindFramebuffer(target, framebuffer) {
            this.gl.bindFramebuffer(target, framebuffer);
        }
        bindRenderbuffer(target, renderbuffer) {
            this.gl.bindRenderbuffer(target, renderbuffer);
        }
        bindTexture(target, texture) {
            this.gl.bindTexture(target, texture);
        }
        blendColor(red, green, blue, alpha) {
            this.gl.blendColor(red, green, blue, alpha);
        }
        blendEquation(mode) {
            this.gl.blendEquation(mode);
        }
        blendEquationSeparate(modeRGB, modeAlpha) {
            this.gl.blendEquationSeparate(modeRGB, modeAlpha);
        }
        blendFunc(modeRGB, modeAlpha) {
            this.gl.blendFunc(modeRGB, modeAlpha);
        }
        blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
            this.gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
        }
        bufferData(target, size, usage) {
            this.gl.bufferData(target, size, usage);
        }
        bufferSubData(target, offset, data) {
            this.gl.bufferSubData(target, offset, data);
        }
        checkFramebufferStatus(target) {
            var result = this.gl.checkFramebufferStatus(target);
            return result;
        }
        clear(mask) {
            this.gl.clear(mask);
        }
        clearColor(red, green, blue, alpha) {
            this.gl.clearColor(red, green, blue, alpha);
        }
        clearDepth(depth) {
            this.gl.clearDepth(depth);
        }
        clearStencil(s) {
            this.gl.clearStencil(s);
        }
        colorMask(red, green, blue, alpha) {
            this.gl.colorMask(red, green, blue, alpha);
        }
        compileShader(shader) {
            this.gl.compileShader(shader);
        }
        compressedTexImage2D(target, level, internalformat, width, height, border, data) {
            this.gl.compressedTexImage2D(target, level, internalformat, width, height, border, data);
        }
        compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data) {
            this.gl.compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data);
        }
        copyTexImage2D(target, level, internalformat, x, y, width, height, border) {
            this.gl.copyTexImage2D(target, level, internalformat, x, y, width, height, border);
        }
        copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height) {
            this.gl.copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
        }
        createBuffer() {
            return this.gl.createBuffer();
        }
        createFramebuffer() {
            return this.gl.createFramebuffer();
        }
        createProgram() {
            return this.gl.createProgram();
        }
        createRenderbuffer() {
            return this.gl.createRenderbuffer();
        }
        createShader(type) {
            return this.gl.createShader(type);
        }
        createTexture() {
            return this.gl.createTexture();
        }
        cullFace(mode) {
            this.gl.cullFace(mode);
        }
        deleteBuffer(buffer) {
            this.gl.deleteBuffer(buffer);
        }
        deleteFramebuffer(framebuffer) {
            this.gl.deleteFramebuffer(framebuffer);
        }
        deleteProgram(program) {
            this.gl.deleteProgram(program);
        }
        deleteRenderbuffer(program) {
            this.gl.deleteRenderbuffer(program);
        }
        deleteShader(shader) {
            this.gl.deleteShader(shader);
        }
        deleteTexture(texture) {
            this.gl.deleteTexture(texture);
        }
        depthFunc(func) {
            this.gl.depthFunc(func);
        }
        depthMask(flag) {
            this.gl.depthMask(flag);
        }
        depthRange(zNear, zFar) {
            this.gl.depthRange(zNear, zFar);
        }
        detachShader(program, shader) {
            this.gl.detachShader(program, shader);
        }
        disable(cap) {
            this.gl.disable(cap);
        }
        disableVertexAttribArray(index) {
            this.gl.disableVertexAttribArray(index);
        }
        drawArrays(mode, first, count) {
            this.gl.drawArrays(mode, first, count);
        }
        drawElements(mode, count, type, offset) {
            this.gl.drawElements(mode, count, type, offset);
        }
        enable(cap) {
            this.gl.enable(cap);
        }
        enableVertexAttribArray(index) {
            this.gl.enableVertexAttribArray(index);
        }
        finish() {
            this.gl.finish();
        }
        flush() {
            this.gl.flush();
        }
        framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer) {
            this.gl.framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
        }
        framebufferTexture2D(target, attachment, textarget, texture, level) {
            this.gl.framebufferTexture2D(target, attachment, textarget, texture, level);
        }
        frontFace(mode) {
            this.gl.frontFace(mode);
        }
        generateMipmap(mode) {
            return this.gl.generateMipmap(mode);
        }
        getActiveAttrib(program, index) {
            return this.gl.getActiveAttrib(program, index);
        }
        getActiveUniform(program, index) {
            return this.gl.getActiveUniform(program, index);
        }
        getAttachedShaders(program) {
            return this.gl.getAttachedShaders(program);
        }
        getAttribLocation(program, name) {
            return this.gl.getAttribLocation(program, name);
        }
        getBufferParameter(target, pname) {
            return this.gl.getBufferParameter(target, pname);
        }
        getContextAttributes() {
            return this.gl.getContextAttributes();
        }
        getError() {
            return this.gl.getError();
        }
        // todo
        getExtension(extensionName) {
            var result = this.gl.getExtension(extensionName);
            return result;
        }
        getFramebufferAttachmentParameter(target, attachment, pname) {
            return this.gl.getFramebufferAttachmentParameter(target, attachment, pname);
        }
        getParameter(pname) {
            var result = this.gl.getParameter(pname);
            return result;
        }
        getProgramInfoLog(program) {
            return this.gl.getProgramInfoLog(program);
        }
        getProgramParameter(program, pname) {
            return this.gl.getProgramParameter(program, pname);
        }
        getRenderbufferParameter(target, pname) {
            return this.gl.getRenderbufferParameter(target, pname);
        }
        getShaderInfoLog(shader) {
            return this.gl.getShaderInfoLog(shader);
        }
        getShaderParameter(shader, pname) {
            return this.gl.getShaderParameter(shader, pname);
        }
        getShaderPrecisionFormat(shadertype, precisiontype) {
            return this.gl.getShaderPrecisionFormat(shadertype, precisiontype);
        }
        getShaderSource(shader) {
            return this.gl.getShaderSource(shader);
        }
        getSupportedExtensions() {
            return this.gl.getSupportedExtensions();
        }
        getTexParameter(target, pname) {
            return this.gl.getTexParameter(target, pname);
        }
        getUniform(program, location) {
            return this.gl.getUniform(program, location);
        }
        getUniformLocation(program, name) {
            return this.gl.getUniformLocation(program, name);
        }
        getVertexAttrib(index, pname) {
            return this.gl.getVertexAttrib(index, pname);
        }
        getVertexAttribOffset(index, pname) {
            return this.gl.getVertexAttribOffset(index, pname);
        }
        hint(target, mode) {
            this.gl.hint(target, mode);
        }
        isBuffer(buffer) {
            this.gl.isBuffer(buffer);
        }
        isContextLost() {
            this.gl.isContextLost();
        }
        isEnabled(cap) {
            this.gl.isEnabled(cap);
        }
        isFramebuffer(framebuffer) {
            this.gl.isFramebuffer(framebuffer);
        }
        isProgram(program) {
            this.gl.isProgram(program);
        }
        isRenderbuffer(renderbuffer) {
            this.gl.isRenderbuffer(renderbuffer);
        }
        isShader(shader) {
            this.gl.isShader(shader);
        }
        isTexture(shader) {
            this.gl.isTexture(shader);
        }
        lineWidth(width) {
            this.gl.lineWidth(width);
        }
        linkProgram(program) {
            this.gl.linkProgram(program);
        }
        pixelStorei(pname, param) {
            this.gl.pixelStorei(pname, param);
        }
        polygonOffset(factor, units) {
            this.gl.polygonOffset(factor, units);
        }
        readPixels(x, y, width, height, format, type, pixels) {
            this.gl.readPixels(x, y, width, height, format, type, pixels);
        }
        renderbufferStorage(target, internalformat, width, height) {
            this.gl.renderbufferStorage(target, internalformat, width, height);
        }
        sampleCoverage(value, invert) {
            this.gl.sampleCoverage(value, invert);
        }
        scissor(x, y, width, height) {
            this.gl.scissor(x, y, width, height);
        }
        shaderSource(shader, source) {
            this.gl.shaderSource(shader, source);
        }
        stencilFunc(func, ref, mask) {
            this.gl.stencilFunc(func, ref, mask);
        }
        stencilFuncSeparate(face, func, ref, mask) {
            this.gl.stencilFuncSeparate(face, func, ref, mask);
        }
        stencilMask(mask) {
            this.gl.stencilMask(mask);
        }
        stencilMaskSeparate(face, mask) {
            this.gl.stencilMaskSeparate(face, mask);
        }
        stencilOp(fail, zfail, zpass) {
            this.gl.stencilOp(fail, zfail, zpass);
        }
        stencilOpSeparate(face, fail, zfail, zpass) {
            this.gl.stencilOpSeparate(face, fail, zfail, zpass);
        }
        texImage2D(target, level, internalformat, width, height, border, format, type, pixels) {
            this.gl.texImage2D(target, level, internalformat, width, height, border, format, type, pixels);
        }
        texParameterf(target, pname, param) {
            this.gl.texParameterf(target, pname, param);
        }
        texParameteri(target, pname, param) {
            this.gl.texParameteri(target, pname, param);
        }
        texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels) {
            this.gl.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
        }
        uniform1f(location, x) {
            this.gl.uniform1f(location, x);
        }
        uniform1fv(location, v) {
            this.gl.uniform1fv(location, v);
        }
        uniform1i(location, x) {
            this.gl.uniform1i(location, x);
        }
        uniform1iv(location, v) {
            this.gl.uniform1iv(location, v);
        }
        uniform2f(location, x, y) {
            this.gl.uniform2f(location, x, y);
        }
        uniform2fv(location, v) {
            this.gl.uniform2fv(location, v);
        }
        uniform2i(location, x, y) {
            this.gl.uniform2i(location, x, y);
        }
        uniform2iv(location, v) {
            this.gl.uniform2iv(location, v);
        }
        uniform3f(location, x, y, z) {
            this.gl.uniform3f(location, x, y, z);
        }
        uniform3fv(location, v) {
            this.gl.uniform3fv(location, v);
        }
        uniform3i(location, x, y, z) {
            this.gl.uniform3i(location, x, y, z);
        }
        uniform3iv(location, v) {
            this.gl.uniform3iv(location, v);
        }
        uniform4f(location, x, y, z, w) {
            this.gl.uniform4f(location, x, y, z, w);
        }
        uniform4fv(location, v) {
            this.gl.uniform4fv(location, v);
        }
        uniform4i(location, x, y, z, w) {
            this.gl.uniform4i(location, x, y, z, w);
        }
        uniform4iv(location, v) {
            this.gl.uniform4iv(location, v);
        }
        uniformMatrix2fv(location, transpose, value) {
            this.gl.uniformMatrix2fv(location, transpose, value);
        }
        uniformMatrix3fv(location, transpose, value) {
            this.gl.uniformMatrix3fv(location, transpose, value);
        }
        uniformMatrix4fv(location, transpose, value) {
            this.gl.uniformMatrix4fv(location, transpose, value);
        }
        useProgram(program) {
            this.gl.useProgram(program);
        }
        validateProgram(program) {
            this.gl.validateProgram(program);
        }
        vertexAttrib1f(indx, x) {
            this.gl.vertexAttrib1f(indx, x);
        }
        vertexAttrib1fv(indx, values) {
            this.gl.vertexAttrib1fv(indx, values);
        }
        vertexAttrib2f(indx, x, y) {
            this.gl.vertexAttrib2f(indx, x, y);
        }
        vertexAttrib2fv(indx, values) {
            this.gl.vertexAttrib2fv(indx, values);
        }
        vertexAttrib3f(indx, x, y, z) {
            this.gl.vertexAttrib3f(indx, x, y, z);
        }
        vertexAttrib3fv(indx, values) {
            this.gl.vertexAttrib3fv(indx, values);
        }
        vertexAttrib4f(indx, x, y, z, w) {
            this.gl.vertexAttrib4f(indx, x, y, z, w);
        }
        vertexAttrib4fv(indx, values) {
            this.gl.vertexAttrib4fv(indx, values);
        }
        vertexAttribPointer(indx, size, type, normalized, stride, offset) {
            this.gl.vertexAttribPointer(indx, size, type, normalized, stride, offset);
        }
        viewport(x, y, width, height) {
            this.gl.viewport(x, y, width, height);
        }
    }
    THREE.WebGLContext = WebGLContext;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLExtensionsNode {
        constructor(gl) {
            this.extensions = {};
            this.gl = gl;
        }
        get(name) {
            var extensions = this.extensions;
            var gl = this.gl;
            if (extensions[name] !== undefined) {
                return extensions[name];
            }
            var extension;
            switch (name) {
                case 'WEBGL_depth_texture':
                    extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                    break;
                case 'EXT_texture_filter_anisotropic':
                    extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                    break;
                case 'WEBGL_compressed_texture_s3tc':
                    extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                    break;
                case 'WEBGL_compressed_texture_pvrtc':
                    extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                    break;
                default:
                    extension = gl.getExtension(name);
            }
            if (extension === null) {
                console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
            }
            extensions[name] = extension;
            return extension;
        }
    }
    THREE.WebGLExtensionsNode = WebGLExtensionsNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLGeometriesNode {
        constructor(gl, attributes, info) {
            this.geometries = {};
            this.wireframeAttributes = {};
            this.gl = gl;
            this.attributes = attributes;
            this.info = info;
        }
        onGeometryDispose(event) {
            var geometries = this.geometries;
            var geometry = event.target;
            var buffergeometry = geometries[geometry.id];
            if (buffergeometry.index !== null) {
                this.attributes.remove(buffergeometry.index);
            }
            for (var name in buffergeometry.attributes) {
                this.attributes.remove(buffergeometry.attributes[name]);
            }
            geometry.removeEventListener('dispose', this.onGeometryDispose);
            delete geometries[geometry.id];
            // TODO Remove duplicate code
            var attribute = this.wireframeAttributes[geometry.id];
            if (attribute) {
                this.attributes.remove(attribute);
                delete this.wireframeAttributes[geometry.id];
            }
            attribute = this.wireframeAttributes[buffergeometry.id];
            if (attribute) {
                this.attributes.remove(attribute);
                delete this.wireframeAttributes[buffergeometry.id];
            }
            //
            this.info.memory.geometries--;
        }
        get(object, geometry) {
            var buffergeometry = this.geometries[geometry.id];
            if (buffergeometry)
                return buffergeometry;
            geometry.addEventListener('dispose', this.onGeometryDispose);
            if (geometry.isBufferGeometry) {
                buffergeometry = geometry;
            }
            else if (geometry.isGeometry) {
                if (geometry._bufferGeometry === undefined) {
                    geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject(object);
                }
                buffergeometry = geometry._bufferGeometry;
            }
            this.geometries[geometry.id] = buffergeometry;
            this.info.memory.geometries++;
            return buffergeometry;
        }
        update(geometry) {
            var index = geometry.index;
            var geometryAttributes = geometry.attributes;
            if (index !== null) {
                this.attributes.update(index, this.gl.ELEMENT_ARRAY_BUFFER);
            }
            for (var name in geometryAttributes) {
                this.attributes.update(geometryAttributes[name], this.gl.ARRAY_BUFFER);
            }
            // morph targets
            var morphAttributes = geometry.morphAttributes;
            for (var name in morphAttributes) {
                var array = morphAttributes[name];
                for (var i = 0, l = array.length; i < l; i++) {
                    this.attributes.update(array[i], this.gl.ARRAY_BUFFER);
                }
            }
        }
        getWireframeAttribute(geometry) {
            var attribute = this.wireframeAttributes[geometry.id];
            if (attribute)
                return attribute;
            var indices = [];
            var geometryIndex = geometry.index;
            var geometryAttributes = geometry.attributes;
            // console.time( 'wireframe' );
            if (geometryIndex !== null) {
                var array = geometryIndex.array;
                for (var i = 0, l = array.length; i < l; i += 3) {
                    var a = array[i + 0];
                    var b = array[i + 1];
                    var c = array[i + 2];
                    indices.push(a, b, b, c, c, a);
                }
            }
            else {
                var array = geometryAttributes.position.array;
                for (var i = 0, count = (array.length / 3) - 1; i < count; i += 3) {
                    var a = i + 0;
                    var b = i + 1;
                    var c = i + 2;
                    indices.push(a, b, b, c, c, a);
                }
            }
            // console.timeEnd( 'wireframe' );
            attribute = new (THREE.arrayMax(indices) > 65535 ? THREE.Uint32BufferAttribute : THREE.Uint16BufferAttribute)(indices, 1, null);
            this.attributes.update(attribute, this.gl.ELEMENT_ARRAY_BUFFER);
            this.wireframeAttributes[geometry.id] = attribute;
            return attribute;
        }
    }
    THREE.WebGLGeometriesNode = WebGLGeometriesNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLIndexedBufferRendererNode {
        constructor(gl, extensions, info) {
            this.gl = gl;
            this.extensions = extensions;
            this.info = info;
        }
        setMode(value) {
            this.mode = value;
        }
        setIndex(value) {
            this.type = value.type;
            this.bytesPerElement = value.bytesPerElement;
        }
        render(start, count) {
            this.gl.drawElements(this.mode, count, this.type, start * this.bytesPerElement);
            this.info.update(count, this.mode);
        }
        renderInstances(geometry, start, count) {
            var extension = this.extensions.get('ANGLE_instanced_arrays');
            if (extension === null) {
                console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
            extension.drawElementsInstancedANGLE(this.mode, count, this.type, start * this.bytesPerElement, geometry.maxInstancedCount);
            this.info.update(count, this.mode, geometry.maxInstancedCount);
        }
    }
    THREE.WebGLIndexedBufferRendererNode = WebGLIndexedBufferRendererNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class renderRecoder {
        constructor() {
            this.frame = 0;
            this.calls = 0;
            this.triangles = 0;
            this.points = 0;
            this.lines = 0;
        }
    }
    THREE.renderRecoder = renderRecoder;
    /**
     * 渲染过程信息
     */
    class WebGLInfoNode {
        constructor(gl) {
            this.gl = gl;
            this.memory = {
                geometries: 0,
                textures: 0
            };
            this.render = new renderRecoder();
        }
        /**
         * 更新渲染过程记录的信息
         */
        update(count, mode, instanceCount) {
            instanceCount = instanceCount || 1;
            this.render.calls++;
            switch (mode) {
                case this.gl.TRIANGLES:
                    this.render.triangles += instanceCount * (count / 3);
                    break;
                case this.gl.TRIANGLE_STRIP:
                case this.gl.TRIANGLE_FAN:
                    this.render.triangles += instanceCount * (count - 2);
                    break;
                case this.gl.LINES:
                    this.render.lines += instanceCount * (count / 2);
                    break;
                case this.gl.LINE_STRIP:
                    this.render.lines += instanceCount * (count - 1);
                    break;
                case this.gl.LINE_LOOP:
                    this.render.lines += instanceCount * count;
                    break;
                case this.gl.POINTS:
                    this.render.points += instanceCount * count;
                    break;
                default:
                    console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
                    break;
            }
        }
        /**
         * 重新设置
         */
        reset() {
            this.render.frame++;
            this.render.calls = 0;
            this.render.triangles = 0;
            this.render.points = 0;
            this.render.lines = 0;
        }
    }
    THREE.WebGLInfoNode = WebGLInfoNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class LightUniformsCache {
        constructor() {
            this.lights = {};
        }
        get(light) {
            if (this.lights[light.id] !== undefined) {
                return this.lights[light.id];
            }
            var uniforms;
            switch (light.type) {
                case 'DirectionalLight':
                    uniforms = {
                        direction: new THREE.Vector3(),
                        color: new THREE.Color(),
                        shadow: false,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new THREE.Vector2()
                    };
                    break;
                case 'SpotLight':
                    uniforms = {
                        position: new THREE.Vector3(),
                        direction: new THREE.Vector3(),
                        color: new THREE.Color(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: false,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new THREE.Vector2()
                    };
                    break;
                case 'PointLight':
                    uniforms = {
                        position: new THREE.Vector3(),
                        color: new THREE.Color(),
                        distance: 0,
                        decay: 0,
                        shadow: false,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new THREE.Vector2(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1000
                    };
                    break;
                case 'HemisphereLight':
                    uniforms = {
                        direction: new THREE.Vector3(),
                        skyColor: new THREE.Color(),
                        groundColor: new THREE.Color()
                    };
                    break;
                case 'RectAreaLight':
                    uniforms = {
                        color: new THREE.Color(),
                        position: new THREE.Vector3(),
                        halfWidth: new THREE.Vector3(),
                        halfHeight: new THREE.Vector3()
                        // TODO (abelnation): set RectAreaLight shadow uniforms
                    };
                    break;
            }
            this.lights[light.id] = uniforms;
            return uniforms;
        }
    }
    THREE.LightUniformsCache = LightUniformsCache;
    class LightsStateManger {
        constructor() {
        }
    }
    THREE.LightsStateManger = LightsStateManger;
    class WebGLLightsNode {
        constructor() {
            this.cache = new LightUniformsCache();
            var lightsStateManager = new LightsStateManger();
            lightsStateManager = {
                id: WebGLLightsNode.count++,
                hash: '',
                ambient: [0, 0, 0],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            };
            this.state = lightsStateManager;
            this.vector3 = new THREE.Vector3();
            this.matrix4 = new THREE.Matrix4();
            this.matrix42 = new THREE.Matrix4();
        }
        setup(lights, shadows, camera) {
            var r = 0, g = 0, b = 0;
            var directionalLength = 0;
            var pointLength = 0;
            var spotLength = 0;
            var rectAreaLength = 0;
            var hemiLength = 0;
            var viewMatrix = camera.matrixWorldInverse;
            for (var i = 0, l = lights.length; i < l; i++) {
                var light = lights[i];
                var color = light.color;
                var intensity = light.intensity;
                var distance = light.distance;
                var shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;
                if (light.isAmbientLight) {
                    r += color.r * intensity;
                    g += color.g * intensity;
                    b += color.b * intensity;
                }
                else if (light.isDirectionalLight) {
                    var uniforms = this.cache.get(light);
                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    this.vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(this.vector3);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                    }
                    this.state.directionalShadowMap[directionalLength] = shadowMap;
                    this.state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                    this.state.directional[directionalLength] = uniforms;
                    directionalLength++;
                }
                else if (light.isSpotLight) {
                    var uniforms = this.cache.get(light);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    uniforms.color.copy(color).multiplyScalar(intensity);
                    uniforms.distance = distance;
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    this.vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(this.vector3);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.coneCos = Math.cos(light.angle);
                    uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                    uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                    }
                    this.state.spotShadowMap[spotLength] = shadowMap;
                    this.state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                    this.state.spot[spotLength] = uniforms;
                    spotLength++;
                }
                else if (light.isRectAreaLight) {
                    var uniforms = this.cache.get(light);
                    // (a) intensity is the total visible light emitted
                    //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
                    // (b) intensity is the brightness of the light
                    uniforms.color.copy(color).multiplyScalar(intensity);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    // extract local rotation of light to derive width/height half vectors
                    this.matrix42.identity();
                    this.matrix4.copy(light.matrixWorld);
                    this.matrix4.premultiply(viewMatrix);
                    this.matrix42.extractRotation(this.matrix4);
                    uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                    uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
                    uniforms.halfWidth.applyMatrix4(this.matrix42);
                    uniforms.halfHeight.applyMatrix4(this.matrix42);
                    // TODO (abelnation): RectAreaLight distance?
                    // uniforms.distance = distance;
                    this.state.rectArea[rectAreaLength] = uniforms;
                    rectAreaLength++;
                }
                else if (light.isPointLight) {
                    var uniforms = this.cache.get(light);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.distance = light.distance;
                    uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                        uniforms.shadowCameraNear = shadow.camera.near;
                        uniforms.shadowCameraFar = shadow.camera.far;
                    }
                    this.state.pointShadowMap[pointLength] = shadowMap;
                    this.state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                    this.state.point[pointLength] = uniforms;
                    pointLength++;
                }
                else if (light.isHemisphereLight) {
                    var uniforms = this.cache.get(light);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.direction.normalize();
                    uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                    uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                    this.state.hemi[hemiLength] = uniforms;
                    hemiLength++;
                }
            }
            this.state.ambient[0] = r;
            this.state.ambient[1] = g;
            this.state.ambient[2] = b;
            this.state.directional.length = directionalLength;
            this.state.spot.length = spotLength;
            this.state.rectArea.length = rectAreaLength;
            this.state.point.length = pointLength;
            this.state.hemi.length = hemiLength;
            this.state.hash = this.state.id + ',' + directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;
        }
    }
    WebGLLightsNode.count = 0;
    THREE.WebGLLightsNode = WebGLLightsNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    function absNumericalSort(a, b) {
        return Math.abs(b[1]) - Math.abs(a[1]);
    }
    THREE.absNumericalSort = absNumericalSort;
    class WebGLMorphtargetsNode {
        constructor(gl) {
            this.influencesList = {};
            this.morphInfluences = new Float32Array(8);
        }
        update(object, geometry, material, program) {
            var objectInfluences = object.morphTargetInfluences;
            var length = objectInfluences.length;
            var influences = this.influencesList[geometry.id];
            if (influences === undefined) {
                // initialise list
                influences = [];
                for (var i = 0; i < length; i++) {
                    influences[i] = [i, 0];
                }
                this.influencesList[geometry.id] = influences;
            }
            var morphTargets = material.morphTargets && geometry.morphAttributes.position;
            var morphNormals = material.morphNormals && geometry.morphAttributes.normal;
            // Remove current morphAttributes
            for (var i = 0; i < length; i++) {
                var influence = influences[i];
                if (influence[1] !== 0) {
                    if (morphTargets)
                        geometry.removeAttribute('morphTarget' + i);
                    if (morphNormals)
                        geometry.removeAttribute('morphNormal' + i);
                }
            }
            // Collect influences
            for (var i = 0; i < length; i++) {
                var influence = influences[i];
                influence[0] = i;
                influence[1] = objectInfluences[i];
            }
            influences.sort(absNumericalSort);
            // Add morphAttributes
            for (var i = 0; i < 8; i++) {
                var influence = influences[i];
                if (influence) {
                    var index = influence[0];
                    var value = influence[1];
                    if (value) {
                        if (morphTargets)
                            geometry.addAttribute('morphTarget' + i, morphTargets[index]);
                        if (morphNormals)
                            geometry.addAttribute('morphNormal' + i, morphNormals[index]);
                        this.morphInfluences[i] = value;
                        continue;
                    }
                }
                this.morphInfluences[i] = 0;
            }
            program.getUniforms().setValue(this.gl, 'morphTargetInfluences', this.morphInfluences);
        }
    }
    THREE.WebGLMorphtargetsNode = WebGLMorphtargetsNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLObjectsNode {
        constructor(geometries, info) {
            this.geometries = geometries;
            this.info = info;
            this.updateList = {};
        }
        update(object) {
            var frame = this.info.render.frame;
            var geometry = object.geometry;
            var buffergeometry = this.geometries.get(object, geometry);
            // Update once per frame
            if (this.updateList[buffergeometry.id] !== frame) {
                if (geometry.isGeometry) {
                    buffergeometry.updateFromObject(object);
                }
                this.geometries.update(buffergeometry);
                this.updateList[buffergeometry.id] = frame;
            }
            return buffergeometry;
        }
        dispose() {
            this.updateList = {};
        }
    }
    THREE.WebGLObjectsNode = WebGLObjectsNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    var programIdCount = 0;
    function getEncodingComponents(encoding) {
        switch (encoding) {
            case THREE.LinearEncoding:
                return ['Linear', '( value )'];
            case THREE.sRGBEncoding:
                return ['sRGB', '( value )'];
            case THREE.RGBEEncoding:
                return ['RGBE', '( value )'];
            case THREE.RGBM7Encoding:
                return ['RGBM', '( value, 7.0 )'];
            case THREE.RGBM16Encoding:
                return ['RGBM', '( value, 16.0 )'];
            case THREE.RGBDEncoding:
                return ['RGBD', '( value, 256.0 )'];
            case THREE.GammaEncoding:
                return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
            default:
                throw new Error('unsupported encoding: ' + encoding);
        }
    }
    function getTexelDecodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
    }
    function getTexelEncodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
    }
    function getToneMappingFunction(functionName, toneMapping) {
        var toneMappingName;
        switch (toneMapping) {
            case THREE.LinearToneMapping:
                toneMappingName = 'Linear';
                break;
            case THREE.ReinhardToneMapping:
                toneMappingName = 'Reinhard';
                break;
            case THREE.Uncharted2ToneMapping:
                toneMappingName = 'Uncharted2';
                break;
            case THREE.CineonToneMapping:
                toneMappingName = 'OptimizedCineon';
                break;
            default:
                throw new Error('unsupported toneMapping: ' + toneMapping);
        }
        return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
    }
    function generateExtensions(extensions, parameters, rendererExtensions) {
        extensions = extensions || {};
        var chunks = [
            (extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading) ? '#extension GL_OES_standard_derivatives : enable' : '',
            (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '',
            (extensions.drawBuffers) && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '',
            (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : ''
        ];
        return chunks.filter(filterEmptyLine).join('\n');
    }
    function generateDefines(defines) {
        var chunks = [];
        for (var name in defines) {
            var value = defines[name];
            if (value === false)
                continue;
            chunks.push('#define ' + name + ' ' + value);
        }
        return chunks.join('\n');
    }
    /**
     * 从shader中获取当前激活的attribute
     * @param gl
     * @param program
     */
    function fetchAttributeLocations(gl, program) {
        var attributes = {};
        var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < n; i++) {
            var info = gl.getActiveAttrib(program, i);
            var name = info.name;
            // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
            attributes[name] = gl.getAttribLocation(program, name);
            // 名称和激活编号的map表信息
        }
        return attributes;
    }
    function filterEmptyLine(string) {
        return string !== '';
    }
    function replaceLightNums(string, parameters) {
        return string
            .replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
            .replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
            .replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights)
            .replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
            .replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
    }
    function replaceClippingPlaneNums(string, parameters) {
        return string
            .replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes)
            .replace(/UNION_CLIPPING_PLANES/g, (parameters.numClippingPlanes - parameters.numClipIntersection));
    }
    function parseIncludes(string) {
        var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;
        function replace(match, include) {
            var replace = THREE.ShaderChunk[include];
            if (replace === undefined) {
                throw new Error('Can not resolve #include <' + include + '>');
            }
            return parseIncludes(replace);
        }
        return string.replace(pattern, replace);
    }
    function unrollLoops(string) {
        var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
        function replace(match, start, end, snippet) {
            var unroll = '';
            for (var i = parseInt(start); i < parseInt(end); i++) {
                unroll += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]');
            }
            return unroll;
        }
        return string.replace(pattern, replace);
    }
    /**
     * webGLprogram
     */
    class WebGLProgramNode {
        constructor(renderer, extensions, code, material, shader, parameters) {
            this.name = shader.name;
            this.id = programIdCount++;
            this.code = code;
            this.usedTimes = 1;
            this.parameters = parameters;
            this.shader = shader;
            this.material = material;
            this.gl = renderer.context;
            this.material = material;
            this.renderer = renderer;
            this.extensions = extensions;
            var gl = this.gl;
            var defines = material.defines;
            var vertexShader = shader.vertexShader;
            var fragmentShader = shader.fragmentShader;
            var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
            if (parameters.shadowMapType === THREE.PCFShadowMap) {
                shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
            }
            else if (parameters.shadowMapType === THREE.PCFSoftShadowMap) {
                shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
            }
            var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
            var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
            var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
            this.setMapParameter(parameters, material, envMapTypeDefine, envMapModeDefine, envMapBlendingDefine);
            var gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;
            var customExtensions = generateExtensions(material.extensions, parameters, extensions);
            var customDefines = generateDefines(defines);
            //创建program
            var program = gl.createProgram();
            this.program = program;
            var prefixVertex;
            var prefixFragment;
            if (material.isRawShaderMaterial) {
                prefixVertex = this.rawMaterialPrefixVertex(customDefines);
                prefixFragment = this.rawMaterialPrefixFragment(customExtensions, customDefines);
            }
            else {
                prefixVertex = this.prefixVertex(parameters, shader, customDefines, gammaFactorDefine, envMapModeDefine, shadowMapTypeDefine, extensions);
                prefixFragment = this.prefixFragment(customExtensions, material, parameters, shader, customDefines, gammaFactorDefine, extensions, envMapTypeDefine, envMapModeDefine, envMapBlendingDefine, shadowMapTypeDefine);
            }
            vertexShader = parseIncludes(vertexShader);
            vertexShader = replaceLightNums(vertexShader, parameters);
            vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
            fragmentShader = parseIncludes(fragmentShader);
            fragmentShader = replaceLightNums(fragmentShader, parameters);
            fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
            vertexShader = unrollLoops(vertexShader);
            fragmentShader = unrollLoops(fragmentShader);
            var vertexGlsl = prefixVertex + vertexShader;
            var fragmentGlsl = prefixFragment + fragmentShader;
            // console.log( '*VERTEX*', vertexGlsl );
            // console.log( '*FRAGMENT*', fragmentGlsl );
            var glVertexShader = THREE.webGLCreateShader(gl, gl.VERTEX_SHADER, vertexGlsl);
            var glFragmentShader = THREE.webGLCreateShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
            this.vertexShader = glVertexShader;
            this.fragmentShader = glFragmentShader;
            gl.attachShader(program, glVertexShader);
            gl.attachShader(program, glFragmentShader);
            // Force a particular attribute to index 0.
            if (material.index0AttributeName !== undefined) {
                gl.bindAttribLocation(program, 0, material.index0AttributeName);
            }
            else if (parameters.morphTargets === true) {
                // programs with morphTargets displace position out of attribute 0
                gl.bindAttribLocation(program, 0, 'position');
            }
            gl.linkProgram(program);
            var programLog = gl.getProgramInfoLog(program).trim();
            var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
            var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
            var runnable = true;
            var haveDiagnostics = true;
            // console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
            // console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
            if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
                runnable = false;
                console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
            }
            else if (programLog !== '') {
                console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
            }
            else if (vertexLog === '' || fragmentLog === '') {
                haveDiagnostics = false;
            }
            if (haveDiagnostics) {
                this.diagnostics = {
                    runnable: runnable,
                    material: material,
                    programLog: programLog,
                    vertexShader: {
                        log: vertexLog,
                        prefix: prefixVertex
                    },
                    fragmentShader: {
                        log: fragmentLog,
                        prefix: prefixFragment
                    }
                };
            }
            // clean up
            gl.deleteShader(glVertexShader);
            gl.deleteShader(glFragmentShader);
            //
        }
        /**
         * 设置一些初始参数
         * @param parameters
         * @param material
         * @param envMapTypeDefine
         * @param envMapModeDefine
         * @param envMapBlendingDefine
         */
        setMapParameter(parameters, material, envMapTypeDefine, envMapModeDefine, envMapBlendingDefine) {
            if (parameters.envMap) {
                switch (material.envMap.mapping) {
                    case THREE.CubeReflectionMapping:
                    case THREE.CubeRefractionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                        break;
                    case THREE.CubeUVReflectionMapping:
                    case THREE.CubeUVRefractionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                        break;
                    case THREE.EquirectangularReflectionMapping:
                    case THREE.EquirectangularRefractionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                        break;
                    case THREE.SphericalReflectionMapping:
                        envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
                        break;
                }
                switch (material.envMap.mapping) {
                    case THREE.CubeRefractionMapping:
                    case THREE.EquirectangularRefractionMapping:
                        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                        break;
                }
                switch (material.combine) {
                    case THREE.MultiplyOperation:
                        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                        break;
                    case THREE.MixOperation:
                        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                        break;
                    case THREE.AddOperation:
                        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                        break;
                }
            }
        }
        /**
         * 原始材料的shader头处理
         * @param customDefines
         */
        rawMaterialPrefixVertex(customDefines) {
            var prefixVertex = [
                customDefines
            ].filter(filterEmptyLine).join('\n');
            if (prefixVertex.length > 0) {
                prefixVertex += '\n';
            }
            return prefixVertex;
        }
        /**
   * 原始材料的shader头处理
   * @param customDefines
   */
        rawMaterialPrefixFragment(customExtensions, customDefines) {
            var prefixFragment = [
                customExtensions,
                customDefines
            ].filter(filterEmptyLine).join('\n');
            if (prefixFragment.length > 0) {
                prefixFragment += '\n';
            }
            return prefixFragment;
        }
        /**
         * 顶点shader头的处理
         * @param parameters
         * @param shader
         * @param customDefines
         * @param gammaFactorDefine
         * @param envMapModeDefine
         * @param shadowMapTypeDefine
         * @param extensions
         */
        prefixVertex(parameters, shader, customDefines, gammaFactorDefine, envMapModeDefine, shadowMapTypeDefine, extensions) {
            var result = [
                'precision ' + parameters.precision + ' float;',
                'precision ' + parameters.precision + ' int;',
                '#define SHADER_NAME ' + shader.name,
                customDefines,
                parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,
                '#define MAX_BONES ' + parameters.maxBones,
                (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
                (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '',
                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',
                parameters.flatShading ? '#define FLAT_SHADED' : '',
                parameters.skinning ? '#define USE_SKINNING' : '',
                parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
                parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
                parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',
                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform mat4 viewMatrix;',
                'uniform mat3 normalMatrix;',
                'uniform vec3 cameraPosition;',
                'attribute vec3 position;',
                'attribute vec3 normal;',
                'attribute vec2 uv;',
                '#ifdef USE_COLOR',
                '	attribute vec3 color;',
                '#endif',
                '#ifdef USE_MORPHTARGETS',
                '	attribute vec3 morphTarget0;',
                '	attribute vec3 morphTarget1;',
                '	attribute vec3 morphTarget2;',
                '	attribute vec3 morphTarget3;',
                '	#ifdef USE_MORPHNORMALS',
                '		attribute vec3 morphNormal0;',
                '		attribute vec3 morphNormal1;',
                '		attribute vec3 morphNormal2;',
                '		attribute vec3 morphNormal3;',
                '	#else',
                '		attribute vec3 morphTarget4;',
                '		attribute vec3 morphTarget5;',
                '		attribute vec3 morphTarget6;',
                '		attribute vec3 morphTarget7;',
                '	#endif',
                '#endif',
                '#ifdef USE_SKINNING',
                '	attribute vec4 skinIndex;',
                '	attribute vec4 skinWeight;',
                '#endif',
                '\n'
            ].filter(filterEmptyLine).join('\n');
            return result;
        }
        /**
         * 片元shader头的处理
         * @param customExtensions
         * @param material
         * @param parameters
         * @param shader
         * @param customDefines
         * @param gammaFactorDefine
         * @param extensions
         * @param envMapTypeDefine
         * @param envMapModeDefine
         * @param envMapBlendingDefine
         * @param shadowMapTypeDefine
         */
        prefixFragment(customExtensions, material, parameters, shader, customDefines, gammaFactorDefine, extensions, envMapTypeDefine, envMapModeDefine, envMapBlendingDefine, shadowMapTypeDefine) {
            var result = [
                customExtensions,
                'precision ' + parameters.precision + ' float;',
                'precision ' + parameters.precision + ' int;',
                '#define SHADER_NAME ' + shader.name,
                customDefines,
                parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,
                (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
                (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '',
                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapTypeDefine : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.envMap ? '#define ' + envMapBlendingDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',
                parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
                parameters.flatShading ? '#define FLAT_SHADED' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',
                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
                parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',
                parameters.envMap && extensions.get('EXT_shader_texture_lod') ? '#define TEXTURE_LOD_EXT' : '',
                'uniform mat4 viewMatrix;',
                'uniform vec3 cameraPosition;',
                (parameters.toneMapping !== THREE.NoToneMapping) ? '#define TONE_MAPPING' : '',
                (parameters.toneMapping !== THREE.NoToneMapping) ? THREE.ShaderChunk['tonemapping_pars_fragment'] : '',
                (parameters.toneMapping !== THREE.NoToneMapping) ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',
                parameters.dithering ? '#define DITHERING' : '',
                (parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding) ? THREE.ShaderChunk['encodings_pars_fragment'] : '',
                parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
                parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
                parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
                parameters.outputEncoding ? getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding) : '',
                parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',
                '\n'
            ].filter(filterEmptyLine).join('\n');
            return result;
        }
        /**
         * 获取当前shader的uniforms参数列表，带addr信息
         */
        getUniforms() {
            if (this.cachedUniforms === undefined) {
                this.cachedUniforms = new THREE.WebGLUniformsNode(this.gl, this.program, this.renderer);
            }
            return this.cachedUniforms;
        }
        ;
        // set up caching for attribute locations
        /**
         * 获取当前shader的attribute信息列表，带addr信息
         */
        getAttributes() {
            if (this.cachedAttributes === undefined) {
                this.cachedAttributes = fetchAttributeLocations(this.gl, this.program);
            }
            return this.cachedAttributes;
        }
        ;
        // free resource
        /**
         * 删除当前program
         */
        destroy() {
            this.gl.deleteProgram(this.program);
            this.program = undefined;
        }
        ;
        /**
         * 缓存uniform
         */
        get uniforms() {
            console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
            return this.getUniforms();
        }
        /**
         * 缓存attribute
        */
        get attributes() {
            console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
            return this.getAttributes();
        }
    }
    THREE.WebGLProgramNode = WebGLProgramNode;
    /**
     * 一个shader的存储内容
     */
    class WebGLShaderItem {
        constructor() {
        }
    }
    THREE.WebGLShaderItem = WebGLShaderItem;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class MaterialShaderEnum {
    }
    MaterialShaderEnum.MeshDepthMaterial = 'depth';
    MaterialShaderEnum.MeshDistanceMaterial = 'distanceRGBA';
    MaterialShaderEnum.MeshNormalMaterial = 'normal';
    MaterialShaderEnum.MeshBasicMaterial = 'basic';
    MaterialShaderEnum.MeshLambertMaterial = 'lambert';
    MaterialShaderEnum.MeshPhongMaterial = 'phong';
    MaterialShaderEnum.MeshToonMaterial = 'phong';
    MaterialShaderEnum.MeshStandardMaterial = 'physical';
    MaterialShaderEnum.MeshPhysicalMaterial = 'physical';
    MaterialShaderEnum.LineBasicMaterial = 'basic';
    MaterialShaderEnum.LineDashedMaterial = 'dashed';
    MaterialShaderEnum.PointsMaterial = 'points';
    MaterialShaderEnum.ShadowMaterial = 'shadow';
    THREE.MaterialShaderEnum = MaterialShaderEnum;
    class WebGLProgramsNode {
        constructor(renderer, extensions, capabilities) {
            this.programs = new Array();
            this.renderer = renderer;
            this.extensions = extensions;
            this.capabilities = capabilities;
            this.shaderIDs = MaterialShaderEnum;
            // this.shaderIDs = {
            //    MeshDepthMaterial: 'depth',
            //    MeshDistanceMaterial: 'distanceRGBA',
            //    MeshNormalMaterial: 'normal',
            //    MeshBasicMaterial: 'basic',
            //    MeshLambertMaterial: 'lambert',
            //    MeshPhongMaterial: 'phong',
            //    MeshToonMaterial: 'phong',
            //    MeshStandardMaterial: 'physical',
            //    MeshPhysicalMaterial: 'physical',
            //    LineBasicMaterial: 'basic',
            //    LineDashedMaterial: 'dashed',
            //    PointsMaterial: 'points',
            //    ShadowMaterial: 'shadow'
            // };
            this.parameterNames = [
                "precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
                "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
                "roughnessMap", "metalnessMap", "gradientMap",
                "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
                "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
                "maxBones", "useVertexTexture", "morphTargets", "morphNormals",
                "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
                "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
                "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
                "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
            ];
        }
        ;
        allocateBones(object) {
            var skeleton = object.skeleton;
            var bones = skeleton.bones;
            if (this.capabilities.floatVertexTextures) {
                return 1024;
            }
            else {
                var nVertexUniforms = this.capabilities.maxVertexUniforms;
                var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
                var maxBones = Math.min(nVertexMatrices, bones.length);
                if (maxBones < bones.length) {
                    console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                    return 0;
                }
                return maxBones;
            }
        }
        getTextureEncodingFromMap(map, gammaOverrideLinear) {
            var encoding;
            if (!map) {
                encoding = THREE.LinearEncoding;
            }
            else if (map.isTexture) {
                encoding = map.encoding;
            }
            else if (map.isWebGLRenderTarget) {
                console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
                encoding = map.texture.encoding;
            }
            // add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
            if (encoding === THREE.LinearEncoding && gammaOverrideLinear) {
                encoding = THREE.GammaEncoding;
            }
            return encoding;
        }
        /**
         * // material 的配置参数，用来配置program的vertex 和fragment 元的shander内容
         * @param material
         * @param lights
         * @param shadows
         * @param fog
         * @param nClipPlanes
         * @param nClipIntersection
         * @param object
         */
        getParameters(material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {
            var shaderID = this.shaderIDs[material.type];
            // heuristics to create shader parameters according to lights in the scene
            // (not to blow over maxLights budget)
            var maxBones = object.isSkinnedMesh ? this.allocateBones(object) : 0;
            var precision = this.capabilities.precision;
            if (material.precision !== null) {
                precision = this.capabilities.getMaxPrecision(material.precision);
                if (precision !== material.precision) {
                    console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
                }
            }
            var currentRenderTarget = this.renderer.getRenderTarget();
            // material 的配置参数，用来配置program的vertex 和fragment 元的shander内容
            var parameters = {
                shaderID: shaderID,
                precision: precision,
                supportsVertexTextures: this.capabilities.vertexTextures,
                outputEncoding: this.getTextureEncodingFromMap((!currentRenderTarget) ? null : currentRenderTarget.texture, this.renderer.gammaOutput),
                map: !!material.map,
                mapEncoding: this.getTextureEncodingFromMap(material.map, this.renderer.gammaInput),
                envMap: !!material.envMap,
                envMapMode: material.envMap && material.envMap.mapping,
                envMapEncoding: this.getTextureEncodingFromMap(material.envMap, this.renderer.gammaInput),
                envMapCubeUV: (!!material.envMap) && ((material.envMap.mapping === THREE.CubeUVReflectionMapping) || (material.envMap.mapping === THREE.CubeUVRefractionMapping)),
                lightMap: !!material.lightMap,
                aoMap: !!material.aoMap,
                emissiveMap: !!material.emissiveMap,
                emissiveMapEncoding: this.getTextureEncodingFromMap(material.emissiveMap, this.renderer.gammaInput),
                bumpMap: !!material.bumpMap,
                normalMap: !!material.normalMap,
                displacementMap: !!material.displacementMap,
                roughnessMap: !!material.roughnessMap,
                metalnessMap: !!material.metalnessMap,
                specularMap: !!material.specularMap,
                alphaMap: !!material.alphaMap,
                gradientMap: !!material.gradientMap,
                combine: material.combine,
                vertexColors: material.vertexColors,
                fog: !!fog,
                useFog: material.fog,
                fogExp: (fog && fog.isFogExp2),
                flatShading: material.flatShading,
                sizeAttenuation: material.sizeAttenuation,
                logarithmicDepthBuffer: this.capabilities.logarithmicDepthBuffer,
                skinning: material.skinning && maxBones > 0,
                maxBones: maxBones,
                useVertexTexture: this.capabilities.floatVertexTextures,
                morphTargets: material.morphTargets,
                morphNormals: material.morphNormals,
                maxMorphTargets: this.renderer.maxMorphTargets,
                maxMorphNormals: this.renderer.maxMorphNormals,
                numDirLights: lights.directional.length,
                numPointLights: lights.point.length,
                numSpotLights: lights.spot.length,
                numRectAreaLights: lights.rectArea.length,
                numHemiLights: lights.hemi.length,
                numClippingPlanes: nClipPlanes,
                numClipIntersection: nClipIntersection,
                dithering: material.dithering,
                shadowMapEnabled: this.renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
                shadowMapType: this.renderer.shadowMap.type,
                toneMapping: this.renderer.toneMapping,
                physicallyCorrectLights: this.renderer.physicallyCorrectLights,
                premultipliedAlpha: material.premultipliedAlpha,
                alphaTest: material.alphaTest,
                doubleSided: material.side === THREE.DoubleSide,
                flipSided: material.side === THREE.BackSide,
                depthPacking: (material.depthPacking !== undefined) ? material.depthPacking : false
            };
            return parameters;
        }
        ;
        /**
         * 根据配置参数 顺序连接形成program的标识字符串
         * @param material
         * @param parameters
         */
        getProgramCode(material, parameters) {
            var array = [];
            if (parameters.shaderID) {
                array.push(parameters.shaderID);
            }
            else {
                array.push(material.fragmentShader);
                array.push(material.vertexShader);
            }
            if (material.defines !== undefined) {
                for (var name in material.defines) {
                    array.push(name);
                    array.push(material.defines[name]);
                }
            }
            for (var i = 0; i < this.parameterNames.length; i++) {
                array.push(parameters[this.parameterNames[i]]);
            }
            array.push(material.onBeforeCompile.toString());
            array.push(this.renderer.gammaOutput);
            return array.join();
        }
        ;
        /**
         * 根据唯一标识符code 得到program
         * @param material
         * @param shader
         * @param parameters
         * @param code program 唯一标识符
         */
        acquireProgram(material, shader, parameters, code) {
            var program;
            // Check if code has been already compiled
            for (var p = 0, pl = this.programs.length; p < pl; p++) {
                var programInfo = this.programs[p];
                if (programInfo.code === code) {
                    program = programInfo;
                    ++program.usedTimes;
                    break;
                }
            }
            if (program === undefined) {
                program = new THREE.WebGLProgramNode(this.renderer, this.extensions, code, material, shader, parameters);
                this.programs.push(program);
            }
            return program;
        }
        ;
        releaseProgram(program) {
            if (--program.usedTimes === 0) {
                // Remove from unordered set
                var i = this.programs.indexOf(program);
                this.programs[i] = this.programs[this.programs.length - 1];
                this.programs.pop();
                // Free WebGL resources
                program.destroy();
            }
        }
        ;
    }
    THREE.WebGLProgramsNode = WebGLProgramsNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLPropertyNode {
        constructor() {
        }
    }
    THREE.WebGLPropertyNode = WebGLPropertyNode;
    class WebGLPropertiesNode {
        constructor() {
            this.properties = new WeakMap();
        }
        get(material) {
            var map = this.properties.get(material);
            if (map === undefined) {
                map = new WebGLPropertyNode();
                this.properties.set(material, map);
            }
            return map;
        }
        remove(material) {
            this.properties.delete(material);
        }
        update(material, key, value) {
            this.properties.get(material)[key] = value;
        }
        dispose() {
            this.properties = new WeakMap();
        }
    }
    THREE.WebGLPropertiesNode = WebGLPropertiesNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    function painterSortStable(a, b) {
        if (a.renderOrder !== b.renderOrder) {
            return a.renderOrder - b.renderOrder;
        }
        else if (a.program && b.program && a.program !== b.program) {
            return a.program.id - b.program.id;
        }
        else if (a.material.id !== b.material.id) {
            return a.material.id - b.material.id;
        }
        else if (a.z !== b.z) {
            return a.z - b.z;
        }
        else {
            return a.id - b.id;
        }
    }
    function reversePainterSortStable(a, b) {
        if (a.renderOrder !== b.renderOrder) {
            return a.renderOrder - b.renderOrder;
        }
        if (a.z !== b.z) {
            return b.z - a.z;
        }
        else {
            return a.id - b.id;
        }
    }
    /**
     * 渲染数据单元
     */
    class RenderItem {
        constructor() {
        }
    }
    THREE.RenderItem = RenderItem;
    /**
     * 渲染对象列表
     */
    class WebGLRenderListNode {
        constructor() {
            this.renderItems = [];
            this.renderItemsIndex = 0;
            this.opaque = [];
            this.transparent = [];
        }
        init() {
            this.renderItemsIndex = 0;
            this.opaque.length = 0;
            this.transparent.length = 0;
        }
        /**
         * 存入值
         * @param object
         * @param geometry
         * @param material
         * @param z
         * @param group
         */
        push(object, geometry, material, z, group) {
            var renderItem = this.renderItems[this.renderItemsIndex];
            if (renderItem === undefined) {
                renderItem = new RenderItem();
                renderItem = {
                    id: object.id,
                    object: object,
                    geometry: geometry,
                    material: material,
                    program: material.program,
                    renderOrder: object.renderOrder,
                    z: z,
                    group: group
                };
                this.renderItems[this.renderItemsIndex] = renderItem;
            }
            else {
                renderItem.id = object.id;
                renderItem.object = object;
                renderItem.geometry = geometry;
                renderItem.material = material;
                renderItem.program = material.program;
                renderItem.renderOrder = object.renderOrder;
                renderItem.z = z;
                renderItem.group = group;
            }
            (material.transparent === true ? this.transparent : this.opaque).push(renderItem);
            this.renderItemsIndex++;
        }
        /**
         * 排序
         */
        sort() {
            if (this.opaque.length > 1)
                this.opaque.sort(painterSortStable);
            if (this.transparent.length > 1)
                this.transparent.sort(reversePainterSortStable);
        }
    }
    THREE.WebGLRenderListNode = WebGLRenderListNode;
    /**
     * renderlist 的列表
     */
    class WebGLRenderListsNode {
        constructor() {
            this.lists = {};
        }
        get(scene, camera) {
            var hash = scene.id + ',' + camera.id;
            var list = this.lists[hash];
            if (list === undefined) {
                // console.log( 'THREE.WebGLRenderLists:', hash );
                list = new WebGLRenderListNode();
                this.lists[hash] = list;
            }
            return list;
        }
        dispose() {
            this.lists = {};
        }
    }
    THREE.WebGLRenderListsNode = WebGLRenderListsNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLRenderStateNode {
        constructor() {
            this.lights = new THREE.WebGLLightsNode();
            this.lightsArray = [];
            this.shadowsArray = [];
            this.spritesArray = [];
            this.state = {
                lightsArray: this.lightsArray,
                shadowsArray: this.shadowsArray,
                spritesArray: this.spritesArray,
                lights: this.lights
            };
        }
        init() {
            this.lightsArray.length = 0;
            this.shadowsArray.length = 0;
            this.spritesArray.length = 0;
        }
        pushLight(light) {
            this.lightsArray.push(light);
        }
        pushShadow(shadowLight) {
            this.shadowsArray.push(shadowLight);
        }
        pushSprite(shadowLight) {
            this.spritesArray.push(shadowLight);
        }
        setupLights(camera) {
            this.lights.setup(this.lightsArray, this.shadowsArray, camera);
        }
    }
    THREE.WebGLRenderStateNode = WebGLRenderStateNode;
    class WebGLRenderStates {
        constructor() {
            this.renderStates = {};
        }
        get(scene, camera) {
            var hash = scene.id + ',' + camera.id;
            var renderState = this.renderStates[hash];
            if (renderState === undefined) {
                renderState = new WebGLRenderStateNode();
                this.renderStates[hash] = renderState;
            }
            return renderState;
        }
        dispose() {
            this.renderStates = {};
        }
    }
    THREE.WebGLRenderStates = WebGLRenderStates;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLShadowMapNode {
        constructor(_renderer, _objects, maxTextureSize) {
            this.enabled = false;
            this.autoUpdate = true;
            this.needsUpdate = false;
            this.type = THREE.PCFShadowMap;
            this._renderer = _renderer;
            this._objects = _objects;
            this.maxTextureSize = maxTextureSize;
            this._frustum = new THREE.Frustum();
            this._projScreenMatrix = new THREE.Matrix4();
            this._shadowMapSize = new THREE.Vector2();
            this._maxShadowMapSize = new THREE.Vector2(maxTextureSize, maxTextureSize);
            this._lookTarget = new THREE.Vector3();
            this._lightPositionWorld = new THREE.Vector3();
            this._MorphingFlag = 1;
            this._SkinningFlag = 2;
            this._NumberOfMaterialVariants = (this._MorphingFlag | this._SkinningFlag) + 1;
            this._depthMaterials = new Array(this._NumberOfMaterialVariants);
            this._distanceMaterials = new Array(this._NumberOfMaterialVariants);
            this._materialCache = {};
            this.shadowSide = { 0: THREE.BackSide, 1: THREE.FrontSide, 2: THREE.DoubleSide };
            this.cubeDirections = [
                new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0)
            ];
            this.cubeUps = [
                new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0),
                new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)
            ];
            this.cube2DViewPorts = [
                new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),
                new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()
            ];
            // init
            for (var i = 0; i !== this._NumberOfMaterialVariants; ++i) {
                var useMorphing = (i & this._MorphingFlag) !== 0;
                var useSkinning = (i & this._SkinningFlag) !== 0;
                var depthMaterial = new THREE.MeshDepthMaterial({
                    depthPacking: THREE.RGBADepthPacking,
                    morphTargets: useMorphing,
                    skinning: useSkinning
                });
                this._depthMaterials[i] = depthMaterial;
                //
                var distanceMaterial = new THREE.MeshDistanceMaterial({
                    morphTargets: useMorphing,
                    skinning: useSkinning
                });
                this._distanceMaterials[i] = distanceMaterial;
            }
            this.enabled = false;
            this.autoUpdate = true;
            this.needsUpdate = false;
            this.type = THREE.PCFShadowMap;
        }
        render(lights, scene, camera) {
            if (this.enabled === false)
                return;
            if (this.autoUpdate === false && this.needsUpdate === false)
                return;
            if (lights.length === 0)
                return;
            // TODO Clean up (needed in case of contextlost)
            var _gl = this._renderer.context;
            var _state = this._renderer.state;
            // Set GL state for depth map.
            _state.disable(_gl.BLEND);
            _state.buffers.color.setClear(1, 1, 1, 1);
            _state.buffers.depth.setTest(true);
            _state.setScissorTest(false);
            // render depth map
            var faceCount;
            for (var i = 0, il = lights.length; i < il; i++) {
                var light = lights[i];
                var shadow = light.shadow;
                var isPointLight = light && light.isPointLight;
                if (shadow === undefined) {
                    console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                    continue;
                }
                var shadowCamera = shadow.camera;
                this._shadowMapSize.copy(shadow.mapSize);
                this._shadowMapSize.min(this._maxShadowMapSize);
                if (isPointLight) {
                    var vpWidth = this._shadowMapSize.x;
                    var vpHeight = this._shadowMapSize.y;
                    // These viewports map a cube-map onto a 2D texture with the
                    // following orientation:
                    //
                    //  xzXZ
                    //   y Y
                    //
                    // X - Positive x direction
                    // x - Negative x direction
                    // Y - Positive y direction
                    // y - Negative y direction
                    // Z - Positive z direction
                    // z - Negative z direction
                    // positive X
                    this.cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
                    // negative X
                    this.cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
                    // positive Z
                    this.cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
                    // negative Z
                    this.cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
                    // positive Y
                    this.cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
                    // negative Y
                    this.cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
                    this._shadowMapSize.x *= 4.0;
                    this._shadowMapSize.y *= 2.0;
                }
                if (shadow.map === null) {
                    var pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };
                    shadow.map = new THREE.WebGLRenderTarget(this._shadowMapSize.x, this._shadowMapSize.y, pars);
                    shadow.map.texture.name = light.name + ".shadowMap";
                    shadowCamera.updateProjectionMatrix();
                }
                if (shadow.isSpotLightShadow) {
                    shadow.update(light);
                }
                var shadowMap = shadow.map;
                var shadowMatrix = shadow.matrix;
                this._lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
                shadowCamera.position.copy(this._lightPositionWorld);
                if (isPointLight) {
                    faceCount = 6;
                    // for point lights we set the shadow matrix to be a translation-only matrix
                    // equal to inverse of the light's position
                    shadowMatrix.makeTranslation(-this._lightPositionWorld.x, -this._lightPositionWorld.y, -this._lightPositionWorld.z);
                }
                else {
                    faceCount = 1;
                    this._lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                    shadowCamera.lookAt(this._lookTarget);
                    shadowCamera.updateMatrixWorld();
                    // compute shadow matrix
                    shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
                    shadowMatrix.multiply(shadowCamera.projectionMatrix);
                    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
                }
                this._renderer.setRenderTarget(shadowMap);
                this._renderer.clear();
                // render shadow map for each cube face (if omni-directional) or
                // run a single pass if not
                for (var face = 0; face < faceCount; face++) {
                    if (isPointLight) {
                        this._lookTarget.copy(shadowCamera.position);
                        this._lookTarget.add(this.cubeDirections[face]);
                        shadowCamera.up.copy(this.cubeUps[face]);
                        shadowCamera.lookAt(this._lookTarget);
                        shadowCamera.updateMatrixWorld();
                        var vpDimensions = this.cube2DViewPorts[face];
                        _state.viewport(vpDimensions);
                    }
                    // update camera matrices and frustum
                    this._projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
                    this._frustum.setFromMatrix(this._projScreenMatrix);
                    // set object matrices & frustum culling
                    this.renderObject(scene, camera, shadowCamera, isPointLight);
                }
            }
            this.needsUpdate = false;
        }
        ;
        getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {
            var geometry = object.geometry;
            var result = null;
            var materialVariants = this._depthMaterials;
            var customMaterial = object.customDepthMaterial;
            if (isPointLight) {
                materialVariants = this._distanceMaterials;
                customMaterial = object.customDistanceMaterial;
            }
            if (!customMaterial) {
                var useMorphing = false;
                if (material.morphTargets) {
                    if (geometry && geometry.isBufferGeometry) {
                        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
                    }
                    else if (geometry && geometry.isGeometry) {
                        useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
                    }
                }
                if (object.isSkinnedMesh && material.skinning === false) {
                    console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
                }
                var useSkinning = object.isSkinnedMesh && material.skinning;
                var variantIndex = 0;
                if (useMorphing)
                    variantIndex |= this._MorphingFlag;
                if (useSkinning)
                    variantIndex |= this._SkinningFlag;
                result = materialVariants[variantIndex];
            }
            else {
                result = customMaterial;
            }
            if (this._renderer.localClippingEnabled &&
                material.clipShadows === true &&
                material.clippingPlanes.length !== 0) {
                // in this case we need a unique material instance reflecting the
                // appropriate state
                var keyA = result.uuid, keyB = material.uuid;
                var materialsForVariant = this._materialCache[keyA];
                if (materialsForVariant === undefined) {
                    materialsForVariant = {};
                    this._materialCache[keyA] = materialsForVariant;
                }
                var cachedMaterial = materialsForVariant[keyB];
                if (cachedMaterial === undefined) {
                    cachedMaterial = result.clone();
                    materialsForVariant[keyB] = cachedMaterial;
                }
                result = cachedMaterial;
            }
            result.visible = material.visible;
            result.wireframe = material.wireframe;
            result.side = (material.shadowSide != null) ? material.shadowSide : this.shadowSide[material.side];
            result.clipShadows = material.clipShadows;
            result.clippingPlanes = material.clippingPlanes;
            result.clipIntersection = material.clipIntersection;
            result.wireframeLinewidth = material.wireframeLinewidth;
            result.linewidth = material.linewidth;
            if (isPointLight && result.isMeshDistanceMaterial) {
                result.referencePosition.copy(lightPositionWorld);
                result.nearDistance = shadowCameraNear;
                result.farDistance = shadowCameraFar;
            }
            return result;
        }
        renderObject(object, camera, shadowCamera, isPointLight) {
            if (object.visible === false)
                return;
            var visible = object.layers.test(camera.layers);
            if (visible && (object.isMesh || object.isLine || object.isPoints)) {
                if (object.castShadow && (!object.frustumCulled || this._frustum.intersectsObject(object))) {
                    object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                    var geometry = this._objects.update(object);
                    var material = object.material;
                    if (Array.isArray(material)) {
                        var groups = geometry.groups;
                        for (var k = 0, kl = groups.length; k < kl; k++) {
                            var group = groups[k];
                            var groupMaterial = material[group.materialIndex];
                            if (groupMaterial && groupMaterial.visible) {
                                var depthMaterial = this.getDepthMaterial(object, groupMaterial, isPointLight, this._lightPositionWorld, shadowCamera.near, shadowCamera.far);
                                this._renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                            }
                        }
                    }
                    else if (material.visible) {
                        var depthMaterial = this.getDepthMaterial(object, material, isPointLight, this._lightPositionWorld, shadowCamera.near, shadowCamera.far);
                        this._renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                    }
                }
            }
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                this.renderObject(children[i], camera, shadowCamera, isPointLight);
            }
        }
    }
    THREE.WebGLShadowMapNode = WebGLShadowMapNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLSpriteRendererNode {
        constructor(renderer, gl, state, textures, capabilities) {
            this.renderer = renderer;
            this.gl = gl;
            this.state = state;
            this.textures = textures;
            this.capabilities = capabilities;
            this.spritePosition = new THREE.Vector3();
            this.spriteRotation = new THREE.Quaternion();
            this.spriteScale = new THREE.Vector3();
        }
        init() {
            var vertices = new Float32Array([
                -0.5, -0.5, 0, 0,
                0.5, -0.5, 1, 0,
                0.5, 0.5, 1, 1,
                -0.5, 0.5, 0, 1
            ]);
            var faces = new Uint16Array([
                0, 1, 2,
                0, 2, 3
            ]);
            this.vertexBuffer = this.gl.createBuffer();
            this.elementBuffer = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
            this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, faces, this.gl.STATIC_DRAW);
            this.program = this.createProgram();
            this.attributes = {
                position: this.gl.getAttribLocation(this.program, 'position'),
                uv: this.gl.getAttribLocation(this.program, 'uv')
            };
            var gl = this.gl;
            var program = this.program;
            this.uniforms = {
                uvOffset: this.gl.getUniformLocation(this.program, 'uvOffset'),
                uvScale: this.gl.getUniformLocation(this.program, 'uvScale'),
                rotation: this.gl.getUniformLocation(program, 'rotation'),
                center: gl.getUniformLocation(program, 'center'),
                scale: gl.getUniformLocation(program, 'scale'),
                color: gl.getUniformLocation(program, 'color'),
                map: gl.getUniformLocation(program, 'map'),
                opacity: gl.getUniformLocation(program, 'opacity'),
                modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
                projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
                fogType: gl.getUniformLocation(program, 'fogType'),
                fogDensity: gl.getUniformLocation(program, 'fogDensity'),
                fogNear: gl.getUniformLocation(program, 'fogNear'),
                fogFar: gl.getUniformLocation(program, 'fogFar'),
                fogColor: gl.getUniformLocation(program, 'fogColor'),
                fogDepth: gl.getUniformLocation(program, 'fogDepth'),
                alphaTest: gl.getUniformLocation(program, 'alphaTest')
            };
            var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            canvas.width = 8;
            canvas.height = 8;
            var context = canvas.getContext('2d');
            context.fillStyle = 'white';
            context.fillRect(0, 0, 8, 8);
            this.texture = new THREE.CanvasTexture(canvas);
        }
        render(sprites, scene, camera) {
            var state = this.state;
            if (sprites.length === 0)
                return;
            // setup gl
            if (this.program === undefined) {
                this.init();
            }
            var program = this.program;
            var attributes = this.attributes;
            var gl = this.gl;
            var uniforms = this.uniforms;
            state.useProgram(program);
            state.initAttributes();
            state.enableAttribute(attributes.position);
            state.enableAttribute(attributes.uv);
            state.disableUnusedAttributes();
            state.disable(gl.CULL_FACE);
            state.enable(gl.BLEND);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
            gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
            gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
            state.activeTexture(gl.TEXTURE0);
            gl.uniform1i(uniforms.map, 0);
            var oldFogType = 0;
            var sceneFogType = 0;
            var fog = scene.fog;
            if (fog) {
                gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
                if (fog.isFog) {
                    gl.uniform1f(uniforms.fogNear, fog.near);
                    gl.uniform1f(uniforms.fogFar, fog.far);
                    gl.uniform1i(uniforms.fogType, 1);
                    oldFogType = 1;
                    sceneFogType = 1;
                }
                else if (fog.isFogExp2) {
                    gl.uniform1f(uniforms.fogDensity, fog.density);
                    gl.uniform1i(uniforms.fogType, 2);
                    oldFogType = 2;
                    sceneFogType = 2;
                }
            }
            else {
                gl.uniform1i(uniforms.fogType, 0);
                oldFogType = 0;
                sceneFogType = 0;
            }
            // update positions and sort
            for (var i = 0, l = sprites.length; i < l; i++) {
                var sprite = sprites[i];
                sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
                sprite.z = -sprite.modelViewMatrix.elements[14];
            }
            sprites.sort(this.painterSortStable);
            // render all sprites
            var scale = [];
            var center = [];
            for (var i = 0, l = sprites.length; i < l; i++) {
                var sprite = sprites[i];
                var material = sprite.material;
                if (material.visible === false)
                    continue;
                sprite.onBeforeRender(this.renderer, scene, camera, undefined, material, undefined);
                gl.uniform1f(uniforms.alphaTest, material.alphaTest);
                gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
                sprite.matrixWorld.decompose(this.spritePosition, this.spriteRotation, this.spriteScale);
                scale[0] = this.spriteScale.x;
                scale[1] = this.spriteScale.y;
                center[0] = sprite.center.x - 0.5;
                center[1] = sprite.center.y - 0.5;
                var fogType = 0;
                if (scene.fog && material.fog) {
                    fogType = sceneFogType;
                }
                if (oldFogType !== fogType) {
                    gl.uniform1i(uniforms.fogType, fogType);
                    oldFogType = fogType;
                }
                if (material.map !== null) {
                    gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
                    gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
                }
                else {
                    gl.uniform2f(uniforms.uvOffset, 0, 0);
                    gl.uniform2f(uniforms.uvScale, 1, 1);
                }
                gl.uniform1f(uniforms.opacity, material.opacity);
                gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
                gl.uniform1f(uniforms.rotation, material.rotation);
                gl.uniform2fv(uniforms.center, center);
                gl.uniform2fv(uniforms.scale, scale);
                state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
                state.buffers.depth.setTest(material.depthTest);
                state.buffers.depth.setMask(material.depthWrite);
                state.buffers.color.setMask(material.colorWrite);
                this.textures.setTexture2D(material.map || this.texture, 0);
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                sprite.onAfterRender(this.renderer, scene, camera, undefined, material, undefined);
            }
            // restore gl
            state.enable(gl.CULL_FACE);
            state.reset();
        }
        ;
        createProgram() {
            var gl = this.gl;
            var program = gl.createProgram();
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(vertexShader, [
                'precision ' + this.capabilities.precision + ' float;',
                '#define SHADER_NAME ' + 'SpriteMaterial',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform float rotation;',
                'uniform vec2 center;',
                'uniform vec2 scale;',
                'uniform vec2 uvOffset;',
                'uniform vec2 uvScale;',
                'attribute vec2 position;',
                'attribute vec2 uv;',
                'varying vec2 vUV;',
                'varying float fogDepth;',
                'void main() {',
                '	vUV = uvOffset + uv * uvScale;',
                '	vec2 alignedPosition = ( position - center ) * scale;',
                '	vec2 rotatedPosition;',
                '	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
                '	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
                '	vec4 mvPosition;',
                '	mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
                '	mvPosition.xy += rotatedPosition;',
                '	gl_Position = projectionMatrix * mvPosition;',
                '	fogDepth = - mvPosition.z;',
                '}'
            ].join('\n'));
            gl.shaderSource(fragmentShader, [
                'precision ' + this.capabilities.precision + ' float;',
                '#define SHADER_NAME ' + 'SpriteMaterial',
                'uniform vec3 color;',
                'uniform sampler2D map;',
                'uniform float opacity;',
                'uniform int fogType;',
                'uniform vec3 fogColor;',
                'uniform float fogDensity;',
                'uniform float fogNear;',
                'uniform float fogFar;',
                'uniform float alphaTest;',
                'varying vec2 vUV;',
                'varying float fogDepth;',
                'void main() {',
                '	vec4 texture = texture2D( map, vUV );',
                '	gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
                '	if ( gl_FragColor.a < alphaTest ) discard;',
                '	if ( fogType > 0 ) {',
                '		float fogFactor = 0.0;',
                '		if ( fogType == 1 ) {',
                '			fogFactor = smoothstep( fogNear, fogFar, fogDepth );',
                '		} else {',
                '			const float LOG2 = 1.442695;',
                '			fogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );',
                '			fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
                '		}',
                '		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',
                '	}',
                '}'
            ].join('\n'));
            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            return program;
        }
        painterSortStable(a, b) {
            if (a.renderOrder !== b.renderOrder) {
                return a.renderOrder - b.renderOrder;
            }
            else if (a.z !== b.z) {
                return b.z - a.z;
            }
            else {
                return b.id - a.id;
            }
        }
    }
    THREE.WebGLSpriteRendererNode = WebGLSpriteRendererNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    /**
     * 颜色测试
     */
    class ColorBuffer {
        constructor(gl) {
            this.gl = gl;
            this.locked;
            this.color = new THREE.Vector4();
            this.currentColorMask;
            this.currentColorClear = new THREE.Vector4(0, 0, 0, 0);
        }
        setMask(colorMask) {
            if (this.currentColorMask !== colorMask && !this.locked) {
                this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                this.currentColorMask = colorMask;
            }
        }
        setLocked(lock) {
            this.locked = lock;
        }
        /**
         * 清除颜色缓存
         * @param r
         * @param g
         * @param b
         * @param a
         * @param premultipliedAlpha
         */
        setClear(r, g, b, a, premultipliedAlpha) {
            if (premultipliedAlpha === true) {
                r *= a;
                g *= a;
                b *= a;
            }
            this.color.set(r, g, b, a);
            if (this.currentColorClear.equals(this.color) === false) {
                this.gl.clearColor(r, g, b, a);
                this.currentColorClear.copy(this.color);
            }
        }
        reset() {
            this.locked = null;
            this.currentColorMask;
            this.currentColorClear.set(1, 0, 0, 0); // set to invalid state
        }
    }
    THREE.ColorBuffer = ColorBuffer;
    /**
     * 深度测试
     */
    class DepthBuffer {
        constructor(gl) {
            this.gl = gl;
            this.locked;
            this.currentDepthMask;
            this.currentDepthFunc;
            this.currentDepthClear;
        }
        setTest(depthTest) {
            var gl = this.gl;
            if (depthTest) {
                this.gl.enable(gl.DEPTH_TEST);
            }
            else {
                this.gl.disable(gl.DEPTH_TEST);
            }
        }
        setMask(depthMask) {
            if (this.currentDepthMask !== depthMask && !this.locked) {
                this.gl.depthMask(depthMask);
                this.currentDepthMask = depthMask;
            }
        }
        setFunc(depthFunc) {
            var gl = this.gl;
            if (this.currentDepthFunc !== depthFunc) {
                if (depthFunc) {
                    switch (depthFunc) {
                        case THREE.NeverDepth:
                            gl.depthFunc(gl.NEVER);
                            break;
                        case THREE.AlwaysDepth:
                            gl.depthFunc(gl.ALWAYS);
                            break;
                        case THREE.LessDepth:
                            gl.depthFunc(gl.LESS);
                            break;
                        case THREE.LessEqualDepth:
                            gl.depthFunc(gl.LEQUAL);
                            break;
                        case THREE.EqualDepth:
                            gl.depthFunc(gl.EQUAL);
                            break;
                        case THREE.GreaterEqualDepth:
                            gl.depthFunc(gl.GEQUAL);
                            break;
                        case THREE.GreaterDepth:
                            gl.depthFunc(gl.GREATER);
                            break;
                        case THREE.NotEqualDepth:
                            gl.depthFunc(gl.NOTEQUAL);
                            break;
                        default:
                            gl.depthFunc(gl.LEQUAL);
                    }
                }
                else {
                    gl.depthFunc(gl.LEQUAL);
                }
                this.currentDepthFunc = depthFunc;
            }
        }
        setLocked(lock) {
            this.locked = lock;
        }
        setClear(depth) {
            if (this.currentDepthClear !== depth) {
                this.gl.clearDepth(depth);
                this.currentDepthClear = depth;
            }
        }
        reset() {
            this.locked = null;
            this.currentDepthMask = null;
            this.currentDepthFunc = null;
            this.currentDepthClear = null;
        }
    }
    THREE.DepthBuffer = DepthBuffer;
    ;
    /**
     * 模板测试
     */
    class StencilBuffer {
        constructor(gl) {
            this.gl = gl;
            this.locked;
            this.currentStencilMask;
            this.currentStencilFunc;
            this.currentStencilRef;
            this.currentStencilFuncMask;
            this.currentStencilFail;
            this.currentStencilZFail;
            this.currentStencilZPass;
            this.currentStencilClear;
        }
        setTest(stencilTest) {
            var gl = this.gl;
            if (stencilTest) {
                gl.enable(gl.STENCIL_TEST);
            }
            else {
                gl.disable(gl.STENCIL_TEST);
            }
        }
        setMask(stencilMask) {
            if (this.currentStencilMask !== stencilMask && !this.locked) {
                this.gl.stencilMask(stencilMask);
                this.currentStencilMask = stencilMask;
            }
        }
        setFunc(stencilFunc, stencilRef, stencilMask) {
            if (this.currentStencilFunc !== stencilFunc ||
                this.currentStencilRef !== stencilRef ||
                this.currentStencilFuncMask !== stencilMask) {
                this.gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                this.currentStencilFunc = stencilFunc;
                this.currentStencilRef = stencilRef;
                this.currentStencilFuncMask = stencilMask;
            }
        }
        setOp(stencilFail, stencilZFail, stencilZPass) {
            if (this.currentStencilFail !== stencilFail ||
                this.currentStencilZFail !== stencilZFail ||
                this.currentStencilZPass !== stencilZPass) {
                this.gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                this.currentStencilFail = stencilFail;
                this.currentStencilZFail = stencilZFail;
                this.currentStencilZPass = stencilZPass;
            }
        }
        setLocked(lock) {
            this.locked = lock;
        }
        setClear(stencil) {
            if (this.currentStencilClear !== stencil) {
                this.gl.clearStencil(stencil);
                this.currentStencilClear = stencil;
            }
        }
        reset() {
            this.locked;
            this.currentStencilMask;
            this.currentStencilFunc;
            this.currentStencilRef;
            this.currentStencilFuncMask;
            this.currentStencilFail;
            this.currentStencilZFail;
            this.currentStencilZPass;
            this.currentStencilClear;
        }
    }
    THREE.StencilBuffer = StencilBuffer;
    /**
     * webgl 状态机管理器
     */
    class WebGLStateNode {
        constructor(gl, extensions, utils) {
            this.version = 0;
            this.gl = gl;
            this.extensions = extensions;
            this.utils = utils;
            var colorBuffer = this.colorBuffer = new ColorBuffer(gl);
            var depthBuffer = this.depthBuffer = new DepthBuffer(gl);
            var stencilBuffer = this.stencilBuffer = new StencilBuffer(gl);
            this.maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            this.newAttributes = new Uint8Array(this.maxVertexAttributes);
            this.enabledAttributes = new Uint8Array(this.maxVertexAttributes);
            this.attributeDivisors = new Uint8Array(this.maxVertexAttributes);
            this.capabilities = {};
            this.compressedTextureFormats;
            this.currentProgram;
            this.currentBlending;
            this.currentBlendEquation;
            this.currentBlendSrc;
            this.currentBlendDst;
            this.currentBlendEquationAlpha;
            this.currentBlendSrcAlpha;
            this.currentBlendDstAlpha;
            this.currentPremultipledAlpha;
            this.currentFlipSided;
            this.currentCullFace;
            this.currentLineWidth;
            this.currentPolygonOffsetFactor;
            this.currentPolygonOffsetUnits;
            this.maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            this.lineWidthAvailable;
            this.version = 0;
            this.glVersion = gl.getParameter(gl.VERSION);
            this.currentTextureSlot;
            this.currentBoundTextures = {};
            this.currentScissor = new THREE.Vector4();
            this.currentViewport = new THREE.Vector4();
            this.emptyTextures = {};
            this.emptyTextures[gl.TEXTURE_2D] = this.createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
            this.emptyTextures[gl.TEXTURE_CUBE_MAP] = this.createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
            if (this.glVersion.indexOf('WebGL') !== -1) {
                this.version = parseFloat(/^WebGL\ ([0-9])/.exec(this.glVersion)[1]);
                this.lineWidthAvailable = (this.version >= 1.0);
            }
            else if (this.glVersion.indexOf('OpenGL ES') !== -1) {
                this.version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(this.glVersion)[1]);
                this.lineWidthAvailable = (this.version >= 2.0);
            }
            colorBuffer.setClear(0, 0, 0, 1);
            depthBuffer.setClear(1);
            stencilBuffer.setClear(0);
            gl.enable(gl.DEPTH_TEST);
            depthBuffer.setFunc(THREE.LessEqualDepth);
            this.setFlipSided(false);
            this.setCullFace(THREE.CullFaceBack);
            gl.enable(gl.CULL_FACE);
            gl.enable(gl.BLEND);
            this.setBlending(THREE.NormalBlending, null, null, null, null, null, null, null);
        }
        createTexture(type, target, count) {
            var gl = this.gl;
            var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
            var texture = gl.createTexture();
            gl.bindTexture(type, texture);
            gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            for (var i = 0; i < count; i++) {
                gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            }
            return texture;
        }
        get buffers() {
            return {
                color: this.colorBuffer,
                depth: this.depthBuffer,
                stencil: this.stencilBuffer
            };
        }
        initAttributes() {
            for (var i = 0, l = this.newAttributes.length; i < l; i++) {
                this.newAttributes[i] = 0;
            }
        }
        /**
         *  开启该attribute
         * @param attribute :shader 中attribute 的编号
         */
        enableAttribute(attribute) {
            this.enableAttributeAndDivisor(attribute, 0);
        }
        /**
         * 开启attribute
         * @param attribute
         * @param meshPerAttribute
         */
        enableAttributeAndDivisor(attribute, meshPerAttribute) {
            this.newAttributes[attribute] = 1;
            if (this.enabledAttributes[attribute] === 0) {
                this.gl.enableVertexAttribArray(attribute);
                this.enabledAttributes[attribute] = 1;
            }
            if (this.attributeDivisors[attribute] !== meshPerAttribute) {
                var extension = this.extensions.get('ANGLE_instanced_arrays');
                extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
                this.attributeDivisors[attribute] = meshPerAttribute;
            }
        }
        /**
         * 关闭attribute
         */
        disableUnusedAttributes() {
            for (var i = 0, l = this.enabledAttributes.length; i !== l; ++i) {
                if (this.enabledAttributes[i] !== this.newAttributes[i]) {
                    this.gl.disableVertexAttribArray(i);
                    this.enabledAttributes[i] = 0;
                }
            }
        }
        enable(id) {
            if (this.capabilities[id] !== true) {
                this.gl.enable(id);
                this.capabilities[id] = true;
            }
        }
        disable(id) {
            if (this.capabilities[id] !== false) {
                this.gl.disable(id);
                this.capabilities[id];
            }
        }
        getCompressedTextureFormats() {
            if (this.compressedTextureFormats === null) {
                this.compressedTextureFormats = [];
                if (this.extensions.get('WEBGL_compressed_texture_pvrtc') ||
                    this.extensions.get('WEBGL_compressed_texture_s3tc') ||
                    this.extensions.get('WEBGL_compressed_texture_etc1') ||
                    this.extensions.get('WEBGL_compressed_texture_astc')) {
                    var formats = this.gl.getParameter(this.gl.COMPRESSED_TEXTURE_FORMATS);
                    for (var i = 0; i < formats.length; i++) {
                        this.compressedTextureFormats.push(formats[i]);
                    }
                }
            }
            return this.compressedTextureFormats;
        }
        /**
         * 应用program
         * @param program
         */
        useProgram(program) {
            if (this.currentProgram !== program) {
                this.gl.useProgram(program);
                this.currentProgram = program;
                return true;
            }
            return false;
        }
        setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
            var gl = this.gl;
            if (blending !== THREE.NoBlending) {
                this.enable(gl.BLEND);
            }
            else {
                this.disable(gl.BLEND);
            }
            if (blending !== THREE.CustomBlending) {
                if (blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha) {
                    switch (blending) {
                        case THREE.AdditiveBlending:
                            if (premultipliedAlpha) {
                                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
                            }
                            else {
                                gl.blendEquation(gl.FUNC_ADD);
                                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                            }
                            break;
                        case THREE.SubtractiveBlending:
                            if (premultipliedAlpha) {
                                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                            }
                            else {
                                gl.blendEquation(gl.FUNC_ADD);
                                gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
                            }
                            break;
                        case THREE.MultiplyBlending:
                            if (premultipliedAlpha) {
                                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                            }
                            else {
                                gl.blendEquation(gl.FUNC_ADD);
                                gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                            }
                            break;
                        default:
                            if (premultipliedAlpha) {
                                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                            }
                            else {
                                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                            }
                    }
                }
            }
            else {
                blendEquationAlpha = blendEquationAlpha || blendEquation;
                blendSrcAlpha = blendSrcAlpha || blendSrc;
                blendDstAlpha = blendDstAlpha || blendDst;
                if (blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha) {
                    gl.blendEquationSeparate(this.utils.convert(blendEquation), this.utils.convert(blendEquationAlpha));
                    this.currentBlendEquation = blendEquation;
                    this.currentBlendEquationAlpha = blendEquationAlpha;
                }
                if (blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha) {
                    gl.blendFuncSeparate(this.utils.convert(blendSrc), this.utils.convert(blendDst), this.utils.convert(blendSrcAlpha), this.utils.convert(blendDstAlpha));
                    this.currentBlendSrc = blendSrc;
                    this.currentBlendDst = blendDst;
                    this.currentBlendSrcAlpha = blendSrcAlpha;
                    this.currentBlendDstAlpha = blendDstAlpha;
                }
            }
            this.currentBlending = blending;
            this.currentPremultipledAlpha = premultipliedAlpha;
        }
        setMaterial(material, frontFaceCW) {
            material.side === THREE.DoubleSide
                ? this.disable(this.gl.CULL_FACE)
                : this.enable(this.gl.CULL_FACE);
            var flipSided = (material.side === THREE.BackSide);
            if (frontFaceCW)
                flipSided = !flipSided;
            this.setFlipSided(flipSided);
            material.transparent === true
                ? this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha)
                : this.setBlending(THREE.NoBlending);
            this.depthBuffer.setFunc(material.depthFunc);
            this.depthBuffer.setTest(material.depthTest);
            this.depthBuffer.setMask(material.depthWrite);
            this.colorBuffer.setMask(material.colorWrite);
            this.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        }
        //
        setFlipSided(flipSided) {
            if (this.currentFlipSided !== flipSided) {
                if (flipSided) {
                    this.gl.frontFace(this.gl.CW);
                }
                else {
                    this.gl.frontFace(this.gl.CCW);
                }
                this.currentFlipSided = flipSided;
            }
        }
        setCullFace(cullFace) {
            var gl = this.gl;
            if (cullFace !== THREE.CullFaceNone) {
                this.enable(gl.CULL_FACE);
                if (cullFace !== this.currentCullFace) {
                    if (cullFace === THREE.CullFaceBack) {
                        gl.cullFace(gl.BACK);
                    }
                    else if (cullFace === THREE.CullFaceFront) {
                        gl.cullFace(gl.FRONT);
                    }
                    else {
                        gl.cullFace(gl.FRONT_AND_BACK);
                    }
                }
            }
            else {
                this.disable(gl.CULL_FACE);
            }
            this.currentCullFace = cullFace;
        }
        setLineWidth(width) {
            if (width !== this.currentLineWidth) {
                if (this.lineWidthAvailable)
                    this.gl.lineWidth(width);
                this.currentLineWidth = width;
            }
        }
        setPolygonOffset(polygonOffset, factor, units) {
            if (polygonOffset) {
                this.enable(this.gl.POLYGON_OFFSET_FILL);
                if (this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units) {
                    this.gl.polygonOffset(factor, units);
                    this.currentPolygonOffsetFactor = factor;
                    this.currentPolygonOffsetUnits = units;
                }
            }
            else {
                this.disable(this.gl.POLYGON_OFFSET_FILL);
            }
        }
        setScissorTest(scissorTest) {
            if (scissorTest) {
                this.enable(this.gl.SCISSOR_TEST);
            }
            else {
                this.disable(this.gl.SCISSOR_TEST);
            }
        }
        // texture
        activeTexture(webglSlot) {
            if (webglSlot === undefined)
                webglSlot = this.gl.TEXTURE0 + this.maxTextures - 1;
            if (this.currentTextureSlot !== webglSlot) {
                this.gl.activeTexture(webglSlot);
                this.currentTextureSlot = webglSlot;
            }
        }
        bindTexture(webglType, webglTexture) {
            if (this.currentTextureSlot === null) {
                this.activeTexture(null);
            }
            var boundTexture = this.currentBoundTextures[this.currentTextureSlot];
            if (boundTexture === undefined) {
                boundTexture = { type: undefined, texture: undefined };
                this.currentBoundTextures[this.currentTextureSlot] = boundTexture;
            }
            if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
                this.gl.bindTexture(webglType, webglTexture || this.emptyTextures[webglType]);
                boundTexture.type = webglType;
                boundTexture.texture = webglTexture;
            }
        }
        compressedTexImage2D() {
            try {
                this.gl.compressedTexImage2D.apply(this.gl, arguments);
            }
            catch (error) {
                console.error('THREE.WebGLState:', error);
            }
        }
        texImage2D() {
            try {
                this.gl.texImage2D.apply(this.gl, arguments);
            }
            catch (error) {
                console.error('THREE.WebGLState:', error);
            }
        }
        //
        scissor(scissor) {
            if (this.currentScissor.equals(scissor) === false) {
                this.gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
                this.currentScissor.copy(scissor);
            }
        }
        viewport(viewport) {
            if (this.currentViewport.equals(viewport) === false) {
                this.gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
                this.currentViewport.copy(viewport);
            }
        }
        //
        reset() {
            for (var i = 0; i < this.enabledAttributes.length; i++) {
                if (this.enabledAttributes[i] === 1) {
                    this.gl.disableVertexAttribArray(i);
                    this.enabledAttributes[i] = 0;
                }
            }
            this.capabilities = {};
            this.compressedTextureFormats;
            this.currentTextureSlot;
            this.currentBoundTextures = {};
            this.currentProgram;
            this.currentBlending;
            this.currentFlipSided;
            this.currentCullFace;
            this.colorBuffer.reset();
            this.depthBuffer.reset();
            this.stencilBuffer.reset();
        }
    }
    THREE.WebGLStateNode = WebGLStateNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLTexturesNode {
        constructor(_gl, extensions, state, properties, capabilities, utils, info) {
            this._isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext); /* global WebGL2RenderingContext */
            this._videoTextures = {};
            this._canvas;
            this._gl = _gl;
            this.extensions = extensions;
            this.state = state;
            this.properties = properties;
            this.capabilities = capabilities;
            this.utils = utils;
            this.info = info;
        }
        //
        clampToMaxSize(image, maxSize) {
            if (image.width > maxSize || image.height > maxSize) {
                if ('data' in image) {
                    console.warn('THREE.WebGLRenderer: image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
                    return;
                }
                // Warning: Scaling through the canvas will only work with images that use
                // premultiplied alpha.
                var scale = maxSize / Math.max(image.width, image.height);
                var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                canvas.width = Math.floor(image.width * scale);
                canvas.height = Math.floor(image.height * scale);
                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
                console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
                return canvas;
            }
            return image;
        }
        isPowerOfTwo(image) {
            return THREE._Math.isPowerOfTwo(image.width) && THREE._Math.isPowerOfTwo(image.height);
        }
        makePowerOfTwo(image) {
            if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap) {
                if (this._canvas === undefined)
                    this._canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                this._canvas.width = THREE._Math.floorPowerOfTwo(image.width);
                this._canvas.height = THREE._Math.floorPowerOfTwo(image.height);
                var context = this._canvas.getContext('2d');
                context.drawImage(image, 0, 0, this._canvas.width, this._canvas.height);
                console.warn('THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + this._canvas.width + 'x' + this._canvas.height, image);
                return this._canvas;
            }
            return image;
        }
        textureNeedsPowerOfTwo(texture) {
            return (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping) ||
                (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter);
        }
        textureNeedsGenerateMipmaps(texture, isPowerOfTwo) {
            return texture.generateMipmaps && isPowerOfTwo &&
                texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter;
        }
        generateMipmap(target, texture, width, height) {
            this._gl.generateMipmap(target);
            var textureProperties = this.properties.get(texture);
            // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
            textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
        }
        // Fallback filters for non-power-of-2 textures
        filterFallback(f) {
            if (f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter) {
                return this._gl.NEAREST;
            }
            return this._gl.LINEAR;
        }
        //
        onTextureDispose(event) {
            var texture = event.target;
            texture.removeEventListener('dispose', this.onTextureDispose);
            this.deallocateTexture(texture);
            if (texture.isVideoTexture) {
                delete this._videoTextures[texture.id];
            }
            this.info.memory.textures--;
        }
        onRenderTargetDispose(event) {
            var renderTarget = event.target;
            renderTarget.removeEventListener('dispose', this.onRenderTargetDispose);
            this.deallocateRenderTarget(renderTarget);
            this.info.memory.textures--;
        }
        //
        deallocateTexture(texture) {
            var textureProperties = this.properties.get(texture);
            if (texture.image && textureProperties.__image__webglTextureCube) {
                // cube texture
                this._gl.deleteTexture(textureProperties.__image__webglTextureCube);
            }
            else {
                // 2D texture
                if (textureProperties.__webglInit === undefined)
                    return;
                this._gl.deleteTexture(textureProperties.__webglTexture);
            }
            // remove all webgl properties
            this.properties.remove(texture);
        }
        deallocateRenderTarget(renderTarget) {
            var renderTargetProperties = this.properties.get(renderTarget);
            var textureProperties = this.properties.get(renderTarget.texture);
            if (!renderTarget)
                return;
            if (textureProperties.__webglTexture !== undefined) {
                this._gl.deleteTexture(textureProperties.__webglTexture);
            }
            if (renderTarget.depthTexture) {
                renderTarget.depthTexture.dispose();
            }
            if (renderTarget.isWebGLRenderTargetCube) {
                for (var i = 0; i < 6; i++) {
                    this._gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                    if (renderTargetProperties.__webglDepthbuffer)
                        this._gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
                }
            }
            else {
                this._gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
                if (renderTargetProperties.__webglDepthbuffer)
                    this._gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            }
            this.properties.remove(renderTarget.texture);
            this.properties.remove(renderTarget);
        }
        //
        setTexture2D(texture, slot) {
            var textureProperties = this.properties.get(texture);
            if (texture.isVideoTexture)
                this.updateVideoTexture(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                var image = texture.image;
                if (image === undefined) {
                    console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', texture);
                }
                else if (image.complete === false) {
                    console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture);
                }
                else {
                    this.uploadTexture(textureProperties, texture, slot);
                    return;
                }
            }
            this.state.activeTexture(this._gl.TEXTURE0 + slot);
            this.state.bindTexture(this._gl.TEXTURE_2D, textureProperties.__webglTexture);
        }
        setTextureCube(texture, slot) {
            var textureProperties = this.properties.get(texture);
            if (texture.image.length === 6) {
                if (texture.version > 0 && textureProperties.__version !== texture.version) {
                    if (!textureProperties.__image__webglTextureCube) {
                        texture.addEventListener('dispose', this.onTextureDispose);
                        textureProperties.__image__webglTextureCube = this._gl.createTexture();
                        this.info.memory.textures++;
                    }
                    this.state.activeTexture(this._gl.TEXTURE0 + slot);
                    this.state.bindTexture(this._gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                    this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                    var isCompressed = (texture && texture.isCompressedTexture);
                    var isDataTexture = (texture.image[0] && texture.image[0].isDataTexture);
                    var cubeImage = [];
                    for (var i = 0; i < 6; i++) {
                        if (!isCompressed && !isDataTexture) {
                            cubeImage[i] = this.clampToMaxSize(texture.image[i], this.capabilities.maxCubemapSize);
                        }
                        else {
                            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                        }
                    }
                    var image = cubeImage[0], isPowerOfTwoImage = this.isPowerOfTwo(image), glFormat = this.utils.convert(texture.format), glType = this.utils.convert(texture.type);
                    this.setTextureParameters(this._gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
                    for (var i = 0; i < 6; i++) {
                        if (!isCompressed) {
                            if (isDataTexture) {
                                this.state.texImage2D(this._gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                            }
                            else {
                                this.state.texImage2D(this._gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                            }
                        }
                        else {
                            var mipmap, mipmaps = cubeImage[i].mipmaps;
                            for (var j = 0, jl = mipmaps.length; j < jl; j++) {
                                mipmap = mipmaps[j];
                                if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
                                    if (this.state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                                        this.state.compressedTexImage2D(this._gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                                    }
                                    else {
                                        console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                                    }
                                }
                                else {
                                    this.state.texImage2D(this._gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                                }
                            }
                        }
                    }
                    if (!isCompressed) {
                        textureProperties.__maxMipLevel = 0;
                    }
                    else {
                        textureProperties.__maxMipLevel = mipmaps.length - 1;
                    }
                    if (this.textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {
                        // We assume images for cube map have the same size.
                        this.generateMipmap(this._gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);
                    }
                    textureProperties.__version = texture.version;
                    if (texture.onUpdate)
                        texture.onUpdate(texture);
                }
                else {
                    this.state.activeTexture(this._gl.TEXTURE0 + slot);
                    this.state.bindTexture(this._gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                }
            }
        }
        setTextureCubeDynamic(texture, slot) {
            this.state.activeTexture(this._gl.TEXTURE0 + slot);
            this.state.bindTexture(this._gl.TEXTURE_CUBE_MAP, this.properties.get(texture).__webglTexture);
        }
        setTextureParameters(textureType, texture, isPowerOfTwoImage) {
            var extension;
            if (isPowerOfTwoImage) {
                this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_S, this.utils.convert(texture.wrapS));
                this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_T, this.utils.convert(texture.wrapT));
                this._gl.texParameteri(textureType, this._gl.TEXTURE_MAG_FILTER, this.utils.convert(texture.magFilter));
                this._gl.texParameteri(textureType, this._gl.TEXTURE_MIN_FILTER, this.utils.convert(texture.minFilter));
            }
            else {
                this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
                this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
                if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping) {
                    console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture);
                }
                this._gl.texParameteri(textureType, this._gl.TEXTURE_MAG_FILTER, this.filterFallback(texture.magFilter));
                this._gl.texParameteri(textureType, this._gl.TEXTURE_MIN_FILTER, this.filterFallback(texture.minFilter));
                if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {
                    console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture);
                }
            }
            extension = this.extensions.get('EXT_texture_filter_anisotropic');
            if (extension) {
                if (texture.type === THREE.FloatType && this.extensions.get('OES_texture_float_linear') === null)
                    return;
                if (texture.type === THREE.HalfFloatType && this.extensions.get('OES_texture_half_float_linear') === null)
                    return;
                if (texture.anisotropy > 1 || this.properties.get(texture).__currentAnisotropy) {
                    this._gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, this.capabilities.getMaxAnisotropy()));
                    this.properties.get(texture).__currentAnisotropy = texture.anisotropy;
                }
            }
        }
        uploadTexture(textureProperties, texture, slot) {
            if (textureProperties.__webglInit === undefined) {
                textureProperties.__webglInit = true;
                texture.addEventListener('dispose', this.onTextureDispose);
                textureProperties.__webglTexture = this._gl.createTexture();
                this.info.memory.textures++;
            }
            this.state.activeTexture(this._gl.TEXTURE0 + slot);
            this.state.bindTexture(this._gl.TEXTURE_2D, textureProperties.__webglTexture);
            this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
            this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
            var image = this.clampToMaxSize(texture.image, this.capabilities.maxTextureSize);
            if (this.textureNeedsPowerOfTwo(texture) && this.isPowerOfTwo(image) === false) {
                image = this.makePowerOfTwo(image);
            }
            var isPowerOfTwoImage = this.isPowerOfTwo(image), glFormat = this.utils.convert(texture.format), glType = this.utils.convert(texture.type);
            this.setTextureParameters(this._gl.TEXTURE_2D, texture, isPowerOfTwoImage);
            var mipmap, mipmaps = texture.mipmaps;
            if (texture.isDepthTexture) {
                // populate depth texture with dummy data
                var internalFormat = this._gl.DEPTH_COMPONENT;
                if (texture.type === THREE.FloatType) {
                    if (!this._isWebGL2)
                        throw new Error('Float Depth Texture only supported in WebGL2.0');
                    internalFormat = this._gl.DEPTH_COMPONENT32F;
                }
                else if (this._isWebGL2) {
                    // WebGL 2.0 requires signed internalformat for glTexImage2D
                    internalFormat = this._gl.DEPTH_COMPONENT16;
                }
                if (texture.format === THREE.DepthFormat && internalFormat === this._gl.DEPTH_COMPONENT) {
                    // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                    // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                    if (texture.type !== THREE.UnsignedShortType && texture.type !== THREE.UnsignedIntType) {
                        console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
                        texture.type = THREE.UnsignedShortType;
                        glType = this.utils.convert(texture.type);
                    }
                }
                // Depth stencil textures need the DEPTH_STENCIL internal format
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                if (texture.format === THREE.DepthStencilFormat) {
                    internalFormat = this._gl.DEPTH_STENCIL;
                    // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                    // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                    if (texture.type !== THREE.UnsignedInt248Type) {
                        console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
                        texture.type = THREE.UnsignedInt248Type;
                        glType = this.utils.convert(texture.type);
                    }
                }
                this.state.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);
            }
            else if (texture.isDataTexture) {
                // use manually created mipmaps if available
                // if there are no manual mipmaps
                // set 0 level mipmap and then use GL to generate other mipmap levels
                if (mipmaps.length > 0 && isPowerOfTwoImage) {
                    for (var i = 0, il = mipmaps.length; i < il; i++) {
                        mipmap = mipmaps[i];
                        this.state.texImage2D(this._gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                    texture.generateMipmaps = false;
                    textureProperties.__maxMipLevel = mipmaps.length - 1;
                }
                else {
                    this.state.texImage2D(this._gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
                    textureProperties.__maxMipLevel = 0;
                }
            }
            else if (texture.isCompressedTexture) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
                        if (this.state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                            this.state.compressedTexImage2D(this._gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                        }
                        else {
                            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                        }
                    }
                    else {
                        this.state.texImage2D(this._gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                }
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            }
            else {
                // regular Texture (image, video, canvas)
                // use manually created mipmaps if available
                // if there are no manual mipmaps
                // set 0 level mipmap and then use GL to generate other mipmap levels
                if (mipmaps.length > 0 && isPowerOfTwoImage) {
                    for (var i = 0, il = mipmaps.length; i < il; i++) {
                        mipmap = mipmaps[i];
                        this.state.texImage2D(this._gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
                    }
                    texture.generateMipmaps = false;
                    textureProperties.__maxMipLevel = mipmaps.length - 1;
                }
                else {
                    this.state.texImage2D(this._gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
                    textureProperties.__maxMipLevel = 0;
                }
            }
            if (this.textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {
                this.generateMipmap(this._gl.TEXTURE_2D, texture, image.width, image.height);
            }
            textureProperties.__version = texture.version;
            if (texture.onUpdate)
                texture.onUpdate(texture);
        }
        // Render targets
        // Setup storage for target texture and bind it to correct framebuffer
        setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
            var glFormat = this.utils.convert(renderTarget.texture.format);
            var glType = this.utils.convert(renderTarget.texture.type);
            this.state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);
            this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, attachment, textureTarget, this.properties.get(renderTarget.texture).__webglTexture, 0);
            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
        }
        // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
        setupRenderBufferStorage(renderbuffer, renderTarget) {
            this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, renderbuffer);
            if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                this._gl.renderbufferStorage(this._gl.RENDERBUFFER, this._gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
                this._gl.framebufferRenderbuffer(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.RENDERBUFFER, renderbuffer);
            }
            else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                this._gl.renderbufferStorage(this._gl.RENDERBUFFER, this._gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
                this._gl.framebufferRenderbuffer(this._gl.FRAMEBUFFER, this._gl.DEPTH_STENCIL_ATTACHMENT, this._gl.RENDERBUFFER, renderbuffer);
            }
            else {
                // FIXME: We don't support !depth !stencil
                this._gl.renderbufferStorage(this._gl.RENDERBUFFER, this._gl.RGBA4, renderTarget.width, renderTarget.height);
            }
            this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, null);
        }
        // Setup resources for a Depth Texture for a FBO (needs an extension)
        setupDepthTexture(framebuffer, renderTarget) {
            var isCube = (renderTarget && renderTarget.isWebGLRenderTargetCube);
            if (isCube)
                throw new Error('Depth Texture with cube render targets is not supported');
            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);
            if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
                throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
            }
            // upload an empty depth texture with framebuffer size
            if (!this.properties.get(renderTarget.depthTexture).__webglTexture ||
                renderTarget.depthTexture.image.width !== renderTarget.width ||
                renderTarget.depthTexture.image.height !== renderTarget.height) {
                renderTarget.depthTexture.image.width = renderTarget.width;
                renderTarget.depthTexture.image.height = renderTarget.height;
                renderTarget.depthTexture.needsUpdate = true;
            }
            this.setTexture2D(renderTarget.depthTexture, 0);
            var webglDepthTexture = this.properties.get(renderTarget.depthTexture).__webglTexture;
            if (renderTarget.depthTexture.format === THREE.DepthFormat) {
                this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, webglDepthTexture, 0);
            }
            else if (renderTarget.depthTexture.format === THREE.DepthStencilFormat) {
                this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_STENCIL_ATTACHMENT, this._gl.TEXTURE_2D, webglDepthTexture, 0);
            }
            else {
                throw new Error('Unknown depthTexture format');
            }
        }
        // Setup GL resources for a non-texture depth buffer
        setupDepthRenderbuffer(renderTarget) {
            var renderTargetProperties = this.properties.get(renderTarget);
            var isCube = (renderTarget.isWebGLRenderTargetCube === true);
            if (renderTarget.depthTexture) {
                if (isCube)
                    throw new Error('target.depthTexture not supported in Cube render targets');
                this.setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
            }
            else {
                if (isCube) {
                    renderTargetProperties.__webglDepthbuffer = [];
                    for (var i = 0; i < 6; i++) {
                        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                        renderTargetProperties.__webglDepthbuffer[i] = this._gl.createRenderbuffer();
                        this.setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
                    }
                }
                else {
                    this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                    renderTargetProperties.__webglDepthbuffer = this._gl.createRenderbuffer();
                    this.setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
                }
            }
            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
        }
        // Set up GL resources for the render target
        setupRenderTarget(renderTarget) {
            var renderTargetProperties = this.properties.get(renderTarget);
            var textureProperties = this.properties.get(renderTarget.texture);
            renderTarget.addEventListener('dispose', this.onRenderTargetDispose);
            textureProperties.__webglTexture = this._gl.createTexture();
            this.info.memory.textures++;
            var isCube = (renderTarget.isWebGLRenderTargetCube === true);
            var isTargetPowerOfTwo = this.isPowerOfTwo(renderTarget);
            // Setup framebuffer
            if (isCube) {
                renderTargetProperties.__webglFramebuffer = [];
                for (var i = 0; i < 6; i++) {
                    renderTargetProperties.__webglFramebuffer[i] = this._gl.createFramebuffer();
                }
            }
            else {
                renderTargetProperties.__webglFramebuffer = this._gl.createFramebuffer();
            }
            // Setup color buffer
            if (isCube) {
                this.state.bindTexture(this._gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
                this.setTextureParameters(this._gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
                for (var i = 0; i < 6; i++) {
                    this.setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
                }
                if (this.textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) {
                    this.generateMipmap(this._gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height);
                }
                this.state.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
            }
            else {
                this.state.bindTexture(this._gl.TEXTURE_2D, textureProperties.__webglTexture);
                this.setTextureParameters(this._gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
                this.setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D);
                if (this.textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) {
                    this.generateMipmap(this._gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height);
                }
                this.state.bindTexture(this._gl.TEXTURE_2D, null);
            }
            // Setup depth and stencil buffers
            if (renderTarget.depthBuffer) {
                this.setupDepthRenderbuffer(renderTarget);
            }
        }
        updateRenderTargetMipmap(renderTarget) {
            var texture = renderTarget.texture;
            var isTargetPowerOfTwo = this.isPowerOfTwo(renderTarget);
            if (this.textureNeedsGenerateMipmaps(texture, isTargetPowerOfTwo)) {
                var target = renderTarget.isWebGLRenderTargetCube ? this._gl.TEXTURE_CUBE_MAP : this._gl.TEXTURE_2D;
                var webglTexture = this.properties.get(texture).__webglTexture;
                this.state.bindTexture(target, webglTexture);
                this.generateMipmap(target, texture, renderTarget.width, renderTarget.height);
                this.state.bindTexture(target, null);
            }
        }
        updateVideoTexture(texture) {
            var id = texture.id;
            var frame = this.info.render.frame;
            // Check the last frame we updated the VideoTexture
            if (this._videoTextures[id] !== frame) {
                this._videoTextures[id] = frame;
                texture.update();
            }
        }
    }
    THREE.WebGLTexturesNode = WebGLTexturesNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Texture extends THREE.EventDispatcher {
        constructor(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
            super();
            this.isTexture = true;
            //Object.defineProperty(this, 'id', { value: textureId++ });
            this.id = Texture.textureId++;
            this.uuid = THREE._Math.generateUUID();
            this.name = '';
            this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
            this.mipmaps = [];
            this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
            this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
            this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
            this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
            this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
            this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
            this.format = format !== undefined ? format : THREE.RGBAFormat;
            this.type = type !== undefined ? type : THREE.UnsignedByteType;
            this.offset = new THREE.Vector2(0, 0);
            this.repeat = new THREE.Vector2(1, 1);
            this.center = new THREE.Vector2(0, 0);
            this.rotation = 0;
            this.matrixAutoUpdate = true;
            this.matrix = new THREE.Matrix3();
            this.generateMipmaps = true;
            this.premultiplyAlpha = false;
            this.flipY = true;
            this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
            // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
            //
            // Also changing the encoding after already used by a Material will not automatically make the Material
            // update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
            this.encoding = encoding !== undefined ? encoding : THREE.LinearEncoding;
            this.version = 0;
            this.onUpdate = null;
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
            return new Texture().copy(this);
        }
        copy(source) {
            this.name = source.name;
            this.image = source.image;
            this.mipmaps = source.mipmaps.slice(0);
            this.mapping = source.mapping;
            this.wrapS = source.wrapS;
            this.wrapT = source.wrapT;
            this.magFilter = source.magFilter;
            this.minFilter = source.minFilter;
            this.anisotropy = source.anisotropy;
            this.format = source.format;
            this.type = source.type;
            this.offset.copy(source.offset);
            this.repeat.copy(source.repeat);
            this.center.copy(source.center);
            this.rotation = source.rotation;
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            this.matrix.copy(source.matrix);
            this.generateMipmaps = source.generateMipmaps;
            this.premultiplyAlpha = source.premultiplyAlpha;
            this.flipY = source.flipY;
            this.unpackAlignment = source.unpackAlignment;
            this.encoding = source.encoding;
            return this;
        }
        toJSON(meta) {
            var isRootObject = (meta === undefined || typeof meta === 'string');
            if (!isRootObject && meta.textures[this.uuid] !== undefined) {
                return meta.textures[this.uuid];
            }
            function getDataURL(image) {
                var canvas;
                if (image instanceof HTMLCanvasElement) {
                    canvas = image;
                }
                else {
                    canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                    canvas.width = image.width;
                    canvas.height = image.height;
                    var context = canvas.getContext('2d');
                    if (image instanceof ImageData) {
                        context.putImageData(image, 0, 0);
                    }
                    else {
                        context.drawImage(image, 0, 0, image.width, image.height);
                    }
                }
                if (canvas.width > 2048 || canvas.height > 2048) {
                    return canvas.toDataURL('image/jpeg', 0.6);
                }
                else {
                    return canvas.toDataURL('image/png');
                }
            }
            var output = {
                metadata: {
                    version: 4.5,
                    type: 'Texture',
                    generator: 'Texture.toJSON'
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (this.image !== undefined) {
                // TODO: Move to THREE.Image
                var image = this.image;
                if (image.uuid === undefined) {
                    image.uuid = THREE._Math.generateUUID(); // UGH
                }
                if (!isRootObject && meta.images[image.uuid] === undefined) {
                    meta.images[image.uuid] = {
                        uuid: image.uuid,
                        url: getDataURL(image)
                    };
                }
                output.image = image.uuid;
            }
            if (!isRootObject) {
                meta.textures[this.uuid] = output;
            }
            return output;
        }
        dispose() {
            this.dispatchEvent({ type: 'dispose' });
        }
        transformUv(uv) {
            if (this.mapping !== THREE.UVMapping)
                return;
            uv.applyMatrix3(this.matrix);
            if (uv.x < 0 || uv.x > 1) {
                switch (this.wrapS) {
                    case THREE.RepeatWrapping:
                        uv.x = uv.x - Math.floor(uv.x);
                        break;
                    case THREE.ClampToEdgeWrapping:
                        uv.x = uv.x < 0 ? 0 : 1;
                        break;
                    case THREE.MirroredRepeatWrapping:
                        if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                            uv.x = Math.ceil(uv.x) - uv.x;
                        }
                        else {
                            uv.x = uv.x - Math.floor(uv.x);
                        }
                        break;
                }
            }
            if (uv.y < 0 || uv.y > 1) {
                switch (this.wrapT) {
                    case THREE.RepeatWrapping:
                        uv.y = uv.y - Math.floor(uv.y);
                        break;
                    case THREE.ClampToEdgeWrapping:
                        uv.y = uv.y < 0 ? 0 : 1;
                        break;
                    case THREE.MirroredRepeatWrapping:
                        if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                            uv.y = Math.ceil(uv.y) - uv.y;
                        }
                        else {
                            uv.y = uv.y - Math.floor(uv.y);
                        }
                        break;
                }
            }
            if (this.flipY) {
                uv.y = 1 - uv.y;
            }
        }
        set needsUpdate(value) {
            this.version++;
        }
    }
    Texture.textureId = 0;
    Texture.DEFAULT_IMAGE = undefined;
    Texture.DEFAULT_MAPPING = THREE.UVMapping;
    THREE.Texture = Texture;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class CubeTexture extends THREE.Texture {
        constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
            super(images !== undefined ? images : [], mapping !== undefined ? mapping : THREE.CubeReflectionMapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
            this.flipY = false;
        }
    }
    THREE.CubeTexture = CubeTexture;
})(THREE || (THREE = {}));
///<reference path="../../textures/Texture"/>
///<reference path="../../textures/CubeTexture"/>
var THREE;
///<reference path="../../textures/Texture"/>
///<reference path="../../textures/CubeTexture"/>
(function (THREE) {
    var emptyTexture = new THREE.Texture();
    var emptyCubeTexture = new THREE.CubeTexture();
    // --- Utilities ---
    // Array Caches (provide typed arrays for temporary by size)
    var arrayCacheF32 = [];
    var arrayCacheI32 = [];
    // Float32Array caches used for uploading Matrix uniforms
    var mat4array = new Float32Array(16);
    var mat3array = new Float32Array(9);
    var mat2array = new Float32Array(4);
    // Flattening for arrays of vectors and matrices
    function flatten(array, nBlocks, blockSize) {
        var firstElem = array[0];
        if (firstElem <= 0 || firstElem > 0)
            return array;
        // unoptimized: ! isNaN( firstElem )
        // see http://jacksondunstan.com/articles/983
        var n = nBlocks * blockSize, r = arrayCacheF32[n];
        if (r === undefined) {
            r = new Float32Array(n);
            arrayCacheF32[n] = r;
        }
        if (nBlocks !== 0) {
            firstElem.toArray(r, 0);
            for (var i = 1, offset = 0; i !== nBlocks; ++i) {
                offset += blockSize;
                array[i].toArray(r, offset);
            }
        }
        return r;
    }
    THREE.flatten = flatten;
    function arraysEqual(a, b) {
        if (a.length !== b.length)
            return false;
        for (var i = 0, l = a.length; i < l; i++) {
            if (a[i] !== b[i])
                return false;
        }
        return true;
    }
    THREE.arraysEqual = arraysEqual;
    function copyArray(a, b) {
        for (var i = 0, l = b.length; i < l; i++) {
            a[i] = b[i];
        }
    }
    THREE.copyArray = copyArray;
    // Texture unit allocation
    function allocTexUnits(renderer, n) {
        var r = arrayCacheI32[n];
        if (r === undefined) {
            r = new Int32Array(n);
            arrayCacheI32[n] = r;
        }
        for (var i = 0; i !== n; ++i)
            r[i] = renderer.allocTextureUnit();
        return r;
    }
    THREE.allocTexUnits = allocTexUnits;
    // --- Setters ---
    // Note: Defining these methods externally, because they come in a bunch
    // and this way their names minify.
    // Single scalar
    function setValue1f(gl, v) {
        var cache = this.cache;
        if (cache[0] === v)
            return;
        gl.uniform1f(this.addr, v);
        cache[0] = v;
    }
    THREE.setValue1f = setValue1f;
    function setValue1i(gl, v) {
        var cache = this.cache;
        if (cache[0] === v)
            return;
        gl.uniform1i(this.addr, v);
        cache[0] = v;
    }
    THREE.setValue1i = setValue1i;
    // Single float vector (from flat array or THREE.VectorN)
    function setValue2fv(gl, v) {
        var cache = this.cache;
        if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y) {
                gl.uniform2f(this.addr, v.x, v.y);
                cache[0] = v.x;
                cache[1] = v.y;
            }
        }
        else {
            if (arraysEqual(cache, v))
                return;
            gl.uniform2fv(this.addr, v);
            copyArray(cache, v);
        }
    }
    THREE.setValue2fv = setValue2fv;
    function setValue3fv(gl, v) {
        var cache = this.cache;
        if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
                gl.uniform3f(this.addr, v.x, v.y, v.z);
                cache[0] = v.x;
                cache[1] = v.y;
                cache[2] = v.z;
            }
        }
        else if (v.r !== undefined) {
            if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
                gl.uniform3f(this.addr, v.r, v.g, v.b);
                cache[0] = v.r;
                cache[1] = v.g;
                cache[2] = v.b;
            }
        }
        else {
            if (arraysEqual(cache, v))
                return;
            gl.uniform3fv(this.addr, v);
            copyArray(cache, v);
        }
    }
    THREE.setValue3fv = setValue3fv;
    function setValue4fv(gl, v) {
        var cache = this.cache;
        if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
                gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
                cache[0] = v.x;
                cache[1] = v.y;
                cache[2] = v.z;
                cache[3] = v.w;
            }
        }
        else {
            if (arraysEqual(cache, v))
                return;
            gl.uniform4fv(this.addr, v);
            copyArray(cache, v);
        }
    }
    THREE.setValue4fv = setValue4fv;
    // Single matrix (from flat array or MatrixN)
    function setValue2fm(gl, v) {
        var cache = this.cache;
        var elements = v.elements;
        if (elements === undefined) {
            if (arraysEqual(cache, v))
                return;
            gl.uniformMatrix2fv(this.addr, false, v);
            copyArray(cache, v);
        }
        else {
            if (arraysEqual(cache, elements))
                return;
            mat2array.set(elements);
            gl.uniformMatrix2fv(this.addr, false, mat2array);
            copyArray(cache, elements);
        }
    }
    THREE.setValue2fm = setValue2fm;
    function setValue3fm(gl, v) {
        var cache = this.cache;
        var elements = v.elements;
        if (elements === undefined) {
            if (arraysEqual(cache, v))
                return;
            gl.uniformMatrix3fv(this.addr, false, v);
            copyArray(cache, v);
        }
        else {
            if (arraysEqual(cache, elements))
                return;
            mat3array.set(elements);
            gl.uniformMatrix3fv(this.addr, false, mat3array);
            copyArray(cache, elements);
        }
    }
    THREE.setValue3fm = setValue3fm;
    function setValue4fm(gl, v) {
        var cache = this.cache;
        var elements = v.elements;
        if (elements === undefined) {
            if (arraysEqual(cache, v))
                return;
            gl.uniformMatrix4fv(this.addr, false, v);
            copyArray(cache, v);
        }
        else {
            if (arraysEqual(cache, elements))
                return;
            mat4array.set(elements);
            gl.uniformMatrix4fv(this.addr, false, mat4array);
            copyArray(cache, elements);
        }
    }
    THREE.setValue4fm = setValue4fm;
    // Single texture (2D / Cube)
    function setValueT1(gl, v, renderer) {
        var unit = renderer.allocTextureUnit();
        if (this.cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            this.cache[0] = unit;
        }
        renderer.setTexture2D(v || emptyTexture, unit);
    }
    THREE.setValueT1 = setValueT1;
    function setValueT6(gl, v, renderer) {
        var unit = renderer.allocTextureUnit();
        if (this.cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            this.cache[0] = unit;
        }
        renderer.setTextureCube(v || emptyCubeTexture, unit);
    }
    THREE.setValueT6 = setValueT6;
    // Integer / Boolean vectors or arrays thereof (always flat arrays)
    function setValue2iv(gl, v) {
        if (arraysEqual(this.cache, v))
            return;
        gl.uniform2iv(this.addr, v);
        copyArray(this.cache, v);
    }
    THREE.setValue2iv = setValue2iv;
    function setValue3iv(gl, v) {
        if (arraysEqual(this.cache, v))
            return;
        gl.uniform3iv(this.addr, v);
        copyArray(this.cache, v);
    }
    THREE.setValue3iv = setValue3iv;
    function setValue4iv(gl, v) {
        if (arraysEqual(this.cache, v))
            return;
        gl.uniform4iv(this.addr, v);
        copyArray(this.cache, v);
    }
    THREE.setValue4iv = setValue4iv;
    // Helper to pick the right setter for the singular case
    function getSingularSetter(type) {
        switch (type) {
            case 0x1406: return setValue1f; // FLOAT
            case 0x8b50: return setValue2fv; // _VEC2
            case 0x8b51: return setValue3fv; // _VEC3
            case 0x8b52: return setValue4fv; // _VEC4
            case 0x8b5a: return setValue2fm; // _MAT2
            case 0x8b5b: return setValue3fm; // _MAT3
            case 0x8b5c: return setValue4fm; // _MAT4
            case 0x8b5e:
            case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
            case 0x8b60: return setValueT6; // SAMPLER_CUBE
            case 0x1404:
            case 0x8b56: return setValue1i; // INT, BOOL
            case 0x8b53:
            case 0x8b57: return setValue2iv; // _VEC2
            case 0x8b54:
            case 0x8b58: return setValue3iv; // _VEC3
            case 0x8b55:
            case 0x8b59: return setValue4iv; // _VEC4
        }
    }
    THREE.getSingularSetter = getSingularSetter;
    // Array of scalars
    function setValue1fv(gl, v) {
        gl.uniform1fv(this.addr, v);
    }
    THREE.setValue1fv = setValue1fv;
    function setValue1iv(gl, v) {
        gl.uniform1iv(this.addr, v);
    }
    THREE.setValue1iv = setValue1iv;
    // Array of vectors (flat or from THREE classes)
    function setValueV2a(gl, v) {
        gl.uniform2fv(this.addr, flatten(v, this.size, 2));
    }
    THREE.setValueV2a = setValueV2a;
    function setValueV3a(gl, v) {
        gl.uniform3fv(this.addr, flatten(v, this.size, 3));
    }
    THREE.setValueV3a = setValueV3a;
    function setValueV4a(gl, v) {
        gl.uniform4fv(this.addr, flatten(v, this.size, 4));
    }
    THREE.setValueV4a = setValueV4a;
    // Array of matrices (flat or from THREE clases)
    function setValueM2a(gl, v) {
        gl.uniformMatrix2fv(this.addr, false, flatten(v, this.size, 4));
    }
    THREE.setValueM2a = setValueM2a;
    function setValueM3a(gl, v) {
        gl.uniformMatrix3fv(this.addr, false, flatten(v, this.size, 9));
    }
    THREE.setValueM3a = setValueM3a;
    function setValueM4a(gl, v) {
        gl.uniformMatrix4fv(this.addr, false, flatten(v, this.size, 16));
    }
    THREE.setValueM4a = setValueM4a;
    // Array of textures (2D / Cube)
    function setValueT1a(gl, v, renderer) {
        var n = v.length, units = allocTexUnits(renderer, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) {
            renderer.setTexture2D(v[i] || emptyTexture, units[i]);
        }
    }
    THREE.setValueT1a = setValueT1a;
    function setValueT6a(gl, v, renderer) {
        var n = v.length, units = allocTexUnits(renderer, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) {
            renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
        }
    }
    THREE.setValueT6a = setValueT6a;
    // Helper to pick the right setter for a pure (bottom-level) array
    function getPureArraySetter(type) {
        switch (type) {
            case 0x1406: return setValue1fv; // FLOAT
            case 0x8b50: return setValueV2a; // _VEC2
            case 0x8b51: return setValueV3a; // _VEC3
            case 0x8b52: return setValueV4a; // _VEC4
            case 0x8b5a: return setValueM2a; // _MAT2
            case 0x8b5b: return setValueM3a; // _MAT3
            case 0x8b5c: return setValueM4a; // _MAT4
            case 0x8b5e: return setValueT1a; // SAMPLER_2D
            case 0x8b60: return setValueT6a; // SAMPLER_CUBE
            case 0x1404:
            case 0x8b56: return setValue1iv; // INT, BOOL
            case 0x8b53:
            case 0x8b57: return setValue2iv; // _VEC2
            case 0x8b54:
            case 0x8b58: return setValue3iv; // _VEC3
            case 0x8b55:
            case 0x8b59: return setValue4iv; // _VEC4
        }
    }
    THREE.getPureArraySetter = getPureArraySetter;
    // --- Top-level ---
    // Parser - builds up the property tree from the path strings
    var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
    // extracts
    // 	- the identifier (member name or array index)
    //  - followed by an optional right bracket (found when array index)
    //  - followed by an optional left bracket or dot (type of subscript)
    //
    // Note: These portions can be read in a non-overlapping fashion and
    // allow straightforward parsing of the hierarchy that WebGL encodes
    // in the uniform names.
    function addUniform(container, uniformObject) {
        container.seq.push(uniformObject);
        container.map[uniformObject.id] = uniformObject;
    }
    THREE.addUniform = addUniform;
    /**
     * 存入当前激活的uniform列表
     * @param activeInfo
     * @param addr
     * @param container
     */
    function parseUniform(activeInfo, addr, container) {
        var path = activeInfo.name, pathLength = path.length;
        // reset RegExp object, because of the early exit of a previous run
        RePathPart.lastIndex = 0;
        while (true) {
            var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = match[2] === ']', subscript = match[3];
            if (idIsIndex)
                id = id | 0; // convert to integer
            if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
                // bare name or "pure" bottom-level array "[0]" suffix
                addUniform(container, subscript === undefined ?
                    new SingleUniform(id, activeInfo, addr) :
                    new PureArrayUniform(id, activeInfo, addr));
                break;
            }
            else {
                // step into inner node / create it in case it doesn't exist
                var map = container.map, next = map[id];
                if (next === undefined) {
                    next = new StructuredUniform(id);
                    addUniform(container, next);
                }
                container = next;
            }
        }
    }
    THREE.parseUniform = parseUniform;
    // --- Uniform Classes ---
    class SingleUniform {
        constructor(id, activeInfo, addr) {
            this.id = id;
            this.addr = addr;
            this.cache = [];
            this.setValue = getSingularSetter(activeInfo.type);
            // this.path = activeInfo.name; // DEBUG
        }
    }
    THREE.SingleUniform = SingleUniform;
    class PureArrayUniform {
        constructor(id, activeInfo, addr) {
            this.id = id;
            this.addr = addr;
            this.size = activeInfo.size;
            this.setValue = getPureArraySetter(activeInfo.type);
            // this.path = activeInfo.name; // DEBUG
        }
    }
    THREE.PureArrayUniform = PureArrayUniform;
    // --- Base for inner nodes (including the root) ---
    class UniformContainer {
        constructor() {
            this.seq = [];
            this.map = {};
        }
    }
    THREE.UniformContainer = UniformContainer;
    class StructuredUniform extends UniformContainer {
        constructor(id) {
            super();
            this.id = id;
        }
        setValue(gl, value) {
            // Note: Don't need an extra 'renderer' parameter, since samplers
            // are not allowed in structured uniforms.
            var seq = this.seq;
            for (var i = 0, n = seq.length; i !== n; ++i) {
                var u = seq[i];
                u.setValue(gl, value[u.id]);
            }
        }
    }
    THREE.StructuredUniform = StructuredUniform;
    // Root Container
    class WebGLUniformsNode extends UniformContainer {
        constructor(gl, program, renderer) {
            super();
            this.setValue = function (gl, name, value) {
                var u = this.map[name];
                if (u !== undefined)
                    u.setValue(gl, value, this.renderer);
            };
            this.setOptional = function (gl, object, name) {
                var v = object[name];
                if (v !== undefined)
                    this.setValue(gl, name, v);
            };
            // UniformContainer.call(this);
            this.renderer = renderer;
            var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
            for (var i = 0; i < n; ++i) {
                var info = gl.getActiveUniform(program, i);
                var addr = gl.getUniformLocation(program, info.name);
                parseUniform(info, addr, this);
            }
        }
    }
    // Static interface
    /**
     * 把 material的uniform向uniform中传递
     */
    WebGLUniformsNode.upload = function (gl, uniformsList, material_uniforms, renderer) {
        for (var i = 0, n = uniformsList.length; i !== n; ++i) {
            var u = uniformsList[i], v = material_uniforms[u.id];
            if (v.needsUpdate !== false) {
                // note: always updating when .needsUpdate is undefined
                u.setValue(gl, v.value, renderer);
            }
        }
    };
    /**
     * 找出激活uniforms中与material_uniforms重合的部分
     */
    WebGLUniformsNode.seqWithValue = function (active_uniforms, values) {
        var r = [];
        for (var i = 0, n = active_uniforms.length; i !== n; ++i) {
            var u = active_uniforms[i];
            if (u.id in values)
                r.push(u);
        }
        return r;
    };
    THREE.WebGLUniformsNode = WebGLUniformsNode;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebGLUtils {
        constructor(gl, extensions) {
            function convert(p) {
                var extension;
                if (p === THREE.RepeatWrapping)
                    return gl.REPEAT;
                if (p === THREE.ClampToEdgeWrapping)
                    return gl.CLAMP_TO_EDGE;
                if (p === THREE.MirroredRepeatWrapping)
                    return gl.MIRRORED_REPEAT;
                if (p === THREE.NearestFilter)
                    return gl.NEAREST;
                if (p === THREE.NearestMipMapNearestFilter)
                    return gl.NEAREST_MIPMAP_NEAREST;
                if (p === THREE.NearestMipMapLinearFilter)
                    return gl.NEAREST_MIPMAP_LINEAR;
                if (p === THREE.LinearFilter)
                    return gl.LINEAR;
                if (p === THREE.LinearMipMapNearestFilter)
                    return gl.LINEAR_MIPMAP_NEAREST;
                if (p === THREE.LinearMipMapLinearFilter)
                    return gl.LINEAR_MIPMAP_LINEAR;
                if (p === THREE.UnsignedByteType)
                    return gl.UNSIGNED_BYTE;
                if (p === THREE.UnsignedShort4444Type)
                    return gl.UNSIGNED_SHORT_4_4_4_4;
                if (p === THREE.UnsignedShort5551Type)
                    return gl.UNSIGNED_SHORT_5_5_5_1;
                if (p === THREE.UnsignedShort565Type)
                    return gl.UNSIGNED_SHORT_5_6_5;
                if (p === THREE.ByteType)
                    return gl.BYTE;
                if (p === THREE.ShortType)
                    return gl.SHORT;
                if (p === THREE.UnsignedShortType)
                    return gl.UNSIGNED_SHORT;
                if (p === THREE.IntType)
                    return gl.INT;
                if (p === THREE.UnsignedIntType)
                    return gl.UNSIGNED_INT;
                if (p === THREE.FloatType)
                    return gl.FLOAT;
                if (p === THREE.HalfFloatType) {
                    extension = extensions.get('OES_texture_half_float');
                    if (extension !== null)
                        return extension.HALF_FLOAT_OES;
                }
                if (p === THREE.AlphaFormat)
                    return gl.ALPHA;
                if (p === THREE.RGBFormat)
                    return gl.RGB;
                if (p === THREE.RGBAFormat)
                    return gl.RGBA;
                if (p === THREE.LuminanceFormat)
                    return gl.LUMINANCE;
                if (p === THREE.LuminanceAlphaFormat)
                    return gl.LUMINANCE_ALPHA;
                if (p === THREE.DepthFormat)
                    return gl.DEPTH_COMPONENT;
                if (p === THREE.DepthStencilFormat)
                    return gl.DEPTH_STENCIL;
                if (p === THREE.AddEquation)
                    return gl.FUNC_ADD;
                if (p === THREE.SubtractEquation)
                    return gl.FUNC_SUBTRACT;
                if (p === THREE.ReverseSubtractEquation)
                    return gl.FUNC_REVERSE_SUBTRACT;
                if (p === THREE.ZeroFactor)
                    return gl.ZERO;
                if (p === THREE.OneFactor)
                    return gl.ONE;
                if (p === THREE.SrcColorFactor)
                    return gl.SRC_COLOR;
                if (p === THREE.OneMinusSrcColorFactor)
                    return gl.ONE_MINUS_SRC_COLOR;
                if (p === THREE.SrcAlphaFactor)
                    return gl.SRC_ALPHA;
                if (p === THREE.OneMinusSrcAlphaFactor)
                    return gl.ONE_MINUS_SRC_ALPHA;
                if (p === THREE.DstAlphaFactor)
                    return gl.DST_ALPHA;
                if (p === THREE.OneMinusDstAlphaFactor)
                    return gl.ONE_MINUS_DST_ALPHA;
                if (p === THREE.DstColorFactor)
                    return gl.DST_COLOR;
                if (p === THREE.OneMinusDstColorFactor)
                    return gl.ONE_MINUS_DST_COLOR;
                if (p === THREE.SrcAlphaSaturateFactor)
                    return gl.SRC_ALPHA_SATURATE;
                if (p === THREE.RGB_S3TC_DXT1_Format || p === THREE.RGBA_S3TC_DXT1_Format ||
                    p === THREE.RGBA_S3TC_DXT3_Format || p === THREE.RGBA_S3TC_DXT5_Format) {
                    extension = extensions.get('WEBGL_compressed_texture_s3tc');
                    if (extension !== null) {
                        if (p === THREE.RGB_S3TC_DXT1_Format)
                            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (p === THREE.RGBA_S3TC_DXT1_Format)
                            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (p === THREE.RGBA_S3TC_DXT3_Format)
                            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (p === THREE.RGBA_S3TC_DXT5_Format)
                            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    }
                }
                if (p === THREE.RGB_PVRTC_4BPPV1_Format || p === THREE.RGB_PVRTC_2BPPV1_Format ||
                    p === THREE.RGBA_PVRTC_4BPPV1_Format || p === THREE.RGBA_PVRTC_2BPPV1_Format) {
                    extension = extensions.get('WEBGL_compressed_texture_pvrtc');
                    if (extension !== null) {
                        if (p === THREE.RGB_PVRTC_4BPPV1_Format)
                            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (p === THREE.RGB_PVRTC_2BPPV1_Format)
                            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (p === THREE.RGBA_PVRTC_4BPPV1_Format)
                            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (p === THREE.RGBA_PVRTC_2BPPV1_Format)
                            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                    }
                }
                if (p === THREE.RGB_ETC1_Format) {
                    extension = extensions.get('WEBGL_compressed_texture_etc1');
                    if (extension !== null)
                        return extension.COMPRESSED_RGB_ETC1_WEBGL;
                }
                if (p === THREE.RGBA_ASTC_4x4_Format || p === THREE.RGBA_ASTC_5x4_Format || p === THREE.RGBA_ASTC_5x5_Format ||
                    p === THREE.RGBA_ASTC_6x5_Format || p === THREE.RGBA_ASTC_6x6_Format || p === THREE.RGBA_ASTC_8x5_Format ||
                    p === THREE.RGBA_ASTC_8x6_Format || p === THREE.RGBA_ASTC_8x8_Format || p === THREE.RGBA_ASTC_10x5_Format ||
                    p === THREE.RGBA_ASTC_10x6_Format || p === THREE.RGBA_ASTC_10x8_Format || p === THREE.RGBA_ASTC_10x10_Format ||
                    p === THREE.RGBA_ASTC_12x10_Format || p === THREE.RGBA_ASTC_12x12_Format) {
                    extension = extensions.get('WEBGL_compressed_texture_astc');
                    if (extension !== null) {
                        return p;
                    }
                }
                if (p === THREE.MinEquation || p === THREE.MaxEquation) {
                    extension = extensions.get('EXT_blend_minmax');
                    if (extension !== null) {
                        if (p === THREE.MinEquation)
                            return extension.MIN_EXT;
                        if (p === THREE.MaxEquation)
                            return extension.MAX_EXT;
                    }
                }
                if (p === THREE.UnsignedInt248Type) {
                    extension = extensions.get('WEBGL_depth_texture');
                    if (extension !== null)
                        return extension.UNSIGNED_INT_24_8_WEBGL;
                }
                return 0;
            }
            return { convert: convert };
        }
    }
    THREE.WebGLUtils = WebGLUtils;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebglContextAttibutes {
        constructor() {
        }
    }
    THREE.WebglContextAttibutes = WebglContextAttibutes;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    function addLineNumbers(string) {
        var lines = string.split('\n');
        for (var i = 0; i < lines.length; i++) {
            lines[i] = (i + 1) + ': ' + lines[i];
        }
        return lines.join('\n');
    }
    function webGLCreateShader(gl, type, string) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, string);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
            console.error('THREE.WebGLShader: Shader couldn\'t compile.');
        }
        if (gl.getShaderInfoLog(shader) !== '') {
            console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));
        }
        // --enable-privileged-webgl-extension
        // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
        return shader;
    }
    THREE.webGLCreateShader = webGLCreateShader;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebVRManager {
        constructor(renderer) {
            this.renderer = renderer;
            var scope = this;
            this.device = null;
            this.frameData = null;
            this.poseTarget = null;
            this.standingMatrix = new THREE.Matrix4();
            this.standingMatrixInverse = new THREE.Matrix4();
            if (typeof window !== 'undefined' && 'VRFrameData' in window) {
                this.frameData = new window.VRFrameData();
                window.addEventListener('vrdisplaypresentchange', this.onVRDisplayPresentChange, false);
            }
            this.matrixWorldInverse = new THREE.Matrix4();
            this.tempQuaternion = new THREE.Quaternion();
            this.tempPosition = new THREE.Vector3();
            this.cameraL = new THREE.PerspectiveCamera(null, null, null, null);
            this.cameraL.bounds = new THREE.Vector4(0.0, 0.0, 0.5, 1.0);
            this.cameraL.layers.enable(1);
            this.cameraR = new THREE.PerspectiveCamera(null, null, null, null);
            this.cameraR.bounds = new THREE.Vector4(0.5, 0.0, 0.5, 1.0);
            this.cameraR.layers.enable(2);
            this.cameraVR = new THREE.ArrayCamera([this.cameraL, this.cameraR]);
            this.cameraVR.layers.enable(1);
            this.cameraVR.layers.enable(2);
            //
            this.enabled = false;
            this.userHeight = 1.6;
        }
        isPresenting() {
            return this.device !== null && this.device.isPresenting === true;
        }
        onVRDisplayPresentChange() {
            if (this.isPresenting()) {
                var eyeParameters = this.device.getEyeParameters('left');
                var renderWidth = eyeParameters.renderWidth;
                var renderHeight = eyeParameters.renderHeight;
                this.currentPixelRatio = this.renderer.getPixelRatio();
                this.currentSize = this.renderer.getSize();
                this.renderer.setDrawingBufferSize(renderWidth * 2, renderHeight, 1);
            }
            else if (this.enabled) {
                this.renderer.setDrawingBufferSize(this.currentSize.width, this.currentSize.height, this.currentPixelRatio);
            }
        }
        getDevice() {
            return this.device;
        }
        ;
        setDevice(value) {
            if (value !== undefined)
                this.device = value;
        }
        ;
        setPoseTarget(object) {
            if (object !== undefined)
                this.poseTarget = object;
        }
        ;
        getCamera(camera) {
            if (this.device === null)
                return camera;
            this.device.depthNear = camera.near;
            this.device.depthFar = camera.far;
            this.device.getFrameData(this.frameData);
            //
            var stageParameters = this.device.stageParameters;
            if (stageParameters) {
                this.standingMatrix.fromArray(stageParameters.sittingToStandingTransform);
            }
            else {
                this.standingMatrix.makeTranslation(0, this.userHeight, 0);
            }
            var pose = this.frameData.pose;
            var poseObject = this.poseTarget !== null ? this.poseTarget : camera;
            // We want to manipulate poseObject by its position and quaternion components since users may rely on them.
            poseObject.matrix.copy(this.standingMatrix);
            poseObject.matrix.decompose(poseObject.position, poseObject.quaternion, poseObject.scale);
            if (pose.orientation !== null) {
                this.tempQuaternion.fromArray(pose.orientation);
                poseObject.quaternion.multiply(this.tempQuaternion);
            }
            if (pose.position !== null) {
                this.tempQuaternion.setFromRotationMatrix(this.standingMatrix);
                this.tempPosition.fromArray(pose.position);
                this.tempPosition.applyQuaternion(this.tempQuaternion);
                poseObject.position.add(this.tempPosition);
            }
            poseObject.updateMatrixWorld();
            if (this.device.isPresenting === false)
                return camera;
            //
            this.cameraL.near = camera.near;
            this.cameraR.near = camera.near;
            this.cameraL.far = camera.far;
            this.cameraR.far = camera.far;
            this.cameraVR.matrixWorld.copy(camera.matrixWorld);
            this.cameraVR.matrixWorldInverse.copy(camera.matrixWorldInverse);
            this.cameraL.matrixWorldInverse.fromArray(this.frameData.leftViewMatrix);
            this.cameraR.matrixWorldInverse.fromArray(this.frameData.rightViewMatrix);
            // TODO (mrdoob) Double check this code
            this.standingMatrixInverse.getInverse(this.standingMatrix);
            this.cameraL.matrixWorldInverse.multiply(this.standingMatrixInverse);
            this.cameraR.matrixWorldInverse.multiply(this.standingMatrixInverse);
            var parent = poseObject.parent;
            if (parent !== null) {
                this.matrixWorldInverse.getInverse(parent.matrixWorld);
                this.cameraL.matrixWorldInverse.multiply(this.matrixWorldInverse);
                this.cameraR.matrixWorldInverse.multiply(this.matrixWorldInverse);
            }
            // envMap and Mirror needs camera.matrixWorld
            this.cameraL.matrixWorld.getInverse(this.cameraL.matrixWorldInverse);
            this.cameraR.matrixWorld.getInverse(this.cameraR.matrixWorldInverse);
            this.cameraL.projectionMatrix.fromArray(this.frameData.leftProjectionMatrix);
            this.cameraR.projectionMatrix.fromArray(this.frameData.rightProjectionMatrix);
            // HACK (mrdoob)
            // https://github.com/w3c/webvr/issues/203
            this.cameraVR.projectionMatrix.copy(this.cameraL.projectionMatrix);
            //
            var layers = this.device.getLayers();
            if (layers.length) {
                var layer = layers[0];
                if (layer.leftBounds !== null && layer.leftBounds.length === 4) {
                    this.cameraL.bounds.fromArray(layer.leftBounds);
                }
                if (layer.rightBounds !== null && layer.rightBounds.length === 4) {
                    this.cameraR.bounds.fromArray(layer.rightBounds);
                }
            }
            return this.cameraVR;
        }
        ;
        getStandingMatrix() {
            return this.standingMatrix;
        }
        ;
        requestAnimationFrame(callback) {
            this.device.requestAnimationFrame(callback);
        }
        ;
        submitFrame() {
            if (this.isPresenting())
                this.device.submitFrame();
        }
        ;
        dispose() {
            if (typeof window !== 'undefined') {
                window.removeEventListener('vrdisplaypresentchange', this.onVRDisplayPresentChange);
            }
        }
        ;
    }
    THREE.WebVRManager = WebVRManager;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class WebXRManager {
        constructor(gl) {
            var scope = this;
            this.gl = gl;
            this.device = null;
            this.session = null;
            this.frameOfRef = null;
            this.isExclusive = false;
            this.pose = null;
            //
            this.cameraL = new THREE.PerspectiveCamera(null, null, null, null);
            this.cameraL.layers.enable(1);
            this.cameraL.viewport = new THREE.Vector4();
            this.cameraR = new THREE.PerspectiveCamera(null, null, null, null);
            this.cameraR.layers.enable(2);
            this.cameraR.viewport = new THREE.Vector4();
            var cameraVR = new THREE.ArrayCamera([this.cameraL, this.cameraR]);
            cameraVR.layers.enable(1);
            cameraVR.layers.enable(2);
            //
            this.enabled = false;
        }
        isPresenting() {
            return this.session !== null && this.frameOfRef !== null;
        }
        getDevice() {
            return this.device;
        }
        ;
        setDevice(value) {
            if (value !== undefined)
                this.device = value;
            this.gl.setCompatibleXRDevice(value);
        }
        ;
        setSession(value) {
            this.session = value;
            if (this.session !== null) {
                this.session.baseLayer = new XRWebGLLayer(this.session, this.gl);
                this.session.requestFrameOfReference('stage').then(function (value) {
                    this.frameOfRef = value;
                    this.isExclusive = this.session.exclusive;
                });
            }
        }
        ;
        getCamera(camera) {
            return this.isPresenting() ? this.cameraVR : camera;
        }
        ;
        onFrame(time, frame) {
            this.pose = frame.getDevicePose(this.frameOfRef);
            var layer = this.session.baseLayer;
            var views = frame.views;
            for (var i = 0; i < views.length; i++) {
                var view = views[i];
                var viewport = layer.getViewport(view);
                var viewMatrix = this.pose.getViewMatrix(view);
                var camera = this.cameraVR.cameras[i];
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.matrixWorldInverse.fromArray(viewMatrix);
                camera.matrixWorld.getInverse(camera.matrixWorldInverse);
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i === 0) {
                    this.cameraVR.matrixWorld.copy(camera.matrixWorld);
                    this.cameraVR.matrixWorldInverse.copy(camera.matrixWorldInverse);
                    // HACK (mrdoob)
                    // https://github.com/w3c/webvr/issues/203
                    this.cameraVR.projectionMatrix.copy(camera.projectionMatrix);
                }
            }
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.session.baseLayer.framebuffer);
            if (this.framCallback) {
                this.framCallback();
            }
        }
        requestAnimationFrame(callback) {
            this.framCallback = callback;
            this.session.requestAnimationFrame(this.onFrame);
        }
        ;
        // DEPRECATED
        getStandingMatrix() {
            console.warn('THREE.WebXRManager: getStandingMatrix() is no longer needed.');
            return new THREE.Matrix4();
        }
        ;
        submitFrame() { }
        ;
    }
    THREE.WebXRManager = WebXRManager;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Fog {
        constructor(color, near, far) {
            this.isFog = true;
            this.name = '';
            this.color = new THREE.Color(color);
            this.near = (near !== undefined) ? near : 1;
            this.far = (far !== undefined) ? far : 1000;
        }
        clone() {
            return new Fog(this.color, this.near, this.far);
        }
        toJSON( /* meta */) {
            return {
                type: 'Fog',
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            };
        }
    }
    THREE.Fog = Fog;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class FogExp2 {
        constructor(color, density) {
            this.isFogExp2 = true;
            this.name = '';
            this.color = new THREE.Color(color);
            this.density = (density !== undefined) ? density : 0.00025;
        }
        clone() {
            return new FogExp2(this.color, this.density);
        }
        toJSON( /* meta */) {
            return {
                type: 'FogExp2',
                color: this.color.getHex(),
                density: this.density
            };
        }
    }
    THREE.FogExp2 = FogExp2;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class Scene extends THREE.Object3D {
        constructor() {
            super();
            this.type = 'Scene';
            this.background = null;
            this.fog = null;
            this.overrideMaterial = null;
            this.autoUpdate = true; // checked by the renderer
        }
        /**
         * 复制
         * @param source
         * @param recursive
         */
        copy(source, recursive) {
            super.copy(source, recursive);
            if (source.background !== null)
                this.background = source.background.clone();
            if (source.fog !== null)
                this.fog = source.fog.clone();
            if (source.overrideMaterial !== null)
                this.overrideMaterial = source.overrideMaterial.clone();
            this.autoUpdate = source.autoUpdate;
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            return this;
        }
        /**
         * 生成json文件
         * @param meta
         */
        toJSON(meta) {
            var data = super.toJSON(meta);
            if (this.background !== null)
                data.object.background = this.background.toJSON(meta);
            if (this.fog !== null)
                data.object.fog = this.fog.toJSON();
            return data;
        }
    }
    THREE.Scene = Scene;
})(THREE || (THREE = {}));
/// <reference path="./Texture.ts" />
var THREE;
/// <reference path="./Texture.ts" />
(function (THREE) {
    class CanvasTexture extends THREE.Texture {
        constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
            super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
            this.isCanvasTexture = true;
            this.needsUpdate = true;
        }
    }
    THREE.CanvasTexture = CanvasTexture;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class CompressedTexture extends THREE.Texture {
        constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
            super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
            this.isCompressedTexture = true;
            this.image = { width: width, height: height };
            this.mipmaps = mipmaps;
            // no flipping for cube textures
            // (also flipping doesn't work for compressed textures )
            this.flipY = false;
            // can't generate mipmaps for compressed textures
            // mips must be embedded in DDS files
            this.generateMipmaps = false;
        }
    }
    THREE.CompressedTexture = CompressedTexture;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class DataTexture extends THREE.Texture {
        constructor(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
            super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
            this.isDataTexture = true;
            this.image = { data: data, width: width, height: height };
            this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
            this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
            this.generateMipmaps = false;
            this.flipY = false;
            this.unpackAlignment = 1;
        }
    }
    THREE.DataTexture = DataTexture;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class DepthTexture extends THREE.Texture {
        constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
            super(null, mapping, wrapS, wrapT, magFilter, minFilter, format !== undefined ? format : THREE.DepthFormat, (type === undefined && format === THREE.DepthFormat) ? THREE.UnsignedShortType : ((type === undefined && format === THREE.DepthStencilFormat) ? THREE.UnsignedInt248Type : type), anisotropy);
            this.isDepthTexture = true;
            format = format !== undefined ? format : THREE.DepthFormat;
            if (format !== THREE.DepthFormat && format !== THREE.DepthStencilFormat) {
                throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
            }
            if (type === undefined && format === THREE.DepthFormat)
                type = THREE.UnsignedShortType;
            if (type === undefined && format === THREE.DepthStencilFormat)
                type = THREE.UnsignedInt248Type;
            this.image = { width: width, height: height };
            this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
            this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
            this.flipY = false;
            this.generateMipmaps = false;
        }
    }
    THREE.DepthTexture = DepthTexture;
})(THREE || (THREE = {}));
var THREE;
(function (THREE) {
    class VideoTexture extends THREE.Texture {
        constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
            super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
            this.isVideoTexture = true;
            this.generateMipmaps = false;
        }
        update() {
            var video = this.image;
            if (video.readyState >= video.HAVE_CURRENT_DATA) {
                this.needsUpdate = true;
            }
        }
    }
    THREE.VideoTexture = VideoTexture;
})(THREE || (THREE = {}));
//# sourceMappingURL=three.js.map